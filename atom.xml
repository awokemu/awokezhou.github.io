<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>awokezhou&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-07T08:43:15.640Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>awokezhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python通过注册表获取串口列表</title>
    <link href="http://yoursite.com/2022/03/07/Python%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E4%B8%B2%E5%8F%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/03/07/Python通过注册表获取串口列表/</id>
    <published>2022-03-07T08:24:36.000Z</published>
    <updated>2022-03-07T08:43:15.640Z</updated>
    
    <content type="html"><![CDATA[<p>工作中需要使用CameraLink协议中的串口和设备进行通信，DALSA采集卡软件中可以将该串口映射到一个COM口上，但是该COM口在Windows的设备管理器中无法识别。使用Python的serial模块或者npm的serialport模块自带枚举函数都无法获取到该COM口。</p><p>JavaScript中，使用以下代码定时轮询串口列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> serialport <span class="keyword">from</span> <span class="string">&#x27;serialport&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    serialport.list().then(</span><br><span class="line">        <span class="function"><span class="params">ports</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ports.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>Python中，使用以下代码获取串口列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line"></span><br><span class="line">plist = <span class="built_in">list</span>(serial.tools.list_ports.comports())</span><br><span class="line">ports = [p.name <span class="keyword">for</span> p <span class="keyword">in</span> plist]</span><br></pre></td></tr></table></figure><p>以上方式都无法获取采集卡映射的COM口。Python中可以使用win32api和win32con通过枚举注册表中的信息来获取串口列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serial_ports</span>():</span></span><br><span class="line">    ports = []</span><br><span class="line">    key = win32api.RegOpenKey(win32con.HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;HARDWARE\DEVICEMAP\SERIALCOMN&quot;</span>, <span class="number">0</span>, win32con.KEY_READ)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            name, value, type1 = win32api.RegEnumValue(key, i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;name:&#123;&#125; value:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, value))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            ports.append(value)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;except&#x27;</span>)</span><br><span class="line">    win32api.RegCloseKey(key)</span><br><span class="line">    <span class="keyword">return</span> ports</span><br></pre></td></tr></table></figure><p>使用<code>RegOpenKey</code>接口来读取键值，使用完毕后需要用<code>RegCloseKey</code>关闭。通过<code>RegEnumValue</code>来枚举串口列表，COM口名称在value字段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中需要使用CameraLink协议中的串口和设备进行通信，DALSA采集卡软件中可以将该串口映射到一个COM口上，但是该COM口在Windows的设备管理器中无法识别。使用Python的serial模块或者npm的serialport模块自带枚举函数都无法获取到该COM
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Microblaze优化选项</title>
    <link href="http://yoursite.com/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/"/>
    <id>http://yoursite.com/2021/11/04/Microblaze优化选项/</id>
    <published>2021-11-04T09:21:12.000Z</published>
    <updated>2021-11-17T02:43:21.364Z</updated>
    
    <content type="html"><![CDATA[<p>Microblaze提供了一些优化选项，正确理解这些选项的含义以及作用对于开发过程有很多帮助，本文主要总结介绍Microblaze Configuration Wizard中的选项内容</p><h2 id="预定义配置"><a href="#预定义配置" class="headerlink" title="预定义配置"></a>预定义配置</h2><p>根据具体使用场景的不同，Microblaze提供了一些预定义的配置选项供用户选择</p><ul><li><p>Microcontroller Preset</p></li><li><p>Real-time Preset</p></li><li><p>Application Preset</p></li><li><p>Minimum Area</p></li><li><p>Maximum Performance</p></li><li><p>Maximum Frequency</p></li><li><p>Linux with MMU</p></li><li><p>Low-end Linux with MMU</p></li><li><p>Typical</p></li><li><p>Frequency Optimized</p></li></ul><p>这些选项实际上是Microblaze在频率、面积、性能这几个指标不同侧重情况下，对各个配置项的组合。选择Current Settings即为自定义模式</p><h2 id="Implementation-Optimization"><a href="#Implementation-Optimization" class="headerlink" title="Implementation Optimization"></a>Implementation Optimization</h2><p>该选项可选以下3种：</p><ul><li><p>Performance</p></li><li><p>Area</p></li><li><p>Frequency</p></li></ul><p>这个选项非常重要，它与Microblaze的流水线级数对应</p><ul><li><p>3级流水线：Area</p></li><li><p>5级流水线：Performance</p></li><li><p>8级流水线：Frequency</p></li></ul><h3 id="三级流水线"><a href="#三级流水线" class="headerlink" title="三级流水线"></a>三级流水线</h3><p>三级流水线对应Area，使用了最小化的硬件花费，只有取址(Fetch)、译码(Decode)和执行(Execute)</p><p><img src="/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/images\01.PNG" alt></p><p>三级流水线没有数据阻塞，只有控制流程阻塞、多指令结构性阻塞和访问较慢的内存、从较慢的内存取址等情况。多周期的指令类别有桶形移位器(barrel shift)、乘法器(multiply)、除法器(divide)和浮点指令</p><h3 id="五级流水线"><a href="#五级流水线" class="headerlink" title="五级流水线"></a>五级流水线</h3><p>五级流水线对应Performance，最大化性能考量，包括取址(Fetch，IF)、译码(Decode OF)、执行(Execute，EX)、内存访问(Access Memory，MEM)和写回(Writeback，WB)</p><p><img src="/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/images\02.PNG" alt></p><p>五级流水线存在以下两种数据阻塞的情况</p><ul><li><p>OF指令需要EX指令的结果作为源操作数。EX指令类别为加载、存储、桶形移位器、乘法器、触发器和浮点运算。这些会导致1-2周期的阻塞</p></li><li><p>OF指令需要MEM指令的结果作为源操作数。MEM指令类别包括加载、乘法器和浮点运算。这些会导致1个周期的阻塞</p></li></ul><p>多周期指令有除法器和浮点运算</p><h3 id="八级流水线"><a href="#八级流水线" class="headerlink" title="八级流水线"></a>八级流水线</h3><p>八级流水线对应Frequency，用于最大化频率，包括取址(Fetch，IF)、译码(Decode OF)、执行(Execute，EX)、内存访问0(Access Memory 0，M0)、内存访问1(Access Memory 1，M1)、内存访问2(Access Memory 2，M2)、内存访问3(Access Memory 3，M3)和写回(Writeback，WB)</p><p><img src="/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/images\03.PNG" alt></p><p>八级流水线存在以下四种数据阻塞的情况</p><ul><li><p>OF指令需要EX指令的结果作为源操作数。EX包括加载、存储、桶形移位器、乘法器、除法器和浮点运算，会导致1-5个周期的阻塞</p></li><li><p>OF指令需要M0指令的结果作为源操作数。M0包括加载、乘法器、除法器和浮点运算，会导致1-4周期的阻塞</p></li><li><p>OF指令需要M1或M2指令的结果作为源操作数。M1或M2包括加载、除法器和浮点运算，会导致1-3或1-2周期的阻塞</p></li><li><p>OF指令需要M3指令的结果作为源操作数。M3包括加载和浮点运算，会导致1周期的阻塞</p></li></ul><p>在额外的多周期指令种，存在3种情况的结构性阻塞</p><ul><li><p>OF中的指令是流指令，EX中的指令是流、加载、存储、除法或浮点指令，并实现了相应的异常，这导致一个1周期的阻塞</p></li><li><p>OF中的指令是流指令，M0、M1、M2或M3中的指令是装载、存储、除法或浮点指令，并实现了相应的异常，这导致一个1周期的阻塞</p></li><li><p>M0中的指令是加载或存储指令，M1、M2或M3中的指令是加载、存储、除法或浮点指令，并实现了相应的异常，这导致一个1周期的阻塞</p></li></ul><p>多周期指令分为分割指令和浮点指令FDIV, FINT和FSQRT</p><h2 id="Use-Instruction-and-Data-Caches"><a href="#Use-Instruction-and-Data-Caches" class="headerlink" title="Use Instruction and Data Caches"></a>Use Instruction and Data Caches</h2><p>使用外部存储器时，激活高速缓存，可以显著提高性能，可以降低外部慢速设备访问的使用量</p><h2 id="Enable-Barrel-Shifter"><a href="#Enable-Barrel-Shifter" class="headerlink" title="Enable Barrel Shifter"></a>Enable Barrel Shifter</h2><p>使能硬件桶形移位器(Barrel Shifter)，可以提高程序在移位操作时的性能。当该选项使能时，编译器可以自动的选择使用<code>bsrl</code>、<code>bsra</code>、<code>bsll</code>、<code>bsrli</code>、<code>bsrai</code>和<code>bslli</code>等汇编指令来优化加速移位操作</p><h2 id="Enable-Floating-Point-Unit"><a href="#Enable-Floating-Point-Unit" class="headerlink" title="Enable Floating Point Unit"></a>Enable Floating Point Unit</h2><p>浮点运算单元能够提升<code>float</code>类型数据进行运算时的效率，Microblaze的FPU遵循了IEEE 754-1985标准，支持加、减、乘、除、比较、转换和平方根运算。编译器会自动根据系统选择的FPU类型使用汇编浮点指令优化浮点运算</p><h2 id="Enable-Integer-Multiplier"><a href="#Enable-Integer-Multiplier" class="headerlink" title="Enable Integer Multiplier"></a>Enable Integer Multiplier</h2><p>使用一个硬件乘法器，可以提升程序在乘法运算时的效率</p><h2 id="Enable-Integer-Divider"><a href="#Enable-Integer-Divider" class="headerlink" title="Enable Integer Divider"></a>Enable Integer Divider</h2><p>使能整型除法器，可以使用idiv和idivu指令，提升除法运算效率</p><h2 id="Enable-Additional-Machine-Status-Registers-Instructions"><a href="#Enable-Additional-Machine-Status-Registers-Instructions" class="headerlink" title="Enable Additional Machine Status Registers Instructions"></a>Enable Additional Machine Status Registers Instructions</h2><p>使能MSR寄存器指令<code>msrset</code>和<code>msrclr</code>，用于设置和清MSR的位。MSR包含了处理器的控制和状态位，读取该寄存器时bit[29]会被复制到bit[0]作为近进位复制。对MSR进行读写有两种方式，一种是使用<code>MFS</code>、<code>MTS</code>指令，另一种是使用<code>msrset</code>和<code>msrclr</code>。当使用<code>msrset</code>和<code>msrclr</code>进行写时，进位立即生效，其余位在一个时钟周期后生效。当使用<code>MTS</code>写时，所有位都在一个时钟周期后生效。程序运行会非常频繁的使用MSR，因此使能该选项可以很大程度的提升性能</p><p>例如在使用FreeRTOS时，systick或者消息队列中会频繁调用<code>microblaze_enable_interrupts</code>和<code>disable_enable_interrupts</code>函数，这两个函数是汇编函数，例如<code>microblaze_enable_interrupts</code>函数的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globlmicroblaze_enable_interrupts</span><br><span class="line">.entmicroblaze_enable_interrupts</span><br><span class="line">.align<span class="number">2</span></span><br><span class="line">microblaze_enable_interrupts:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> XPAR_MICROBLAZE_USE_MSR_INSTR == 1</span></span><br><span class="line">rtsdr15, <span class="number">8</span></span><br><span class="line">msrset  r0, <span class="number">0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/*XPAR_MICROBLAZE_USE_MSR_INSTR == 1*/</span></span></span><br><span class="line">#Read the MSR <span class="keyword">register</span></span><br><span class="line">mfsr12, rmsr</span><br><span class="line">#Set the interrupt enable bit</span><br><span class="line">orir12, r12, <span class="number">0x2</span></span><br><span class="line">#Save the MSR <span class="keyword">register</span></span><br><span class="line">mtsrmsr, r12</span><br><span class="line">#Return</span><br><span class="line">rtsdr15, <span class="number">8</span></span><br><span class="line">nop</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*XPAR_MICROBLAZE_USE_MSR_INSTR == 1*/</span></span></span><br><span class="line">.endmicroblaze_enable_interrupts</span><br></pre></td></tr></table></figure><p>可以看到，如果定义了<code>MSR_INSTR</code>，使能中断只有两条指令完成，否则需要5条指令。因此开启额外MSR指令能够在多任务系统任务切换和上下文切换方面提升性能</p><h2 id="Enable-Pattern-Comparator"><a href="#Enable-Pattern-Comparator" class="headerlink" title="Enable Pattern Comparator"></a>Enable Pattern Comparator</h2><p>使能模式比较器，可以使用<code>pcmpbf</code>、<code>pcmpeq</code>和<code>pcmpne</code>指令，提升程序在进行比较时的性能。编译器自动进行指令转换</p><h2 id="Enable-Reversed-Load-Store-and-Swap-Instructions"><a href="#Enable-Reversed-Load-Store-and-Swap-Instructions" class="headerlink" title="Enable Reversed Load/Store and Swap Instructions"></a>Enable Reversed Load/Store and Swap Instructions</h2><p>启用反向加载/存储和交换指令，可以使用<code>lbur</code>、<code>lhur</code>、<code>lwr</code>、<code>sbr</code>、<code>shr</code>、<code>swr</code>、<code>swapb</code>和<code>swawph</code>指令。反向加载/存储指令可以以相反的字节顺序读写数据，交换指令可以在寄存器中交换字节和字。这些指令在处理网络字节序(大端)和Microblaze字节序(小端)</p><p>时可以提升性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Microblaze提供了一些优化选项，正确理解这些选项的含义以及作用对于开发过程有很多帮助，本文主要总结介绍Microblaze Configuration Wizard中的选项内容&lt;/p&gt;
&lt;h2 id=&quot;预定义配置&quot;&gt;&lt;a href=&quot;#预定义配置&quot; class=&quot;h
      
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="Xilinx" scheme="http://yoursite.com/tags/Xilinx/"/>
    
  </entry>
  
  <entry>
    <title>csv读取注释</title>
    <link href="http://yoursite.com/2021/10/22/csv%E8%AF%BB%E5%8F%96%E6%B3%A8%E9%87%8A/"/>
    <id>http://yoursite.com/2021/10/22/csv读取注释/</id>
    <published>2021-10-22T10:01:52.000Z</published>
    <updated>2021-10-22T10:15:59.319Z</updated>
    
    <content type="html"><![CDATA[<p>Python的pandas库处理csv文件非常方便，开发过程中经常会用到csv文件，例如将csv中的数据转化为二进制、将csv文件转化为json等。由于csv本身是以列表的形式组织数据的，如果想要额外的加入一些描述信息，比如版本号等，应该如何做呢？</p><p>可以以key-value的形式在csv文件头部写入一些信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Version:v1<span class="number">.0</span></span><br><span class="line">#Data:<span class="number">2021</span>/<span class="number">01</span>/<span class="number">01</span></span><br><span class="line">#Author:Jam</span><br><span class="line">#Description: This is a example of csv commit</span><br></pre></td></tr></table></figure><p>利用以下函数可以从csv文件中以字典的形式获取注释中的key-value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csv_read_attrs</span>(<span class="params">filename</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    fobj = <span class="built_in">open</span>(filename)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = fobj.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        s += line</span><br><span class="line">    attrs = re.findall(<span class="string">r&#x27;#(.*)&#x27;</span>, s)</span><br><span class="line">    keys = [x.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].strip() <span class="keyword">for</span> x <span class="keyword">in</span> attrs]</span><br><span class="line">    values = [x.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>].strip() <span class="keyword">for</span> x <span class="keyword">in</span> attrs]</span><br><span class="line">    attrs = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys,values))</span><br><span class="line">    <span class="keyword">return</span> attrs</span><br></pre></td></tr></table></figure><p>将上述注释保存为test.csv文件，调用<code>csv_read_attrs</code>函数解析注释信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import csv_read_attrs from csvAttrs</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; attrs = csv_read_attrs(<span class="string">&#x27;test.csv&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; attrs</span></span><br><span class="line">&#123;&#x27;Version&#x27;: &#x27;v1.0&#x27;, &#x27;Data&#x27;: &#x27;2021/01/01&#x27;, &#x27;Author&#x27;: &#x27;Jam&#x27;, &#x27;Description&#x27;: &#x27;This is a example of csv commit&#x27;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python的pandas库处理csv文件非常方便，开发过程中经常会用到csv文件，例如将csv中的数据转化为二进制、将csv文件转化为json等。由于csv本身是以列表的形式组织数据的，如果想要额外的加入一些描述信息，比如版本号等，应该如何做呢？&lt;/p&gt;
&lt;p&gt;可以以ke
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻202110</title>
    <link href="http://yoursite.com/2021/10/15/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202110/"/>
    <id>http://yoursite.com/2021/10/15/每月见闻202110/</id>
    <published>2021-10-15T08:09:55.000Z</published>
    <updated>2021-10-15T10:25:08.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ICCV2021"><a href="#ICCV2021" class="headerlink" title="ICCV2021"></a>ICCV2021</h2><p>不久前计算机视觉三大顶会之一的ICCV2021接收结果已经公布，本次ICCV共计6236篇有效提交论文，其中有1617篇被接收，接收率为25.9%</p><p>论文共分为检测、分割、估计、跟踪、视觉定位、底层图像处理、图像视频检索、三位视觉等多个方向，<a href="https://github.com/extreme-assistant/ICCV2021-Paper-Code-Interpretation">极市团队-ICCV论文代码整理</a>该Github项目整理了所有的相关论文和代码，主要有以下方向</p><ul><li><p>2D Object Detection(2D目标检测)</p></li><li><p>3D Object Detection(3D目标检测)</p></li><li><p>Saliency Object Detection(显著性目标检测)</p></li><li><p>Camouflaged Object Detection(伪装目标检测)</p></li><li><p>Anomally Detection in Image(图像异常检测/表面缺陷检测)</p></li><li><p>Edge Detection(边缘检测)</p></li><li><p>Image Segmentation(图像分割)</p></li><li><p>Instance Segmentation(示例分割)</p></li><li><p>Semantic Segmentation(语义分割)</p></li><li><p>Video Object Segmentation(视频目标分割)</p></li><li><p>Referring Image Segmentation(参考图像分割)</p></li><li><p>Dense Prediction(密集预测)</p></li><li><p>Facial Recognition/Detection(人脸识别/检测)</p></li><li><p>Face Generation/Face Synthesis/Face Reconstruction/Face Editing(人脸生成/合成/重建/编辑)</p></li><li><p>Face Forgery/Face Anti-Spoofing(人脸伪造/反欺骗)</p></li><li><p>3D Vision(三维视觉)</p></li><li><p>Point Cloud(点云)</p></li><li><p>3D Reconstruction(三维重建)</p></li><li><p>Neural Network Structure Design &amp; Optimization(神经网络设计与优化)</p></li><li><p>Transformer</p></li><li><p>NAS(神经网络架构搜索)</p></li><li><p>Loss Function(损失函数)</p></li><li><p>Visualization/Interpretability(可视化/可解释性)</p></li><li><p>Model Training/Generalization(模型训练/泛化)</p></li><li><p>Noisy Label(噪声标签)</p></li><li><p>Long-Tailed Distribution(长尾分布)</p></li><li><p>Out of Distribution Detection(分布外样本检测)</p></li><li><p>Knowledge Distillation(知识蒸馏)</p></li><li><p>Pruning(剪枝)</p></li><li><p>Quantization(量化)</p></li><li><p>Image Generation/Image Synthesis(图像生成/合成)</p></li><li><p>View Synthesis(视图合成)</p></li><li><p>GAN/Generative/Adversarial(GAN/生成式/对抗式)</p></li><li><p>Image Processing(图像处理)</p></li><li><p>Super Resolution(超分辨率)</p></li><li><p>Image Denoising(图像去噪/去模糊/去雨去雾)</p></li><li><p>Image Edit/Image Inpainting(图像编辑/修复)</p></li><li><p>Style Transfer(风格迁移)</p></li><li><p>Image Quality Assessment(图像质量评估)</p></li><li><p>Human Pose Estimation(姿态估计)</p></li><li><p>Depth Estimation(深度估计)</p></li><li><p>Image&amp;Video Retrieval/Video Understanding(图像&amp;视频检索/理解)</p></li><li><p>Action/Activity Recognition(行为识别/动作识别)</p></li><li><p>Re-Identification/Detection(行人重识别/检测)</p></li><li><p>Image/Video Caption(图像/视频字幕)</p></li><li><p>Visual Localization(视觉定位)</p></li><li><p>Image Matching(图像匹配)</p></li><li><p>3D Vision(三维视觉)</p></li><li><p>Object Tracking(目标跟踪)</p></li><li><p>Medical Imaging(医学影像)</p></li><li><p>Text Detection/Recognition(文本检测/识别)</p></li><li><p>Remote Sensing Image(遥感图像)</p></li><li><p>Scene Graph Generation(场景图生成)</p></li><li><p>Scene Graph Prediction(场景图预测)</p></li><li><p>Data Augmentation(数据增广)</p></li><li><p>Anomaly Detection(异常检测)</p></li><li><p>Representation Learning(表征学习)</p></li><li><p>Image Clustering(图像聚类)</p></li><li><p>Few-shot/Zero-shot Learning(小样本学习/零样本学习)</p></li><li><p>Continual Learning/Life-long Learning(持续学习)</p></li><li><p>Transfer Learning/Domain Adaptation(迁移学习/自适应)</p></li><li><p>Metric Learning(度量学习)</p></li><li><p>Incremental Learning(增量学习)</p></li><li><p>Contrastive Learning(对比学习)</p></li><li><p>Visual Reasoning/VQA(推理学习/视觉问答)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ICCV2021&quot;&gt;&lt;a href=&quot;#ICCV2021&quot; class=&quot;headerlink&quot; title=&quot;ICCV2021&quot;&gt;&lt;/a&gt;ICCV2021&lt;/h2&gt;&lt;p&gt;不久前计算机视觉三大顶会之一的ICCV2021接收结果已经公布，本次ICCV共计6236篇有
      
    
    </summary>
    
    
      <category term="每月见闻" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻202108</title>
    <link href="http://yoursite.com/2021/08/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202108/"/>
    <id>http://yoursite.com/2021/08/13/每月见闻202108/</id>
    <published>2021-08-13T02:37:11.000Z</published>
    <updated>2021-10-15T08:10:42.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h3><p>微软、OpenAL、Github联合推出了自动代码生成AI：Copilot，该技术使用OpenAI最新的GPT3语言模型，在Github海量(数十亿行代码)的公共仓库数据集上进行了代码学习训练。通过一个Web内测接口，用户可以在页面中输入需求描述，Copilot自动转换为代码，支持很多种编程语言，在Python、Java、JavaScript等语言方面尤其优秀</p><p><img src="/2021/08/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202108/images\02.png" alt></p><p><img src="/2021/08/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202108/images\03.png" alt></p><p>该项目发布后，在网络上引起了很多讨论，有人发现Copilot生成的代码和很多开源项目代码几乎是直接复制粘贴，有些甚至连注释都搬运过来。并且，Copilot无法理解复杂上下文环境，只能针对非常明确具体简单的需求给出一些代码块，并且程序员依然不能放心的使用，必须仔细检查代码中是否存在漏洞。最重要的问题是，Github官方在后续的回应中明确了使用了Github所有公开代码来训练Copilot，并且不区分License类别，后续Copilot还有可能商用的说法，引起了很多开发者的抨击，Github官方并不具备这样的权力，这样做本身就是对开源的破坏</p><p>参考</p><p><a href="https://copilot.github.com/">copilot技术预览网站</a></p><p><a href="https://www.openai.com/blog/openai-codex/">OpenAI Codex</a></p><p><a href="https://arxiv.org/abs/2107.03374">OpenAi Codex Paper</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Copilot&quot;&gt;&lt;a href=&quot;#Copilot&quot; class=&quot;headerlink&quot; title=&quot;Copilot&quot;&gt;&lt;/a&gt;Copilot&lt;/h3&gt;&lt;p&gt;微软、OpenAL、Github联合推出了自动代码生成AI：Copilot，该技术使用OpenAI最
      
    
    </summary>
    
    
      <category term="每月见闻" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>优先队列(PriorityQueue)</title>
    <link href="http://yoursite.com/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/08/30/优先队列/</id>
    <published>2020-08-29T19:17:39.000Z</published>
    <updated>2021-08-13T02:24:21.747Z</updated>
    
    <content type="html"><![CDATA[<p>普通的队列是一种FIFO结构，在优先队列(PriorityQueue)中，数据存在优先级，在进行出队操作时，具有最大(MaxPriorityQueue)或最小(MinPriorityQueue)优先级的元素最先出队。在很多应用场景中，都需要这种对数据进行有序处理或者按照优先级处理的方式</p><p>优先队列的应用很广泛，最常见的是进行任务调度，当有多个任务都需要处理的时候，为不同的任务划分优先级，并分别调度；优先队列还可以开发图搜索算法、数据压缩算法等</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>优先队列的实现有很多方式，例如链表和数组。利用二叉堆来实现优先队列是一种较为高效的做法</p><div class="table-container"><table><thead><tr><th>结构</th><th>入队</th><th>出队最大元素</th></tr></thead><tbody><tr><td>有序数组</td><td>N</td><td>1</td></tr><tr><td>无序数组</td><td>1</td><td>N</td></tr><tr><td>堆</td><td>logN</td><td>logN</td></tr></tbody></table></div><p>二叉堆实现的优先队列能够保证在插入和删除两个维度都较快</p><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆是一组能够用堆有序的完全二叉树排列的元素，并在数组中按照层级存储</p><p>可以用下图来表示一个二叉堆</p><p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image/PriorityQueue-01.png" alt></p><p>假设字幕A~Z表示的数值依次增大，则上图表示的是一个最大二叉堆(大根堆)，根节点”T”最大，二叉堆中任意子节点的数值不大于父节点数值</p><p>二叉堆有以下特性</p><ul><li><p>位置为k的节点父节点位置为k/2，两个子节点位置分别为2k和2k+1</p></li><li><p>大小为N的完全二叉树高度为logN</p></li></ul><p>以上性质决定了二叉堆在进行遍历或者搜索的路径是跳跃层级的，无论是插入还是删除操作，由于树高最大logN，因此操作的复杂度最大也为logN</p><h3 id="数组实现二叉堆"><a href="#数组实现二叉堆" class="headerlink" title="数组实现二叉堆"></a>数组实现二叉堆</h3><p>使用数组实现二叉堆是非常高效的，二叉堆中元素的位置和数组索引的关系可以用下图表示</p><p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-02.png" alt></p><p>使用数组实现二叉堆，仅利用数组索引就可以沿着树上下移动，非常便利。要注意为了编程时父子位置关系的统一性，数组的第一个位置不使用</p><p>在对堆进行操作时，会首先进行一些简单的改动，例如插入时先将元素插入到堆底，或者删除时先删除堆顶元素，这样会打破原有堆的有序状态，然后再将堆恢复有序状态(堆的有序化)。本文以最大优先队列为例，对堆的有序化操作进行说明</p><p>有序化需要用到两个辅助函数：比较(less)和交换(exch)。less函数是为了实现优先队列的泛化，希望实现的优先队列是一种泛型数据结构，而非某一种特定的数据结构，因此对于某一种具体的数据结构和类型，需要提供对应的比较函数”compare”，例如字符串String、文件File、时间Time等；交换两个元素是优先队列中使用非常频繁的操作，因此提取为单独的函数。以下是less和exch的伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">less</span><span class="params">(array, compare, i, j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(array[i], array[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(array, i, j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上浮-swim"><a href="#上浮-swim" class="headerlink" title="上浮(swim)"></a>上浮(swim)</h4><p>当插入一个元素到堆底后，如果该元素比其父节点更大，就需要通过上浮操作来对堆进行有序化。例如在G节点下向堆中插入元素”Y”</p><p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-03.png" alt></p><p>“Y”元素只需要一遍一遍的与其父节点进行比较，并交换它们的位置，当”Y”元素到达合适的位置时，整个堆就变得有序了</p><p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-04.png" alt></p><p>整个过程是插入元素不断地向上”浮动“，不在上浮路径上的元素都保持不变。有序化后部分元素的所在层数会发生变化。上浮的伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k: new item&#x27;s index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((k&gt;<span class="number">1</span>) &amp;&amp; less(k/<span class="number">2</span>,k)) &#123;</span><br><span class="line">        exch(k/<span class="number">2</span>, k);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下沉-sink"><a href="#下沉-sink" class="headerlink" title="下沉(sink)"></a>下沉(sink)</h4><p>当某个元素变得比它的两个子节点或是其中之一小，通过下沉操作来恢复有序状态。例如将堆顶元素”T”删除后再将”G”元素放在原先”T”元素的位置</p><p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-05.png" alt></p><p>“G”元素只需要一遍一遍与其子节点进行比较，并交换位置，当”G”元素到达合适的位置时，整个堆就变得有序了</p><p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-06.png" alt></p><p>下沉的伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">        j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> ((j&lt;N) &amp;&amp;  less(j, j+<span class="number">1</span>)) </span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        exch(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p>由于数组需要在创建时分配固定大小，因此为了提高利用的灵活性，需要队列能够自动调整数组大小。太过频繁的重新调整会增大开销，较为合理的方式是</p><ul><li><p>当数组满时，扩容为原数组2倍</p></li><li><p>当数组元素大小减小到数组容量时，减小容量为原数组一半</p></li></ul><h3 id="C语言实现MinPQ"><a href="#C语言实现MinPQ" class="headerlink" title="C语言实现MinPQ"></a>C语言实现MinPQ</h3><p><code>MinPQ</code>结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- MinPQ --&#123;*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">minpq</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> node_nr;        <span class="comment">/* node number */</span></span><br><span class="line">    <span class="keyword">int</span> capacity;       <span class="comment">/* the capacity of queue */</span>     </span><br><span class="line">    <span class="keyword">size_t</span> nodesize;    <span class="comment">/* every node&#x27;s size in the queue */</span>   </span><br><span class="line">    <span class="keyword">int</span> *p;             <span class="comment">/* point to the private priority array */</span></span><br><span class="line">    <span class="keyword">char</span> *q;            <span class="comment">/* point to the node array */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINPQ_F_CDC   0x0001  <span class="comment">/* custom define comparator */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINPQ_F_RES   0x0002  <span class="comment">/* capacity resize */</span></span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;</span><br><span class="line">    <span class="keyword">bool</span> (*comparator)(<span class="keyword">void</span> *, <span class="keyword">void</span> *);    <span class="comment">/* point to custom define comparator */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> info_width;     <span class="comment">/* use fo debug and dump */</span></span><br><span class="line">    <span class="keyword">void</span> (*info_prior_handle)(struct _minpq *, <span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>);    <span class="comment">/* use fo debug and dump */</span></span><br><span class="line">    <span class="keyword">void</span> (*info_value_handle)(struct _minpq *, <span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>);    <span class="comment">/* use fo debug and dump */</span></span><br><span class="line">&#125; MinPQ;</span><br></pre></td></tr></table></figure><p>创建<code>MinPQ</code>，创建函数需要传入节点大小和容量，如果容量为0，默认支持自动扩容；如果使用自定义优先级，需要传入比较器<code>comparator</code>。创建函数内部会创建并维护一个内部默认的优先级数组<code>p</code>，该数组是整型类型，如果要用默认的整型优先级，后续插入元素时可传入优先级数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a Min Priroity Queue(MinPQ)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @nodesize: every node&#x27;s size in the queue</span></span><br><span class="line"><span class="comment"> * @capacity: the capacity of queue</span></span><br><span class="line"><span class="comment"> * @comparator: custom define comparator</span></span><br><span class="line"><span class="comment"> * @flags: queue&#x27;s features</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return: MinPQ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MinPQ *<span class="title">MinPQ_create</span><span class="params">(<span class="keyword">size_t</span> nodesize, <span class="keyword">int</span> capacity, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span>(*comparator)(<span class="keyword">void</span> *, <span class="keyword">void</span> *), <span class="keyword">uint16_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> allocnr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* params check */</span></span><br><span class="line">    <span class="keyword">if</span> (nodesize &lt;= <span class="number">0</span>) &#123;log_err(<span class="string">&quot;nodesize zero&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;log_err(<span class="string">&quot;capacity invaild&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">    MinPQ *q = zalloc(<span class="keyword">sizeof</span>(MinPQ));</span><br><span class="line">    <span class="keyword">if</span> (!q) &#123;log_err(<span class="string">&quot;MinPQ create error&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;node_nr = <span class="number">0</span>;</span><br><span class="line">    q-&gt;nodesize = nodesize;</span><br><span class="line">    q-&gt;info_width = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    q-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;    <span class="comment">/* if no capacity, we set resize flag auto */</span></span><br><span class="line">        mask_push(q-&gt;flags, MINPQ_F_RES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;comparator = comparator;</span><br><span class="line">        mask_push(q-&gt;flags, MINPQ_F_CDC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mask_push(q-&gt;flags, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!capacity) &#123;</span><br><span class="line">        allocnr = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        allocnr = capacity + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alloc private priority */</span></span><br><span class="line">    q-&gt;p = zalloc(allocnr*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    q-&gt;q = zalloc(allocnr*q-&gt;node_nr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素，会首先检查容量和是否支持扩容；新节点先放在堆底，然后上浮操作进行有序化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * MinPQ insert operation</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @q: the queue you want to do insert</span></span><br><span class="line"><span class="comment"> * @u: the node you want to insert</span></span><br><span class="line"><span class="comment"> * @p: the priority of insert node, if use custom define priority, don&#x27;t need this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">err_type <span class="title">MinPQ_insert</span><span class="params">(struct _minpq *q, <span class="keyword">void</span> *u, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MinPQ_full(q)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask_exst(q-&gt;flags, MINPQ_F_RES)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q-&gt;capacity) q-&gt;capacity = <span class="number">1</span>;</span><br><span class="line">            _resize(q, q-&gt;capacity*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log_err(<span class="string">&quot;MinPQ full&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> et_full;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;p[++q-&gt;node_nr] = p;</span><br><span class="line">    addr = q-&gt;q + q-&gt;nodesize*q-&gt;node_nr;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, u, q-&gt;nodesize);</span><br><span class="line">    _swim(q, q-&gt;node_nr);</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素，先将堆顶元素拷贝出来，然后将堆底元素移动到堆顶，调用下沉<code>sink</code>进行有序化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">MinPQ_delmin</span><span class="params">(struct _minpq *q, <span class="keyword">void</span> *u, <span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr1, *addr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MinPQ_empty(q)) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;MinPQ empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr1 = q-&gt;q + q-&gt;nodesize;</span><br><span class="line">    <span class="built_in">memcpy</span>(u, addr1, q-&gt;nodesize);</span><br><span class="line">    *p = q-&gt;p[<span class="number">1</span>];</span><br><span class="line">    q-&gt;p[<span class="number">1</span>] = q-&gt;p[q-&gt;node_nr];</span><br><span class="line">    addr2 = q-&gt;q + q-&gt;nodesize*q-&gt;node_nr;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr1, addr2, q-&gt;nodesize);</span><br><span class="line">    q-&gt;node_nr--;</span><br><span class="line">    _sink(q, <span class="number">1</span>);</span><br><span class="line">    q-&gt;p[q-&gt;node_nr+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((q-&gt;node_nr&gt;<span class="number">0</span>) &amp;&amp; </span><br><span class="line">        (q-&gt;node_nr==(q-&gt;capacity<span class="number">-1</span>)/<span class="number">4</span>) &amp;&amp;</span><br><span class="line">        mask_exst(q-&gt;flags, MINPQ_F_RES)) &#123;</span><br><span class="line">        _resize(q, q-&gt;capacity/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr2 = q-&gt;q + q-&gt;nodesize*(q-&gt;node_nr+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(addr2, <span class="number">0x0</span>, q-&gt;nodesize);</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取指定索引数据，该函数可以结合<code>for</code>循环遍历队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">MinPQ_get</span><span class="params">(struct minpq *q, <span class="keyword">void</span> *u, <span class="keyword">int</span> *p, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (empty(q)) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;MinPQ empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = q-&gt;q + q-&gt;nodesize*index;</span><br><span class="line">    <span class="built_in">memcpy</span>(u, addr, q-&gt;nodesize);</span><br><span class="line">    *p = q-&gt;p[index];</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上浮操作，用到了递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swim(struct _minpq *q, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((k&gt;<span class="number">1</span>) &amp;&amp; (_greater(q, k/<span class="number">2</span>, k))) &#123;</span><br><span class="line">        _swap(q, k, k/<span class="number">2</span>);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下沉操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _sink(struct _minpq *q, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= q-&gt;node_nr) &#123;</span><br><span class="line">        j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> ((j&lt;q-&gt;node_nr) &amp;&amp; (_greater(q, j, j+<span class="number">1</span>)))</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_greater(q, k, j)) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        _swap(q, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swap(struct __minpq *q, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tempp;</span><br><span class="line">    <span class="keyword">char</span> *addr1, *addr2;</span><br><span class="line">    <span class="keyword">char</span> *tempu = zalloc(q-&gt;nodesize);</span><br><span class="line"></span><br><span class="line">    tempp = q-&gt;p[i];</span><br><span class="line">    q-&gt;p[i] = q-&gt;p[j];</span><br><span class="line">    q-&gt;p[j] = tempp;</span><br><span class="line"></span><br><span class="line">    addr1 = q-&gt;q + q-&gt;nodesize*i;</span><br><span class="line">    addr2 = q-&gt;q + q-&gt;nodesize*j;</span><br><span class="line">    <span class="built_in">memcpy</span>(tempu, addr1, q-&gt;nodesize);</span><br><span class="line">    <span class="built_in">memcpy</span>(addr1, addr2, q-&gt;nodesize);</span><br><span class="line">    <span class="built_in">memcpy</span>(addr2, tempu, q-&gt;nodesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> _greater(struct _minpq *q, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr1, *addr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;comparator) &#123;</span><br><span class="line">        <span class="keyword">return</span> (q-&gt;p[i] &gt; q-&gt;p[j]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr1 = q-&gt;q + q-&gt;nodesize*i;</span><br><span class="line">        addr2 = q-&gt;q + q-&gt;nodesize*j;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;comparator(addr1, addr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">err_type _resize(struct _minpq *q, <span class="keyword">int</span> capcaity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capcaity &lt;= q-&gt;node_nr) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;capcaity invaild&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = zalloc(q-&gt;nodesize*(capcaity+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;alloc new error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_nomem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">new</span>, q-&gt;q, q-&gt;nodesize*(q-&gt;node_nr+<span class="number">1</span>));</span><br><span class="line">    mem_free(q-&gt;q);</span><br><span class="line">    q-&gt;q = <span class="keyword">new</span>;</span><br><span class="line">    q-&gt;capacity = capcaity;</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些辅助查询函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPQ_size</span><span class="params">(struct _minpq *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;node_nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MinPQ_full</span><span class="params">(struct _minpq *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;capacity == q-&gt;node_nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MinPQ_empty</span><span class="params">(struct _minpq *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;node_nr == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;普通的队列是一种FIFO结构，在优先队列(PriorityQueue)中，数据存在优先级，在进行出队操作时，具有最大(MaxPriorityQueue)或最小(MinPriorityQueue)优先级的元素最先出队。在很多应用场景中，都需要这种对数据进行有序处理或者按照优先
      
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>C-Namespace</title>
    <link href="http://yoursite.com/2020/07/13/C-Namespace/"/>
    <id>http://yoursite.com/2020/07/13/C-Namespace/</id>
    <published>2020-07-13T02:36:21.000Z</published>
    <updated>2021-08-13T02:24:21.626Z</updated>
    
    <content type="html"><![CDATA[<p>记录两种C语言实现命令空间的方法</p><h2 id="结构体封装"><a href="#结构体封装" class="headerlink" title="结构体封装"></a>结构体封装</h2><p>简单来说就是将某个独立的库对外封装一个统一的接口结构体<code>structX</code>，外部调用时都使用<code>structX.aaa()</code>来调用库中的方法。例如有一个<code>foo</code>的库，要对外提供<code>test()</code>方法，可在<code>foo.h</code>文件中定义一个命名空间结构体<code>namespace_foo</code>，结构体中定义好需要对外提供的方法成员，并在最后通过<code>extern</code>关键字对外暴露结构体变量<code>Foo</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">namespace_foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *version;</span><br><span class="line">    <span class="keyword">int</span> (*test)();</span><br><span class="line">&#125; namespace_foo;</span><br><span class="line"><span class="keyword">extern</span> namespace_foo <span class="keyword">const</span> Foo;</span><br></pre></td></tr></table></figure><p>结构体变量<code>Foo</code>的定义在<code>foo.c</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace_foo <span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    .name = <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    .version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">    .test = foo_test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部要调用<code>foo</code>库中的函数，只需要引用<code>foo.h</code>头文件后，通过形如<code>Foo.test()</code>的方式就可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo.test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有另外一个库<code>goo</code>需要同时使用，只需要定义结构体变量<code>Goo</code>时的变量名称与<code>Foo</code>不同即可</p><h2 id="利用ifdef"><a href="#利用ifdef" class="headerlink" title="利用ifdef"></a>利用ifdef</h2><p>另一种方式是利用条件宏定义宏来重定义函数名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.h */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo_test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAMESPACE_FOO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test(...)    foo_test(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在外部使用<code>foo</code>库的函数前，需要通过宏声明<code>NAMESPACE_FOO</code>，然后再引用<code>foo.h</code>头文件，后续调用<code>test()</code>函数就等于调用<code>foo_test()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESPACE_FOO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录两种C语言实现命令空间的方法&lt;/p&gt;
&lt;h2 id=&quot;结构体封装&quot;&gt;&lt;a href=&quot;#结构体封装&quot; class=&quot;headerlink&quot; title=&quot;结构体封装&quot;&gt;&lt;/a&gt;结构体封装&lt;/h2&gt;&lt;p&gt;简单来说就是将某个独立的库对外封装一个统一的接口结构体&lt;code&gt;s
      
    
    </summary>
    
      <category term="Program Language" scheme="http://yoursite.com/categories/Program-Language/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/Program-Language/C/"/>
    
    
      <category term="Program Skill" scheme="http://yoursite.com/tags/Program-Skill/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻202007</title>
    <link href="http://yoursite.com/2020/07/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202007/"/>
    <id>http://yoursite.com/2020/07/13/每月见闻202007/</id>
    <published>2020-07-13T02:04:28.000Z</published>
    <updated>2021-08-13T02:24:21.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="电子织物微交互"><a href="#电子织物微交互" class="headerlink" title="电子织物微交互"></a>电子织物微交互</h3><p>在”ACM CHI 2020”会议中，Tensorflow团队展示了机器学习如何与交互式织物相结合，从而实现离散和连续手势的并行使用</p><p><img src="每月见闻202007/images/01.gif" alt></p><p>识别手势主要利用了<strong>螺旋感应矩阵 (HSM)</strong>，这些织物具有电容感应能力，具备传输和接收电极的作用。实验收集了 12 位参与者的数据，共得到 864 个手势样本，包括：轻弹、滑动、单点触摸手势等。训练后实现了约 94% 的手势识别准确率</p><p><img src="每月见闻202007/images/02.gif" alt></p><p>该技术未来可应用于线控耳机的手势控制方式、连帽衣物控制等</p><p><img src="每月见闻202007/images/03.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h2&gt;&lt;h3 id=&quot;电子织物微交互&quot;&gt;&lt;a href=&quot;#电子织物微交互&quot; class=&quot;headerlink&quot; title=&quot;电子织物微交互&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="每月见闻" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>触发词检测</title>
    <link href="http://yoursite.com/2020/06/28/%E8%A7%A6%E5%8F%91%E8%AF%8D%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2020/06/28/触发词检测/</id>
    <published>2020-06-28T01:27:18.000Z</published>
    <updated>2021-08-13T02:24:21.850Z</updated>
    
    <content type="html"><![CDATA[<p>经过一个多月工作之余的研究和编码调试，终于将触发词检测的完整方案实现并验证有效，能够在PC端进行独立的实时触发词检测，开源代码见<a href="https://github.com/awokezhou/TriggerWordDetect">我的开源repo</a>。该project来源于deeplearning.ai的<a href="[https://www.deeplearning.ai/deep-learning-specialization/](https://www.deeplearning.ai/deep-learning-specialization/">Deep Learning Specialization</a>课程中的”Sequence Models”序列模型，课程中完整介绍了如何搭建一个基于神经网络的触发词检测模型</p><p>本文首先对deeplearning.ai的触发词检测课程内容进行介绍，然后对我自己的实现方案进行了介绍说明，最后总结了整个研究过程中的知识点和经验</p><h2 id="deeplearning-ai触发词检测"><a href="#deeplearning-ai触发词检测" class="headerlink" title="deeplearning.ai触发词检测"></a>deeplearning.ai触发词检测</h2><p>目前很多智能产品上都带有触发词检测功能，例如苹果Siri、百度小度、小米的小爱同学等。触发词检测(Trigger word detect)也叫做关键字检测(keyword detect)或者唤醒词检测(wakeword detect)，能够让设备在听到某个特定单词后自动唤醒。该课程介绍了一个触发词检测的通用模型，能够基于该模型训练自己的触发词，并在不同的设备上部署</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>设定一个10秒的检测窗口detect window，将音频内容划分为以下3种类型</p><ul><li><p>background：背景音</p></li><li><p>activate：激活词，也就是要检测的触发词</p></li><li><p>negative：负面词，不同于激活词的说话声</p></li></ul><p>10秒的检测窗口中，背景音一直存在，激活词和负面词可以在任意位置出现</p><p><img src="触发词检测/images/01.png" alt></p><p>将10秒的检测窗口划分为若干个检测单元，未出现触发词的检测单元，将其标签设置为0，出现触发词的检测单元，将其标签设置为1</p><p><img src="触发词检测/images/02.png" alt></p><p>标签1与触发词的出现时间需要有一定的滞后性，因为必须先检测到完整的触发词，才能输出检测到的结果</p><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>首先需要为触发词检测算法构建一个数据集。理想情况下，最终的模型应该尽可能的在各种场景下都能够进行检测。因此，你需要在不同的背景声音中创建一段录音，例如图书馆、家中、办公室、户外、咖啡厅等等。另外，为了数据和模型有更好的泛化效果，采集的所有样本中，应该将激活次和负面词的出现频率和位置尽可能分布均匀。另外，如果你想要能够识别不同口音，那么需要采集更多样本，包括不同年龄、性别、体重、籍贯等</p><h4 id="程序化生成样本"><a href="#程序化生成样本" class="headerlink" title="程序化生成样本"></a>程序化生成样本</h4><p>数据集的来源可能是你去收集不同人的录音。如果以10秒的窗口为样本，那么你需要拿着一个录音设备采集多组10秒的音频，以1000个样本数量为例，总的样本时间为10000秒大概是2.7个小时，再加上寻找不同的人和沟通的时间，总的时间成本可能很长</p><p>可以使用一个程序化生成样本的方法，将收集的数据分为background、activate和negative三类。background表示在各种环境中采集若干个10秒的背景声音，activate表示采集不同人只说激活词的声音，negative表示不同人只说负面词的声音。采集完成后，将activate和negative样本随机的插入background中，这样能够更加快速的生成更多样本</p><p><img src="触发词检测/images/03.png" alt></p><h4 id="录音转换为频谱"><a href="#录音转换为频谱" class="headerlink" title="录音转换为频谱"></a>录音转换为频谱</h4><p>录音本质上是麦克风记录下气压的微小变化，而这种时域的录音信号，直接用来提取和分析特征，是非常困难的，通过转换到频域，能够更好地提取和利用特征</p><p>在Python中，可以用<code>matplotlib.pyplot</code>包的<code>specgram</code>方法实现录音转换为频谱数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specgram</span>(<span class="params">filename</span>):</span></span><br><span class="line">    rate, data = wavfile.read(filename)</span><br><span class="line">    nfft = <span class="number">200</span></span><br><span class="line">    fs = <span class="number">8000</span></span><br><span class="line">    noverlap = <span class="number">120</span></span><br><span class="line">    nchannels = data.ndim</span><br><span class="line">    <span class="keyword">if</span> nchannels == <span class="number">1</span>:</span><br><span class="line">        pxx, freqs, bins, im = plt.specgram(data, nfft, fs, noverlap)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pxx, freqs, bins, im = plt.specgram(data[:,<span class="number">0</span>], nfft, fs, noverlap=noverlap)</span><br><span class="line">    <span class="keyword">return</span> pxx</span><br></pre></td></tr></table></figure><p>以上代码，将一个10秒的录音文件转换为频谱数据pxx。这里需要注意一下录音数据和频谱数据的shape</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rate, data = wavfile.read(<span class="string">&#x27;test.wav&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.shape</span><br><span class="line">(<span class="number">441000</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pxx = specgram(<span class="string">&#x27;test.wav&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pxx.shape</span><br><span class="line">(<span class="number">101</span>,<span class="number">5511</span>)</span><br></pre></td></tr></table></figure><p>因为录音使用44100Hz的采样频率，因此1秒产生44100帧音频数据，10秒就是441000帧数据，音频数据是一维的序列。转化为频谱数据后，将10秒划分为了5511个片段，并提取了101个主要频率的窗口</p><h4 id="创建一个训练样本"><a href="#创建一个训练样本" class="headerlink" title="创建一个训练样本"></a>创建一个训练样本</h4><p>创建训练样本的前提是，已经按照上文的要求，采集了若干数量的背景声、激活词和负面词的录音文件。生成一个训练样本，需要以下4个步骤</p><ul><li><p>随机选择一个背景录音</p></li><li><p>随机选择若干个激活词音频插入到背景的随机位置</p></li><li><p>随机选择若干个负面词音频插入到背景的随机位置</p></li><li><p>对生成的样本进行标记</p></li></ul><p>这里需要注意，插入的过程，是音频数据的叠加操作，而不是追加，例如向一个10秒的背景音频中插入1秒的激活词片段，插入后得到的合成音频仍然是10秒，而不是11秒。在进行多次插入时，为了避免重复插入到相同的位置，需要记录已经插入的片段位置</p><p>在进行标记时，将10秒的时长划分为1375，触发词后的50个片段被标记为1，这样做的好处是不需要人为的听取每一个合成音频再手动进行标记，标记过程可以自动进行。1375个片段长度是由模型决定的，后文介绍</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>使用的模型如图所示</p><p><img src="触发词检测/images/04.png" alt></p><p>模型的输入是合成音频转化成的频谱数据，shape为(5511,101)，输出shape为(1375,)。首先是经过一个一维卷积层，进行简单的特征提取，并减小数据大小到(1375,196)，然后数据经过两个GRU层，最后通过Sigmoid函数将输出归一化到0~1</p><h4 id="评估和预测"><a href="#评估和预测" class="headerlink" title="评估和预测"></a>评估和预测</h4><p>该模型在dev数据集上获得了0.94的精度。在预测时，先将音频数据输入模型，得到模型输出，然后遍历1375个输出数据，如果有连续50个数据大小超过某个阈值(0.6)，认为检测到触发词</p><h2 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h2><h3 id="数据集生成"><a href="#数据集生成" class="headerlink" title="数据集生成"></a>数据集生成</h3><p>实验环境为Linux，Linux系统为音频处理抽象了一个ALSA框架，包括声卡设备驱动、音频核心层和应用层的一些工具。录音使用”arecord”命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord -xxxx</span><br></pre></td></tr></table></figure><p>另外，还需要两个python音频处理包：pydub和alsaaudio。pydub用于处理音频插入合成，alsaaudio用于实时录音</p><h4 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h4><p>抽象了<code>DataLoader</code>类来用于加载和生成数据集，代码位于DataLoader.py。设定两个根目录下和数据集相关路径：</p><ul><li><p>orig：表示原始录音数据</p></li><li><p>gen：表示生成的合成音频和数据集</p></li></ul><p>orig路径下包括background、activate、negative三个文件夹，分别存放背景音、触发词和负面词。gen路径下包括train和dev两部分，分别存放训练集数据和验证集数据</p><p>DataLoader主要实现load、info和generate三个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataLoader</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ...</span>):</span></span><br><span class="line">        /*......*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, ...</span>):</span></span><br><span class="line">        /*......*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        /*......*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, ...</span>):</span></span><br><span class="line">        /*......*/</span><br></pre></td></tr></table></figure><p>load主要完成从指定路径加载原始音频文件到内存，默认是从orig路径下加载，也可以从参数指定路径，路径下需要包含background、activate和negative三个子文件夹。info主要是显示loader相关信息，generate方法生成数据集文件，可通过target参数指定是生成训练集还是验证集</p><h5 id="load"><a href="#load" class="headerlink" title="load"></a>load</h5><p>load方法会遍历远视音频路径下的文件，并按照子文件夹background、activate和negative将音频文件加载到loader的<code>ori_activate</code>、<code>ori_negative</code>和<code>ori_background</code>三个列表中，加载音频文件是调用<code>AudioSegment</code>的<code>from_wav()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, path=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">        oripath = <span class="literal">None</span></span><br><span class="line">        valnames = self.__dict__</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            oripath = self.config[<span class="string">&#x27;ori_dir&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            oripath = path</span><br><span class="line">            self.config[<span class="string">&#x27;ori_dir&#x27;</span>] = path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> self.config[<span class="string">&#x27;labels&#x27;</span>]:</span><br><span class="line">            dirname = os.path.join(oripath, label)</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(dirname):</span><br><span class="line">                <span class="keyword">if</span> file[-<span class="number">4</span>:] == <span class="string">&#x27;.wav&#x27;</span>:</span><br><span class="line">                    data = AudioSegment.from_wav(os.path.join(dirname, file))</span><br><span class="line">                    valnames[<span class="string">&#x27;ori_&#x27;</span>+label].append(data)</span><br></pre></td></tr></table></figure><h5 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h5><p>考虑到PC机内存问题，要生成大量数据集文件，使用了batch的方式，generate参数支持批量生成，参数batchs用于控制批次，默认为1，batch_size用于控制单次生成的数量大小</p><p>在实现内部，使用<code>yield</code>抽象了一个生成器<code>_generator</code>来生成单个合成音频文件，一个批次的数据通过<code>numpy.save</code>导出为.npy文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, <span class="built_in">dir</span>=<span class="literal">None</span>, target=<span class="string">&#x27;train&#x27;</span>, batchs=<span class="number">1</span>, batch_size=<span class="number">100</span></span>):</span></span><br><span class="line"></span><br><span class="line">        target_dir = <span class="literal">None</span></span><br><span class="line">        target_path = <span class="literal">None</span></span><br><span class="line">        self.synthesis_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        np.random.seed(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_loaded():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;not loaded&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">dir</span>:</span><br><span class="line">            target_dir = self.config[<span class="string">&#x27;gen_dir&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_dir = <span class="built_in">dir</span></span><br><span class="line">            self.config[<span class="string">&#x27;gen_dir&#x27;</span>] = <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            target_path = os.path.join(target_dir,self.config[<span class="string">&#x27;gen_train_dir&#x27;</span>])</span><br><span class="line">        <span class="keyword">elif</span> target == <span class="string">&#x27;dev&#x27;</span>:</span><br><span class="line">            target_path = os.path.join(target_dir,self.config[<span class="string">&#x27;gen_dev_dir&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        self.dataset_path = os.path.join(target_path, self.config[<span class="string">&#x27;gen_dataset_dir&#x27;</span>])</span><br><span class="line">        self.synthesis_path = os.path.join(target_path, self.config[<span class="string">&#x27;gen_synthesis_dir&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;target:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(target))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;target dir:&#123;&#125; path:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(target_dir, target_path))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dataset path:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.dataset_path))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;synthesis path:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.synthesis_path))</span><br><span class="line"></span><br><span class="line">        self.gen_clean(target_path)</span><br><span class="line">        self.gen_mkdir(target_path)</span><br><span class="line"></span><br><span class="line">        self.gen_X = np.zeros((batch_size, <span class="number">5511</span>, <span class="number">101</span>))</span><br><span class="line">        self.gen_Y = np.zeros((batch_size, <span class="number">1375</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batchs):</span><br><span class="line"></span><br><span class="line">                self.synthesis_count = <span class="number">0</span></span><br><span class="line">                random_backgrounds = self.get_random_data(self.ori_background, </span><br><span class="line">                                                          size=batch_size,</span><br><span class="line">                                                          fixed_size=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment">#print(&#x27;random backgrounds number &#123;&#125;&#x27;.format(len(random_backgrounds)))</span></span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> self._generator(random_backgrounds, i):</span><br><span class="line">                    self.gen_X[self.synthesis_count] = x.transpose()</span><br><span class="line">                    self.gen_Y[self.synthesis_count] = y.transpose()</span><br><span class="line">                    self.synthesis_count += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                np.save(<span class="string">&#x27;&#123;&#125;/X-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(self.dataset_path, i), self.gen_X)</span><br><span class="line">                np.save(<span class="string">&#x27;&#123;&#125;/Y-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(self.dataset_path, i), self.gen_Y)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;generated dataset batch&#123;&#125; to &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    i, self.dataset_path))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>单个生成数据的步骤为</p><ul><li><p>随机抽取一个背景音频</p></li><li><p>随机抽取几段actives音频，通过<code>AudioSegment</code>的<code>overlay</code>方法将active插入到background中，这里需要记录已插入的片段起始和结束时间，避免重复或覆盖</p></li><li><p>将插入了activate的位置，在同比例的Y数据中修改标记为1</p></li><li><p>随机抽取若干negative音频，插入背景中，同样要避免覆盖</p></li><li><p>将合成后的音频导出为.wav文件</p></li><li><p>读取.wav合成文件并转换为频谱数据</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> DataLoader improt DataLoader</span><br><span class="line"><span class="comment"># 创建loader实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader = DataLoader()</span><br><span class="line"><span class="comment"># 查看loader，可以看到loader还未加载数据，已经有生成的训练数据集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader.info()</span><br><span class="line">-- DataLoader info --</span><br><span class="line"><span class="keyword">not</span> load</span><br><span class="line">generated to gen</span><br><span class="line">generated train to gen/train</span><br><span class="line">batchs:<span class="number">1</span> </span><br><span class="line">batchsize:<span class="number">100</span> </span><br><span class="line">no dev</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载原始音频数据，可看到从orig加载了17个activates、30个negatives和30个背景</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader.load()</span><br><span class="line">data loaded <span class="keyword">from</span> ori, activate:<span class="number">17</span> negativa:<span class="number">30</span> background:<span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按默认参数生成训练集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader.generate()</span><br><span class="line">...</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">94.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">95.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">96.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">97.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">98.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">99.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">generated dataset batch0 to gen/train/dataset</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>模型就和deeplearning.ai课程介绍的一致，一个一维卷积层+2个GRU层+一个sigmoid激活函数，网络输入为5511乘101，输出为1375乘1，优化器用Adam，学习速率为0.001，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>(<span class="params">input_shape=(<span class="params"><span class="number">5511</span>,<span class="number">101</span></span>), learn_rate=<span class="number">0.001</span></span>):</span></span><br><span class="line"></span><br><span class="line">    model = tf.keras.models.Sequential()</span><br><span class="line"></span><br><span class="line">    model.add(layers.Input(shape = input_shape))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv1D(<span class="number">196</span>, kernel_size=<span class="number">15</span>, strides=<span class="number">4</span>))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.Activation(<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.GRU(units = <span class="number">128</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line"></span><br><span class="line">    model.add(layers.GRU(units = <span class="number">128</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.TimeDistributed(layers.Dense(<span class="number">1</span>, activation = <span class="string">&quot;sigmoid&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    opt = tf.keras.optimizers.Adam(lr=learn_rate, beta_1=<span class="number">0.9</span>, beta_2=<span class="number">0.999</span>, decay=<span class="number">0.01</span>)</span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=opt, loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="string">&quot;accuracy&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>训练使用了GPU加速，在5000个生成数据上进行了训练，没有使用学习速率衰减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">modelname, train_index=<span class="number">0</span>, batch_size=<span class="number">10</span>, epochs=<span class="number">30</span>, save=<span class="literal">True</span>, lr_reduce=<span class="literal">False</span>, use_gpu=<span class="literal">True</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> use_gpu:</span><br><span class="line">        gpu_setting()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    callback_list = []</span><br><span class="line">    model = load_model(modelname)</span><br><span class="line">    X = np.load(<span class="string">&#x27;record_data_gen/train/dataset/X-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(train_index))</span><br><span class="line">    Y = np.load(<span class="string">&#x27;record_data_gen/train/dataset/Y-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(train_index))</span><br><span class="line">    <span class="keyword">if</span> lr_reduce:</span><br><span class="line">        lr = ReduceLROnPlateau(monitor=<span class="string">&#x27;loss&#x27;</span>, patience=<span class="number">20</span>, verbose=<span class="number">1</span>, mode=<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">        callback_list.append(lr)</span><br><span class="line">    history = model.fit(X,Y,batch_size=batch_size,epochs=epochs, callbacks=callback_list)</span><br><span class="line">    model.save(modelname)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;train time:&#123;&#125; second&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(end-start)))</span><br><span class="line">    <span class="keyword">return</span> history</span><br></pre></td></tr></table></figure><p>最终的精度达到0.975左右，loss在0.01以下</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>实时预测</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>利用GRU模型处理时间序列</p></li><li><p>利用一维卷积预处理</p></li><li><p>利用GPU加速训练</p></li><li><p>Linux ALSA框架</p></li><li><p>train经验</p><ul><li><p>数据问题，数据一定要正确</p></li><li><p>训练速度问题，先用一个较大的学习速率验证自己数据是否正确，再降低速率进行正式学习</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过一个多月工作之余的研究和编码调试，终于将触发词检测的完整方案实现并验证有效，能够在PC端进行独立的实时触发词检测，开源代码见&lt;a href=&quot;https://github.com/awokezhou/TriggerWordDetect&quot;&gt;我的开源repo&lt;/a&gt;。该pr
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
      <category term="project" scheme="http://yoursite.com/categories/ML/project/"/>
    
    
      <category term="Tensorflow" scheme="http://yoursite.com/tags/Tensorflow/"/>
    
      <category term="deeplearning.ai" scheme="http://yoursite.com/tags/deeplearning-ai/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻202006</title>
    <link href="http://yoursite.com/2020/06/16/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202006/"/>
    <id>http://yoursite.com/2020/06/16/每月见闻202006/</id>
    <published>2020-06-16T05:46:15.000Z</published>
    <updated>2021-08-13T02:24:21.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="言论"><a href="#言论" class="headerlink" title="言论"></a>言论</h2><h3 id="算法工程师毒鸡汤"><a href="#算法工程师毒鸡汤" class="headerlink" title="算法工程师毒鸡汤"></a><a href="https://www.bilibili.com/video/BV1654y1B7Zi">算法工程师毒鸡汤</a></h3><p>在B站关注的一位微软人工智能UP主讲述了一期关于算法岗应该注意什么的问题，值得学习</p><style>@media all and (orientation : landscape) { .video {width:800px; height:600px;}}@media all and (orientation : portrait){ .video {width:90%; height:250px;}}</style><iframe class="video" src="//player.bilibili.com/player.html?aid=841073548&bvid=BV1654y1B7Zi&cid=202449874&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>其实在实际工程落地的时候，算法模型本身的很多问题都是微不足道的，旺旺制约落地的关键问题，是业务、数据、迭代等与算法不相关的方面。要搞算法，前提是怎么样让自己成为一名专业的工程师，怎么样能够编写出健壮性稳定性良好的代码，了解足够的后端相关知识，再去关注算法本身</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="Tensorflow案例分享—量化匠人经验，助力文化传承"><a href="#Tensorflow案例分享—量化匠人经验，助力文化传承" class="headerlink" title="Tensorflow案例分享—量化匠人经验，助力文化传承"></a>Tensorflow案例分享—量化匠人经验，助力文化传承</h3><p>日本广岛县熊野町生产的传统工艺品“熊野笔(Kumano Fude)”拥有很长的历史，是日本最著名的毛笔。由于笔头的品质难以用机器衡量，在大多数生产制作流程中，都是人工参与，导致产量很低。</p><p><img src="每月见闻202006/images/01.png" alt></p><p>某团队利用Tensorflow搭建了一个识别熊野笔良品的量化模型，首先利用一个卷积自编码器在人工筛选的良品上进行学习，在识别时输入任意笔刷图像，将会计算模型输入和输出的差距来判断是否为良品。</p><p><img src="每月见闻202006/images/02.png" alt></p><p>最终能够输出模型认为次品有问题的地方，用红色标注</p><p><img src="每月见闻202006/images/01.gif" alt></p><h3 id="滴滴未来出行"><a href="#滴滴未来出行" class="headerlink" title="滴滴未来出行"></a><a href="https://xw.qq.com/cmsid/20200627A0AO1Y00">滴滴未来出行</a></h3><p>滴滴在上海嘉定区开启了未来出行项目，通过部署无人驾驶网约车，用户有几率打到无人驾驶车，随车配备了安全驾驶员</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;言论&quot;&gt;&lt;a href=&quot;#言论&quot; class=&quot;headerlink&quot; title=&quot;言论&quot;&gt;&lt;/a&gt;言论&lt;/h2&gt;&lt;h3 id=&quot;算法工程师毒鸡汤&quot;&gt;&lt;a href=&quot;#算法工程师毒鸡汤&quot; class=&quot;headerlink&quot; title=&quot;算法工程师毒鸡汤&quot;
      
    
    </summary>
    
    
      <category term="每月见闻" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow创建GPU环境</title>
    <link href="http://yoursite.com/2020/06/13/Tensorflow%E5%88%9B%E5%BB%BAGPU%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/06/13/Tensorflow创建GPU环境/</id>
    <published>2020-06-13T03:02:52.000Z</published>
    <updated>2021-08-13T02:24:21.720Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Tensorflow做CS230触发词检测的train时，发现如果<code>learning rate=0.0001</code>，训练500个epochs，12小时都训练不完，实在是太慢了。看CS230的教程上说在GPU上训练用时3个小时，因此研究了一下如何搭建一套支持GPU训练的Tensorflow环境，能够快捷简单正确的安装出一整套环境</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>搭建一套支持GPU的Tensorflow环境，主要有以下几个方面的问题</p><ul><li><p>显卡驱动、显卡深度学习库、Tensorflow的版本对应关系很复杂，版本对应不上，用不了</p></li><li><p>Tensorflow1和Tensorflow2变化很大</p></li></ul><p>Tensorflow要支持GPU，实际上是显卡厂商提供了深度学习的计算支持，Tensorflow适配和调用显卡厂商的支持库。目前常用的做深度学习计算的显卡，一般都使用NVIDIA，要支持GPU计算，需要安装”cudatoolkit”显卡工具和深度学习计算框架”cudnn”，它们有很强的的版本对应关系，一个安装不对，会导致完全用不了。网上有很多版本对应的介绍和列表，这里就不再赘述</p><p>很多关于Tensorflow GPU环境的介绍，都是在Tensorflow1的版本上介绍的，v1版本CPU和GPU版本是分开的，需要单独安装。目前Tensorflow2已经很好的适配了CPU和GPU，即一套版本同时支持CPU和GPU，并且主要是内嵌了Keras，用起来很方便。网上关于这方面的介绍比较少</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>综合各种搭建方案，我最终选择了通过anaconda来安装虚拟环境，主要是因为我本地还有python2.7和tensorflow CPU环境存在，并不想对这两个环境有所变动。另一方面是通过anaconda安装GPU环境，它可以自动安装相关依赖环境，cudatoolkit和cudnn的版本不需要自己去找</p><p>环境介绍：</p><ul><li><p>OS：Ubuntu18.0.4</p></li><li><p>CPU：Inter(R) Core(TM) i5-7200U CPU @ 2.5GHz</p></li><li><p>GPU：GeForce MX150 2GB</p></li><li><p>Tensorflow2.2.0</p></li></ul><p>首先创建一个名为”tf-gpu”的虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tf-gpu</span><br></pre></td></tr></table></figure><p>进入虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate tf-gpu</span><br></pre></td></tr></table></figure><p>安装python3.8，因为我选择安装的是tensorflow2.2.0版本，它依赖于python3.8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install python=3.8</span><br></pre></td></tr></table></figure><p>安装tensorflow及其依赖，这里一定要写成tensorflow-gpu，否则conda不会安装GPU相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorlfow-gpu=2.2.0</span><br></pre></td></tr></table></figure><p>conda会安装很多相关依赖，包括cudnn7.6.5、cudatoolkit10.1、scipy、numpy等等</p><p>安装完成后可通过如下操作查看Tensorflow是否支持GPU</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">print(tf.test.is_gpu_avaliable())</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>使用GPU进行训练，实测一个epochs只需要16秒，比CPU训练快了进10倍</p><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>在实际使用时，调用<code>model.fit</code>训练，出现了如下报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not create cudnn handle: CUDNN_STATUS_INTERNAL_ERROR</span><br></pre></td></tr></table></figure><p>查了一些资料，是因为显卡内存不足导致的，可通过如下代码限制Tensorflow申请显存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gpus = tf.config.experimental.list_physical_devices(device_type=&#x27;GPU&#x27;)</span><br><span class="line">for gpu in gpus:</span><br><span class="line">    tf.config.experimental.set_memory_growth(gpu, </span><br><span class="line">       [tf.config.experiment.VirtualDeviceConfiguration(memory_limit=2048)])</span><br><span class="line">    tf.config.experimental.set_memory_growth(gpu, True)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Tensorflow做CS230触发词检测的train时，发现如果&lt;code&gt;learning rate=0.0001&lt;/code&gt;，训练500个epochs，12小时都训练不完，实在是太慢了。看CS230的教程上说在GPU上训练用时3个小时，因此研究了一下如何搭建一
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
      <category term="框架" scheme="http://yoursite.com/categories/ML/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Tensorflow" scheme="http://yoursite.com/categories/ML/%E6%A1%86%E6%9E%B6/Tensorflow/"/>
    
    
      <category term="Tensorflow" scheme="http://yoursite.com/tags/Tensorflow/"/>
    
      <category term="GPU" scheme="http://yoursite.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>TFLite Micro 编译生成动态链接库</title>
    <link href="http://yoursite.com/2020/05/09/TFLite-Micro-%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
    <id>http://yoursite.com/2020/05/09/TFLite-Micro-编译生成动态链接库/</id>
    <published>2020-05-09T06:08:25.000Z</published>
    <updated>2021-08-13T02:24:21.711Z</updated>
    
    <content type="html"><![CDATA[<p>研究Tensorflow Lite Microcontroller(TFLite Micro)好一段时间了，终于是搞明白了如何按照自己的需求编译生成动态链接库”libtensorflow-microlite.so”了！目前能够编译输出的库大小为2.5M，支持”full-connected”、”softmax”和卷积算子，两层全连接网络运行时占用16k内存</p><h2 id="TFLite-Micro介绍"><a href="#TFLite-Micro介绍" class="headerlink" title="TFLite Micro介绍"></a>TFLite Micro介绍</h2><p>自从2018年Google发布机器学习开源框架Tensorflow以来，它就一直是大家关注的焦点，我也一直关注着它的动态。Tensorflow更迭的很快，从最初的1.0版本到现在的2.1版本，它的功能变得更加强大，内置了神经网络高层API Keras，提供TensorBoard可视化网络，Tensor Hub和别人共享自己的模型，TFDS标准化Datasets操作，Tensorflow Serving专为服务端提供分布式计算架构，Tensorflow Lite(TFLite)专用于嵌入式设备。当然，我一直以来的兴趣点都在于赋予机器智能，自然对TFLite更感兴趣</p><p>Tensorflow Lite的核心功能在于它将模型的训练(train)和推断(inference)分离，为此主要提供了两个组件</p><ul><li><p>转换器(converter)：它将Tensorflow模型转换成一种中间格式文件(.tflite)，可被解释器解释</p></li><li><p>解释器(interpreter)：它可在不同平台上加载并运行模型</p></li></ul><p>因此，通常来说，我们可以在个人电脑或者工作站上使用Python、java等高级语言来设计、训练和验证评估模型，模型完善后，通过转换器转换为中间文件。将模型部署在嵌入式设备上时，交叉编译生成目标平台的解释器库，并编写代码通过解释器加载该模型</p><h2 id="TFLite-Micro的问题"><a href="#TFLite-Micro的问题" class="headerlink" title="TFLite Micro的问题"></a>TFLite Micro的问题</h2><p>Tensorflow希望TFLite可以在多种平台上部署，目前共支持Android、IOS、Linux和和Microcontrollers四种大类型的平台。Microcontrollers版本官方宣称可以适用于资源非常有限的嵌入式设备，例如在内存资源只有数千字节的ARM Cortex Mx架构上，不依赖操作系统，只需要支持标准C/C++和动态内存分配，运行时只占用不到20K内存空间，可完成语音识别等功能</p><p>听上去是个非常有吸引力的方向，但是在研究的时候，你会发现真正要把TFLite Micro落地，是一件非常困难的事情。首先，Tensorflow官方文档对这部分的介绍非常少，将TFLite源码编译生成动态或者静态库倒是很方便，但是要编译TFLite Micro生成库文件并调用，基本找不到说明文档。另外，源码只为几种特定的目标平台提供了完整的部署方案和示例，而真正项目中开发，并不会用到这些目标平台和相关的配套工具，而通常是源码+Makefile+交叉编译链这种非常原始原生的开发方式，需要提取一套非常独立的精简的源码来编译，甚至需要裁减部分功能，而这一点，我搜遍了百度、google，找不到任何一个有相关研究的文章</p><p>经过我大约一周的研究探索，终于是搞清楚了如何使用Tensorflow2.1版本编译生成TFLite Micro的动态链接库，并运行推断。关键点如下</p><ul><li><p>pip安装最新的Tensorflow</p></li><li><p>git clone最新的Tensorflow源码到本地</p></li><li><p>不需要对Tensorflow源码进行任何的编译</p></li><li><p>仿照一个预先定制化的<a href="%5Bhttps://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view%5D(https://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view">Tensorflow项目</a>，构建自己的定制化Tensorflow源码</p></li><li><p>编写Makefile，解决一些文件依赖问题，删除一些不必要的功能函数，生成动态链接库</p></li></ul><h2 id="TFLite-Micro的编译构建"><a href="#TFLite-Micro的编译构建" class="headerlink" title="TFLite Micro的编译构建"></a>TFLite Micro的编译构建</h2><p>TFLite Micro的源代码其实是非常独立的，并不太依赖很多其他文件。官方给出了一个预先定制化的<a href="%5Bhttps://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view%5D(https://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view">Tensorflow项目</a>，但是这个项目并不能拿来直接使用，因为它里面的很多源码并非基于2.1版本的Tensorflow，而是更早期的。因此，如果你想直接拿来用，必须找到对应版本的Tensorflow Python库并安装。我当然没有选择这种方式，因为2.1版本支持Keras模型转换，我比较喜欢用Keras来搭建模型</p><p>下载解压这个项目文件，你会得到三个目录：mbed、keil、make，分别对应3种构建方式的源码。我做嵌入式软件一般都是用make，因此本文主要介绍make方式构建的方法。每种构建方式的文件夹下都有多个构建示例，对应不同需求的项目，例如只需要解释器的micro_interpreter，要做语音识别的micro_speech，全连接的full_connected，不同需求需要的源码有一些差异</p><p>整体的构建方式是Makefile位于根目录，Tensorflow的源码按照固定的层级关系来放置，源码中的所有头文件引用已经做了相对路径处理，因此Makefile在处理include时，只需引用tensorflow这个路径就可以了。我选择全连接来做实验，根目录的情况如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">tensorflow third_party Makefile</span><br></pre></td></tr></table></figure><p>tensorflow路径下是Tensorflow源码，third_party路径下是一些第三方库，例如flatbuffer等，Makefile用于构建</p><h3 id="需要的源文件"><a href="#需要的源文件" class="headerlink" title="需要的源文件"></a>需要的源文件</h3><p>几个核心的源文件：micro_error_reporter.cc、micro_interpreter.cc、micro_allocator.cc、all_ops_resolver.cc、full_connected.cc，可以直接从现有源码中拷贝过来，保证路径一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp xxx/tensorflow/tensorflow/lite/micro/micro_interpreter.cc full_connected/tensorflow/lite/micro/</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>需要的文件路径，就与源码一一对应的建立，大致需要的路径结构如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|-- tensorflow</span><br><span class="line">    |-- core</span><br><span class="line">        |-- public</span><br><span class="line">    |-- lite</span><br><span class="line">        |-- c</span><br><span class="line">        |-- core</span><br><span class="line">            |-- api</span><br><span class="line">        |-- kernels</span><br><span class="line">            |-- internal</span><br><span class="line">                |-- optimized</span><br><span class="line">                |-- reference</span><br><span class="line">                    |-- integer_ops</span><br><span class="line">        |-- micro</span><br><span class="line">            |--kernels</span><br><span class="line">            |--memory_planner</span><br></pre></td></tr></table></figure><p>编译的时候，因为有.c和.cc两种文件，编译命令要分开，.c的用gcc，.cc的用g++。我的做法是先把必要的文件加进来，然后一边编译一边看报错，找不到定义的话就是缺头文件，找不到符号的话就是缺源文件，慢慢往里面添加，最终就会得到一个所有依赖都封闭的源文件夹。注意创建的文件路径一定要与源码中一致，例如”kernels”不要写成”kernel”</p><h3 id="算子裁减"><a href="#算子裁减" class="headerlink" title="算子裁减"></a>算子裁减</h3><p>在tensorflow/lite/micro/kernels/all_ops_resolver.cc文件中声明了所有需要用到的算子，源码中非常多，由于我只测试全连接，很多都不需要，因此只保留了”Register_FULL_CONNECTED()”、”Register_SOFTMAX()”和”Register_DEPTHWISE_CONV_2D”这3个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;研究Tensorflow Lite Microcontroller(TFLite Micro)好一段时间了，终于是搞明白了如何按照自己的需求编译生成动态链接库”libtensorflow-microlite.so”了！目前能够编译输出的库大小为2.5M，支持”full-co
      
    
    </summary>
    
    
      <category term="Tensorflow" scheme="http://yoursite.com/tags/Tensorflow/"/>
    
      <category term="嵌入式" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻202005</title>
    <link href="http://yoursite.com/2020/05/09/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202005/"/>
    <id>http://yoursite.com/2020/05/09/每月见闻202005/</id>
    <published>2020-05-09T04:08:05.000Z</published>
    <updated>2021-08-13T02:24:21.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li><p><a href="[https://oschvr.com/posts/blocking-ads-with-pihole/](https://oschvr.com/posts/blocking-ads-with-pihole/">Blocking Ads with PiHole</a></p><p>一篇详细的操作指导，一步步教你在树莓派上面安装 Pi-Hole，架设一个可以屏蔽广告的 DNS 服务器</p></li><li><p><a href="https://medium.com/swlh/git-worktrees-the-best-git-feature-youve-never-heard-of-9cd21df67baf">Git Worktree：你从未听说过的最好的 Git 功能</a></p><p>这篇文章简单介绍了 git worktree 功能，也就是让一个代码库的两个分支同时都可以访问的功能</p></li><li><p><a href="https://mp.weixin.qq.com/s/G-LyRhJwhYk1rvj6vmMFLg">TensorFlow Lite 新功能亮相 TF DevSummit ‘20</a></p><p>在即将推出的Tensorflow 2.3版本中，针对Lite做了很多改进，旨在提供更方便、更快的学习框架。启用了最前沿的SOTA模型，使用了新的TensorFlow Lite 转换器，支持更多模型，支持 Keras 模型的训练时量化</p></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><p><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/rpi_DATA_2711_1p0.pdf">BCM2711 datasheet</a></p><p>树梅派4代的CPU datasheet终于公布了完整版本</p></li><li><p><a href="[https://tf.wiki/zh_hans/mlstudyjam.html](https://tf.wiki/zh_hans/mlstudyjam.html">简单粗暴的Tensorflow2.0</a></p><p>一个很棒的中文Tensorflow2.0在线文档</p></li><li><p><a href="https://lavanya.ai/">lavanya.ai</a></p><p>一个kaggle大神blog，介绍她很多比赛都能名列前茅的方法</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;[https://oschvr.com/posts/blocking-ads-with-pihole/]
      
    
    </summary>
    
    
      <category term="每月见闻" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>TFLite Micro - Hello World</title>
    <link href="http://yoursite.com/2020/05/09/TFLite-Micro-Hello-World/"/>
    <id>http://yoursite.com/2020/05/09/TFLite-Micro-Hello-World/</id>
    <published>2020-05-09T04:07:11.000Z</published>
    <updated>2021-08-13T02:24:21.700Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于定制化的TFLite Micro动态链接库，通过”hello world”示例来验证TFLite Micro版本的功能。虽然名字叫是”hello world”，其实并不是在控制台上打印出”hello world”这么简单，而是用Python版本的Tensorflow构建训练一个能够学习并生成正弦波的模型，通过TFLite的转换器转换为.tflite文件，并使用TFLite Micro动态链接库加载并执行推断的过程</p><p>开发环境</p><ul><li><p>Inter i5-7200U</p></li><li><p>Ubuntu18.04.2 x86_64</p></li><li><p>conda Python3.7虚拟环境</p></li><li><p>Tensorflow2.1.0</p></li></ul><p>参考</p><ul><li><p><a href="http://tensorflow.google.cn/">http://tensorflow.google.cn/</a></p></li><li><p>tensorflow/tensorflow/lite/micro/examples/hello_world/create_sine_model.ipynb</p></li></ul><h2 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h2><p>首先需要加载一些python库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure><p>以下代码生成一组随机数，并计算它们的正弦值，并绘图显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SAMPLES = <span class="number">1000</span></span><br><span class="line">np.random.seed(<span class="number">1337</span>)</span><br><span class="line">x_values = np.random.uniform(low=<span class="number">0</span>, high=<span class="number">2</span>*math.pi, size=SAMPLES)</span><br><span class="line">np.random.shuffle(x_values)</span><br><span class="line">y_values = np.sin(x_values)</span><br><span class="line">plt.plot(x_values, y_values, <span class="string">&#x27;b.&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/01.png" alt></p><h2 id="添加噪声"><a href="#添加噪声" class="headerlink" title="添加噪声"></a>添加噪声</h2><p>由于数据是由正弦函数直接生成，数据太过平滑。然而现实中获取的各种信号必然夹杂着噪声数据，而机器学习算法能够从带有噪声的数据中学习到真正的信息</p><p>为数据添加一些噪声，并绘制显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_values += <span class="number">0.1</span> * np.random.randn(*y_values.shape)</span><br><span class="line">plt.plot(x_values, y_values, <span class="string">&#x27;b.&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/02.png" alt></p><h2 id="拆分数据"><a href="#拆分数据" class="headerlink" title="拆分数据"></a>拆分数据</h2><p>我们已经生成了一个近似真实世界的噪声数据，我们用它来训练模型</p><p>为了验证评估模型，以及防止数据的过拟合，我们将数据拆分为训练集、测试集和验证集3部分，比例为3:1:1</p><p>以下代码将数据分割，并以不同的颜色显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TRAIN_SPLIT =  <span class="built_in">int</span>(<span class="number">0.6</span> * SAMPLES)</span><br><span class="line">TEST_SPLIT = <span class="built_in">int</span>(<span class="number">0.2</span> * SAMPLES + TRAIN_SPLIT)</span><br><span class="line">x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])</span><br><span class="line">y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])</span><br><span class="line">plt.plot(x_train, y_train, <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&quot;Train&quot;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;r.&#x27;</span>, label=<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">plt.plot(x_validate, y_validate, <span class="string">&#x27;y.&#x27;</span>, label=<span class="string">&quot;Validate&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/03.png" alt></p><h2 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h2><p>我们将建立一个模型，它接收一个输入，并用它来预测一个输出，此类问题称为回归问题。为了达到这个目的，我们将创建一个简单的神经网络，它将使用多层的神经元来学习数据背后的模式，以便进行预测</p><p>首先，我们定义两个层。第一层接收一个输入，并经过16个神经元。输入到来时，每个神经元将根据自身的权重和偏置状态受到不同程度的激活，神经元的激活程度由数字表示。第一层的激活将作为第二层的输入，第二层的输出作为模型的输出值</p><p>我们使用Keras来定义模型，模型使用”relu”作为激活函数，优化器使用”rmsprop”，损失函数使用”mse”，使用MAE来评估</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line">model_1 = tf.keras.Sequential()</span><br><span class="line">model_1.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">1</span>,)))</span><br><span class="line">model_1.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line">model_1.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>, metrics=[<span class="string">&#x27;mae&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>一旦我们定义好了模型，可以使用数据来训练它。训练过程将x输入到网络中，检查网络输出与原始数据的偏离程度，并调整神经元的偏置和权重。训练过程是在整个数据上多次运行，每次完整的运行都称为”epoch”。在每个”epoch”中，数据以多批次的方式在网络中运行，每一批次都有几个数据进入网络并输出，对网络参数的调整是以一个批次为单位的。”epoch”次数和批次大小都可以通过参数调整</p><p>以下代码运行1000个”epoch”，每个批次16个数据，还传递一些数据用于验证。整个训练需要一定的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history_1 = model_1.fit(x_train, y_train, epochs=<span class="number">1000</span>, batch_size=<span class="number">16</span>,</span><br><span class="line">                    validation_data=(x_validate, y_validate))</span><br></pre></td></tr></table></figure><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>在训练期间，模型的性能在数据迭代中不断的提升，训练会生成一个日志，告诉我们性能在训练过程中是如何变化的。以下代码将以图形形式显示其中一些信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loss = history_1.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history_1.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/04.png" alt></p><p>图形中显示了每个epoch的损失函数情况。有多种方式的损失函数，这里我们使用的是均方误差MSE。损失函数在前25个epoch迅速减少，之后趋于平缓，这意味着模型在不断改进。我们的目标是当模型不再改进，或者当训练损失小于验证损失时，意味着学习已经收敛，需要停止训练。为了更清楚的观察平坦部分，我们跳过前50个epoch的训练情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SKIP = <span class="number">50</span></span><br><span class="line">plt.plot(epochs[SKIP:], loss[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_loss[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/05.png" alt></p><p>从上图中可以看出，损失在前600个epoch持续减少，到600之后不再变化，这意味着600之后的训练是没有必要的。同时，我们也可以看到，最低的损失函数值仍然在0.155左右，这意味着我们的网络预测平均偏离了15%。另外，验证损失值跳变很多。为了了解更多模型的性能，我们可以绘制更多数据，这次我们输出MAE平均绝对误差，这是测量网络预测与实际之间差距距离的另一种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plt.clf()</span><br><span class="line">mae = history_1.history[<span class="string">&#x27;mae&#x27;</span>]</span><br><span class="line">val_mae = history_1.history[<span class="string">&#x27;val_mae&#x27;</span>]</span><br><span class="line">plt.plot(epochs[SKIP:], mae[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training MAE&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_mae[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation MAE&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation mean absolute error&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;MAE&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/06.png" alt></p><p>这幅图告诉了我们更多的信息。训练数据的MAE始终低于验证数据的MAE，这意味着网络可能有过拟合，或者学习训练数据太僵硬，以至于无法对新数据做出有效预测。此外，MAE整体都较高，最多为0.305，这表明模型的预测有30%的偏差。为了更清楚的了解到发生了什么，我们可以将网络预测值和实际训练值进行比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">predictions = model_1.predict(x_train)</span><br><span class="line">plt.clf()</span><br><span class="line">plt.title(<span class="string">&#x27;Training data predicted vs actual values&#x27;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">plt.plot(x_train, predictions, <span class="string">&#x27;r.&#x27;</span>, label=<span class="string">&#x27;Predicted&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/07.png" alt></p><p>这张图表明网络已经学会以非常有限的方式逼近正弦函数，但是这是一个线性的逼近。这种拟合的刚性表明，该模型没有足够的能力来学习正弦波函数的全部复杂性，因此只能用过于简单的方法来近似它。我们可以修改模型，来改进性能</p><h2 id="改变模型"><a href="#改变模型" class="headerlink" title="改变模型"></a>改变模型</h2><p>再增加一层神经元，以下增加一个16个神经元的层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model_2 = tf.keras.Sequential()</span><br><span class="line">model_2.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">1</span>,)))</span><br><span class="line">model_2.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model_2.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line">model_2.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>, metrics=[<span class="string">&#x27;mae&#x27;</span>])</span><br></pre></td></tr></table></figure><p>我们现在将训练新模型。为了节省时间，我们只训练600个epoch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history_2 = model_2.fit(x_train, y_train, epochs=<span class="number">600</span>, batch_size=<span class="number">16</span>,</span><br><span class="line">                    validation_data=(x_validate, y_validate))</span><br></pre></td></tr></table></figure><h2 id="再次评估模型"><a href="#再次评估模型" class="headerlink" title="再次评估模型"></a>再次评估模型</h2><p>可以看到，模型已经有了很大改进，验证损失从0.15降到0.015，验证MAE从0.31降低到0.1</p><p>以下代码显示新模型训练的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">loss = history_2.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history_2.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">SKIP = <span class="number">100</span></span><br><span class="line">plt.clf()</span><br><span class="line">plt.plot(epochs[SKIP:], loss[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_loss[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">mae = history_2.history[<span class="string">&#x27;mae&#x27;</span>]</span><br><span class="line">val_mae = history_2.history[<span class="string">&#x27;val_mae&#x27;</span>]</span><br><span class="line">plt.plot(epochs[SKIP:], mae[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training MAE&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_mae[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation MAE&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation mean absolute error&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/08.png" alt></p><p><img src="TFLite-Micro-Hello-World/images/09.png" alt></p><p><img src="TFLite-Micro-Hello-World/images/10.png" alt></p><p>很好的结果，从图中可以看到一些令人兴奋的事情</p><ul><li><p>我们的网络已经更快地达到了它的最高精度(在200个epoch而不是600个)</p></li><li><p>总的损失和MAE比之前的网络好得多</p></li><li><p>验证误差比训练误差更小，这意味着网络并没有过拟合</p></li></ul><p>让我们对照模型的预测值和训练数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loss = model_2.evaluate(x_test, y_test)</span><br><span class="line">predictions = model_2.predict(x_test)</span><br><span class="line">plt.clf()</span><br><span class="line">plt.title(<span class="string">&#x27;Comparison of predictions and actual values&#x27;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">plt.plot(x_test, predictions, <span class="string">&#x27;r.&#x27;</span>, label=<span class="string">&#x27;Predicted&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/11.png" alt></p><p>由上图看出，预测结果与我们的数据非常吻合。这个模型并不完美，它的预测并没有形成一个平滑的正弦曲线，如果我们想更进一步，我们可以尝试进一步增加模型的容量，也许可以使用一些技术来防止过度拟合。然而，机器学习的一个重要部分是知道什么时候停止，这个模型对于我们示例来说已经足够好了</p><h2 id="转换模型到TFLite"><a href="#转换模型到TFLite" class="headerlink" title="转换模型到TFLite"></a>转换模型到TFLite</h2><p>将模型用于TFLite微控制器，需要将其转换为正确的格式，为此我们将使用Tensorflow Lite转换器，转换器可以以一种特殊的、节省空间的格式将模型输出到文件。由于是部署到微控制器上，我们希望它尽可能小，可以通过量化的方法减小尺寸。它降低了模型权重的精度，以节省内存。因为量化模型更小，因此运行起来也更快</p><p>转换器可以在转换时选择是否进行量化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">converter = tf.lite.TFLiteConverter.from_keras_model(model_2)</span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;sine_model.tflite&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(tflite_model)</span><br><span class="line">converter = tf.lite.TFLiteConverter.from_keras_model(model_2)</span><br><span class="line">converter.optimizations = [tf.lite.Optimize.OPTIMIZE_FOR_SIZE]</span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;sine_model_quantized.tflite&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(tflite_model)</span><br></pre></td></tr></table></figure><p>执行以上代码可以看到，未量化的模型大小为2732KB，量化模型大小为2720KB</p><h2 id="测试转换后的模型"><a href="#测试转换后的模型" class="headerlink" title="测试转换后的模型"></a>测试转换后的模型</h2><p>为了证明这些模型在转换和量化之后仍然是准确的，我们将使用这两个模型进行预测，并将其与我们的测试结果进行比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sine_model = tf.lite.Interpreter(<span class="string">&#x27;sine_model.tflite&#x27;</span>)</span><br><span class="line">sine_model_quantized = tf.lite.Interpreter(<span class="string">&#x27;sine_model_quantized.tflite&#x27;</span>)</span><br><span class="line">sine_model.allocate_tensors()</span><br><span class="line">sine_model_quantized.allocate_tensors()</span><br><span class="line">sine_model_input = sine_model.tensor(sine_model.get_input_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_output = sine_model.tensor(sine_model.get_output_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_quantized_input = sine_model_quantized.tensor(sine_model_quantized.get_input_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_quantized_output = sine_model_quantized.tensor(sine_model_quantized.get_output_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_predictions = np.empty(x_test.size)</span><br><span class="line">sine_model_quantized_predictions = np.empty(x_test.size)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x_test.size):</span><br><span class="line">    sine_model_input().fill(x_test[i])</span><br><span class="line">    sine_model.invoke()</span><br><span class="line">    sine_model_predictions[i] = sine_model_output()[<span class="number">0</span>]</span><br><span class="line">    sine_model_quantized_input().fill(x_test[i])</span><br><span class="line">    sine_model_quantized.invoke()</span><br><span class="line">    sine_model_quantized_predictions[i] = sine_model_quantized_output()[<span class="number">0</span>]</span><br><span class="line">plt.clf()</span><br><span class="line">plt.title(<span class="string">&#x27;Comparison of various models against actual values&#x27;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">plt.plot(x_test, predictions, <span class="string">&#x27;ro&#x27;</span>, label=<span class="string">&#x27;Original predictions&#x27;</span>)</span><br><span class="line">plt.plot(x_test, sine_model_predictions, <span class="string">&#x27;bx&#x27;</span>, label=<span class="string">&#x27;Lite predictions&#x27;</span>)</span><br><span class="line">plt.plot(x_test, sine_model_quantized_predictions, <span class="string">&#x27;gx&#x27;</span>, label=<span class="string">&#x27;Lite quantized predictions&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="TFLite-Micro-Hello-World/images/12.png" alt></p><p>从图中我们可以看出，对原始模型、转换模型和量化模型的预测都非常接近，无法区分。这意味着我们的量化模型已经可以使用了！</p><h2 id="使用C-程序执行推断"><a href="#使用C-程序执行推断" class="headerlink" title="使用C++程序执行推断"></a>使用C++程序执行推断</h2><p>这里使用C++程序需要依赖TFLite Micro动态链接库，参见<a href></a></p><p>通过xxd命令将模型文件转换为C++源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -i sine_model_quantized.tflite &gt; sine_model_quantized.cc</span><br></pre></td></tr></table></figure><p>可以看到生成的C++文件中，模型是以字节序列存放的，并通过sine_model_quantized.h文件向外暴露模型地址和长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sine_model_quantized_tflite[] = &#123;</span><br><span class="line">  <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x4c</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0e</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x0c</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x00</span>,</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sine_model_quantized_tflite_len = <span class="number">2640</span>;</span><br></pre></td></tr></table></figure><p>我们创建一个main.cc源文件，用来加载模型并循环执行推断，将模型输出导出到csv文件中，最后用python绘图呈现模型的预测效果</p><h3 id="引用一些头文件"><a href="#引用一些头文件" class="headerlink" title="引用一些头文件"></a>引用一些头文件</h3><p>TFLite Micro程序需要引用一些必要的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/kernels/all_ops_resolver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/micro_error_reporter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/micro_interpreter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/debug_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorlfow/lite/version.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sine_model_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>all_ops_resolver.h文件中定义了一些优化器相关的运算组建，例如全连接(Full Connected, FC)、柔性最大化函数Softmax、卷积conv</p><p>micro_error_reporter.h文件中定义了调试方法</p><p>micro_interpreter.h文件中是解释器的定义</p><p>sin_model_data.h引用模型文件</p><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><p>首先创建一个调试器reporter</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tflite::MicroErrorReporter micro_error_reporter;</span><br><span class="line">tflite::ErrorReporter* error_reporter = &amp; micro_error_reporter;</span><br></pre></td></tr></table></figure><p>调用GetModel()方法加载模型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tflite::Model* model = ::tflite::<span class="built_in">GetModel</span>(g_sine_model_data);</span><br><span class="line"><span class="keyword">if</span> (model-&gt;<span class="built_in">version</span>() != TFLITE_SCHEMA_VERSION) &#123;</span><br><span class="line">    error_reporter-&gt;<span class="built_in">Report</span>(</span><br><span class="line">        <span class="string">&quot;Model provided is schema version %d not equal &quot;</span></span><br><span class="line">        <span class="string">&quot;to supported version %d.\n&quot;</span>,</span><br><span class="line">        model-&gt;<span class="built_in">version</span>(), TFLITE_SCHEMA_VERSION);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个运算器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tflite::ops::micro::AllOpsResolver resolver;</span><br></pre></td></tr></table></figure><p>创建解释器，并为模型推断分配内存空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tensor_arena_size = <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> tensor_arena[tensor_arena_size];</span><br><span class="line"><span class="function">tflite::MicroInterpreter <span class="title">interpreter</span><span class="params">(model, resolver,tensor_arena,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     tensor_arena_size, error_reporter)</span></span>;</span><br><span class="line"></span><br><span class="line">    TfLiteStatus alloc_status = interpreter.<span class="built_in">AllocateTensors</span>();</span><br><span class="line"><span class="keyword">if</span> (alloc_status != kTfLiteOk) &#123;</span><br><span class="line">    error_reporter-&gt;<span class="built_in">Report</span>(<span class="string">&quot;Alloc tensors Error:%d&quot;</span>, alloc_status);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建指针指向模型输入和输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tflite::MicroInterpreter *inter = &amp;interpreter;</span><br><span class="line">TfLiteTensor* input = interpreter.<span class="built_in">input</span>(<span class="number">0</span>);</span><br><span class="line">TfLiteTensor* output = interpreter.<span class="built_in">output</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>创建csv文件”data.csv”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, ios::out);</span><br></pre></td></tr></table></figure><p>以下循环，产生1000个输入，执行模型推断，并将输入和输出保存到csv文件，并打印到屏幕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> kInferencesPerCycle = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> kXrange = <span class="number">2.f</span> * <span class="number">3.14159265359f</span>;</span><br><span class="line"><span class="keyword">int</span> inference_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> position = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(inference_count) /</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(kInferencesPerCycle);</span><br><span class="line">    <span class="keyword">float</span> x_val = position * kXrange;</span><br><span class="line">    <span class="comment">//error_reporter-&gt;Report(&quot;x_val:%f&quot;, x_val);</span></span><br><span class="line">    input-&gt;data.f[<span class="number">0</span>] = x_val;</span><br><span class="line">    TfLiteStatus invoke_status = inter-&gt;<span class="built_in">Invoke</span>();</span><br><span class="line">    <span class="keyword">if</span> (invoke_status != kTfLiteOk) &#123;</span><br><span class="line">        error_reporter-&gt;<span class="built_in">Report</span>(<span class="string">&quot;Invoke Error:%d&quot;</span>, invoke_status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> y_val = output-&gt;data.f[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%f, y:%f\r\n&quot;</span>,x_val, y_val);</span><br><span class="line">    outFile&lt;&lt;x_val&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;y_val&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    inference_count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (inference_count &gt;= kInferencesPerCycle) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>编译程序并运行，数据保存到了”data.csv”文件中，查看其内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cat data.csv | head -n 20</span><br><span class="line">0,0.0486171</span><br><span class="line">0.00628319,0.0537117</span><br><span class="line">0.0125664,0.0588063</span><br><span class="line">0.0188496,0.0639008</span><br><span class="line">0.0251327,0.0689952</span><br><span class="line">0.0314159,0.0740901</span><br><span class="line">0.0376991,0.0791845</span><br><span class="line">0.0439823,0.0842792</span><br><span class="line">0.0502655,0.0893737</span><br><span class="line">0.0565487,0.0944682</span><br><span class="line">0.0628319,0.0995628</span><br><span class="line">0.069115,0.104657</span><br><span class="line">0.0753982,0.109752</span><br><span class="line">0.0816814,0.114847</span><br><span class="line">0.0879646,0.119941</span><br><span class="line">0.0942478,0.125036</span><br><span class="line">0.100531,0.13013</span><br><span class="line">0.106814,0.135225</span><br><span class="line">0.113097,0.14032</span><br><span class="line">0.119381,0.145414</span><br></pre></td></tr></table></figure><p>编写python脚本draw.py读取data.csv文件并将数值绘制出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">X = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> myFile:</span><br><span class="line">    lines=csv.reader(myFile)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        x = <span class="built_in">float</span>(line[<span class="number">0</span>])</span><br><span class="line">        y = <span class="built_in">float</span>(line[<span class="number">1</span>])</span><br><span class="line">        X.append(x)</span><br><span class="line">        Y.append(y)</span><br><span class="line"></span><br><span class="line">plt.plot(X, Y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>执行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python draw.py</span><br></pre></td></tr></table></figure><p>结果如图</p><p><img src="TFLite-Micro-Hello-World/images/13.png" alt></p><p>可见模型输出的结果准确</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基于定制化的TFLite Micro动态链接库，通过”hello world”示例来验证TFLite Micro版本的功能。虽然名字叫是”hello world”，其实并不是在控制台上打印出”hello world”这么简单，而是用Python版本的Tensorflow
      
    
    </summary>
    
      <category term="ML" scheme="http://yoursite.com/categories/ML/"/>
    
      <category term="框架" scheme="http://yoursite.com/categories/ML/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Tensorflow" scheme="http://yoursite.com/categories/ML/%E6%A1%86%E6%9E%B6/Tensorflow/"/>
    
    
      <category term="Tensorflow" scheme="http://yoursite.com/tags/Tensorflow/"/>
    
      <category term="嵌入式" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻202004</title>
    <link href="http://yoursite.com/2020/04/21/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202004/"/>
    <id>http://yoursite.com/2020/04/21/每月见闻202004/</id>
    <published>2020-04-21T02:15:25.000Z</published>
    <updated>2021-08-13T02:24:21.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h1><ul><li><p><a href="https://www.bilibili.com/video/BV1U64y1u7oz">TinyML</a><br>该视频介绍了”Machine Learning with TensorFlow Lite on Arduino and Ultra-Low-Power Microcontrollers”这本书，该书研究将机器学习应用于低功耗的嵌入式设备当中的问题，例如将Tensorflow Lite应用于Arduino。有空可以了解一下，看能否用于NB-IoT设备</p><p>另外TinyML还有一个<a href="[https://www.tinyml.org/summit/](https://www.tinyml.org/summit/">网站</a>)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Book&quot;&gt;&lt;a href=&quot;#Book&quot; class=&quot;headerlink&quot; title=&quot;Book&quot;&gt;&lt;/a&gt;Book&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1U64y1u7oz&quot;
      
    
    </summary>
    
    
      <category term="每月见闻" scheme="http://yoursite.com/tags/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>Narrowband Power Optimizations for Massive IoT: eDRX and PSM[译]</title>
    <link href="http://yoursite.com/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-%E8%AF%91/"/>
    <id>http://yoursite.com/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-译/</id>
    <published>2020-04-17T02:47:50.000Z</published>
    <updated>2021-08-13T02:24:21.640Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自twilio网站文章<a href="[https://www.twilio.com/docs/wireless/nb/nb-iot-power-optimizations-edrx-psm](https://www.twilio.com/docs/wireless/nb/nb-iot-power-optimizations-edrx-psm">Narrowband Power Optimizations for Massive IoT: eDRX and PSM</a>)</p><p>NB-IoT(Narrowband IoT, 窄带物联网)蜂窝技术是为低功耗设备而设计的。它包含了大量物联网设备开发人员可以使用的功能，例如位置跟踪器、低成本传感器网络、公用电表和预防性维护监视器，以将产品的电力消耗降到最低</p><p>本指南描述了其中的两个优化特性，即PSM(省电模式, Power Save Mode)和eDRX(扩展不连续接收, Extended Discontinuous Reception)，以帮助您评估它们如何为您的大规模物联网应用程序带来好处，以及如何利用它们</p><h2 id="PSM"><a href="#PSM" class="headerlink" title="PSM"></a>PSM</h2><p>通常，大多数物联网设备间歇性地发送或接收数据。在数据的发送和接收之间，可以让设备处于休眠状态，以最大限度的降低功耗，最大化电池能量</p><p>PSM是蜂窝调制解调器的一种特性，它可以关闭设备无线电并使设备进入休眠状态，而无需在下次醒来时re-attach(重新附着)到网络。虽然re-attach过程只消耗少量的能量，但是在设备的整个生命周期中，re-attach的累积能量消耗可能变得非常大。因此，如果可以避免re-attach，可使得电池寿命延长。PSM刚好提供了这一点</p><ul><li><p>PSM是一种降低无线电能量消耗的设备端机制。设备报告网络自己需要多频繁和多长时间处于活跃状态，以便传输和接收数据。然而，最终的值是由网络决定的</p></li><li><p>PSM模式类似于断电，但是设备在网络中的状态仍然保持为已注册。当设备再次活跃时，没有必要re-attach或re-establish(重新建立)PDN(数据包数据网络, Packet Data Network)连接</p></li><li><p>PSM特性是在3GPP Release 12 中引入的，适用于所有LTE设备类别。设备请求PSM只需在attach、TAU(跟踪区域更新, tracking area udpate)或者路由区域更新中包含一个带有所需值的计时器</p></li></ul><p><img src="/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-%E8%AF%91/image/01.png" alt></p><h3 id="PSM-FAQS"><a href="#PSM-FAQS" class="headerlink" title="PSM FAQS"></a>PSM FAQS</h3><h4 id="它如何工作？"><a href="#它如何工作？" class="headerlink" title="它如何工作？"></a>它如何工作？</h4><p>当设备通过网络初始化PSM时，它提供两个首选计时器(T3324和T3412)；PSM时间是这两个计时器的差值(T3412减去T3324)。网络可以接受这些值，也可以设置不同的值。然后网络保留状态信息，设备保持在网络上注册。如果设备在它与网络约定的时间间隔到期之前唤醒并发送数据，则不需要re-attach过程</p><h4 id="当设备处于活跃PSM周期时，它可以接收消息吗"><a href="#当设备处于活跃PSM周期时，它可以接收消息吗" class="headerlink" title="当设备处于活跃PSM周期时，它可以接收消息吗?"></a>当设备处于活跃PSM周期时，它可以接收消息吗?</h4><p>不能，在活跃PSM周期时无法访问设备</p><h4 id="当设备处于活跃PSM周期时，是否可以通过NIDD-非ip数据传递-Non-IP-Data-Delivery-访问它"><a href="#当设备处于活跃PSM周期时，是否可以通过NIDD-非ip数据传递-Non-IP-Data-Delivery-访问它" class="headerlink" title="当设备处于活跃PSM周期时，是否可以通过NIDD(非ip数据传递, Non-IP Data Delivery)访问它?"></a>当设备处于活跃PSM周期时，是否可以通过NIDD(非ip数据传递, Non-IP Data Delivery)访问它?</h4><p>不能，NIDD通过寻呼信道工作(paging channel)，该信道利用无线电。在活跃PSM周期中，无线电完全关闭，无法访问设备</p><h4 id="在活跃PSM周期中发送到设备的数据包会发生什么"><a href="#在活跃PSM周期中发送到设备的数据包会发生什么" class="headerlink" title="在活跃PSM周期中发送到设备的数据包会发生什么?"></a>在活跃PSM周期中发送到设备的数据包会发生什么?</h4><p>3GPP要求必须由网络存储数据包。建议网络操作员至少为最后一个100字节的数据包留出存储空间</p><h4 id="一个设备可以在PSM周期中停留多久？"><a href="#一个设备可以在PSM周期中停留多久？" class="headerlink" title="一个设备可以在PSM周期中停留多久？"></a>一个设备可以在PSM周期中停留多久？</h4><p>在T-Mobile的NB-IoT网络上，一个设备可以在PSM循环中最多停留12小时</p><h2 id="使用PSM"><a href="#使用PSM" class="headerlink" title="使用PSM"></a>使用PSM</h2><p>蜂窝模块必须支持PSM。可以使用设备上的AT命令来启用它</p><p>例如，如果你使用的是Quectel BG96调制解调器，你可以发送以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT+QCFG=&quot;psm/urc&quot;[enable]</span><br><span class="line"></span><br><span class="line">AT+QPSMTIMER: &lt;tau_timer&gt;,&lt;T3324_timer&gt;</span><br></pre></td></tr></table></figure><p>不需要用户进行网络配置；在设备上启用PSM就足够了</p><p>根据GPRS Timer 3规范(见3GPP TS 24.008第<a href="[https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf](https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf">10.5.7.4a</a>)节)，要求的周期TAU定时器值编码如下：</p><p>第5位到第1位表示二进制编码的定时器值。第6位到第8位定义计时器的计时器值单元，如下所示</p><div class="table-container"><table><thead><tr><th>Timer 3 value</th><th>Timer value is incremented in multiples of</th></tr></thead><tbody><tr><td>000xxxxx</td><td>10 minutes</td></tr><tr><td>001xxxxx</td><td>1 hour</td></tr><tr><td>010xxxxx</td><td>10 hours</td></tr><tr><td>011xxxxx</td><td>2 seconds</td></tr><tr><td>100xxxxx</td><td>30 seconds</td></tr><tr><td>101xxxxx</td><td>1 minute</td></tr><tr><td>110xxxxx</td><td>320 hours*</td></tr><tr><td>111xxxxx</td><td>Timer is deactivated</td></tr></tbody></table></div><blockquote><p>参见3GPP <a href="[https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf](https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf">TS 24.008</a>)规范中的说明，表10.5.163a提供了关于这个值的更多信息</p></blockquote><p>请求的活跃时间是由GPRS Timer 2规范的octet 3定义的一个二进制字符串字节值(见3GPP <a href="[https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf]](https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf%5D">TS 24.008</a>(<a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf">https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf</a>)的10.5.7.4节)，如下所示：</p><p>bi5到1表示二进制编码计时器值。第6到8位定义计时器的定时器如下</p><div class="table-container"><table><thead><tr><th>Timer 3 value</th><th>Timer value is incremented in multiples of</th></tr></thead><tbody><tr><td>000xxxxx</td><td>2 seconds</td></tr><tr><td>001xxxxx</td><td>1 minute</td></tr><tr><td>010xxxxx</td><td>1 decihour (6 minutes)</td></tr><tr><td>111xxxxx</td><td>Timer is deactivated</td></tr></tbody></table></div><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CPSMS=1,,,&quot;01000011&quot;,&quot;01000011&quot;</span><br></pre></td></tr></table></figure><p>以上命令使得PSM周期TAU值变为30小时，请求的活动时间为18分钟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CPSMS=0</span><br></pre></td></tr></table></figure><p>以上命令禁用PSM</p><h2 id="eDRX"><a href="#eDRX" class="headerlink" title="eDRX"></a>eDRX</h2><p>eDRX是现有LTE功能的扩展，可以被物联网设备用来降低功耗。eDRX可以在没有PSM的情况下使用，也可以与PSM结合使用，以获得额外的电能节省</p><p>eDRX允许大大扩展设备不监听网络的时间间隔。对于一个大规模的物联网应用程序，设备在几秒钟或更长时间内无法访问是完全可以接受的。虽然eDX不能提供与PSM相同的功耗降低级别，但它可以在设备可达性和某些应用程序的功耗之间提供一个很好的折衷。网络和设备在设备可以睡眠时进行协商。设备在规定的周期内保持其接收电路关闭，在此期间，设备不侦听寻呼或下行控制信道。当设备醒来时，接收器将监听物理控制通道</p><p><img src="/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-%E8%AF%91/image/02.png" alt></p><p>eDRX只允许在一定期限内使用；以下列出了这些项目：</p><ul><li><p>20.48 seconds</p></li><li><p>40.96 seconds</p></li><li><p>81.92 seconds (~1 minute)</p></li><li><p>163.84 seconds (~ 3 min)</p></li><li><p>327.68 seconds (~ 5 min)</p></li><li><p>655.36 seconds (~ 11 min)</p></li><li><p>1310.72 seconds (~22 min)</p></li><li><p>2621.44 seconds (~44 min)</p></li><li><p>5242.88 seconds (~87 min)</p></li><li><p>10485.76 seconds (~175 min)</p></li></ul><h3 id="使用eDRX"><a href="#使用eDRX" class="headerlink" title="使用eDRX"></a>使用eDRX</h3><p>eDRX的支持因运营商而异。设备向网络请求一个给定的eDRX周期；网络使用实际使用的eDRX周期和PTW(巡护时间窗口)应答</p><p>启用eDRX不会对模块发送数据的能力产生负面影响，但是会关闭对所配置的周期间隔的接收，从而节约电能</p><p>T-Mobile支持所有文档(见表10.5.5.32 3GPP TS 24.008)值的窄带eDRX循环，NB-S1模式，范围从~20s (20.48s)到~3hrs (10485.76s)。值由表单的位串表示：</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>“0010”</td><td>20.48s</td></tr><tr><td>“0011”</td><td>40.96s</td></tr><tr><td>“0101”</td><td>81.92s</td></tr><tr><td>“1001”</td><td>163.84s</td></tr><tr><td>“1010”</td><td>327.68s</td></tr><tr><td>“1011”</td><td>655.36s</td></tr><tr><td>“1100”</td><td>1310.72s</td></tr><tr><td>“1101”</td><td>2621.44s</td></tr><tr><td>“1101”</td><td>2621.44s</td></tr><tr><td>“1110”</td><td>5242.88s</td></tr><tr><td>“1111”</td><td>10485.76s (~175min)</td></tr></tbody></table></div><p>根据您的产品使用的NB-IoT模块，请求的eDRX周期可以存储在非易失性内存中，并在会话之间保持。模块通常支持禁用eDRX和一个后续的AT命令，以及一个恢复默认值的选项</p><p>要在u-blox SARA-N410-02b和Quectel BG96上为NB模块配置eDRX，可以使用AT+CEDRXS命令，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CEDRXS=2,5,&quot;1001&quot;</span><br></pre></td></tr></table></figure><p>这要求在窄带(5)的URC反馈(2)和163.84s(“1001”)的eDRX循环时间下启用eDRX</p><p>如果配置了URC，网络将通过重复请求的周期间隔以及实际有效的周期间隔和网络指定的PTW时间来响应。上述命令的一个URC示例是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+CEDRXP: [5,&quot;1001&quot;,&quot;1001&quot;,&quot;0111&quot;]</span><br></pre></td></tr></table></figure><p>为NB-S1返回的PTW值对应于以下时间：</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>“0000”</td><td>2.56s</td></tr><tr><td>“0001”</td><td>5.12s</td></tr><tr><td>“0010”</td><td>7.68s</td></tr><tr><td>“0011”</td><td>10.24s</td></tr><tr><td>“0100”</td><td>12.8s</td></tr><tr><td>“0101”</td><td>15.36s</td></tr><tr><td>“0110”</td><td>17.92s</td></tr><tr><td>“0111”</td><td>20.48s</td></tr><tr><td>“1000”</td><td>23.04s</td></tr><tr><td>“1001”</td><td>25.6s</td></tr><tr><td>“1010”</td><td>28.16s</td></tr><tr><td>“1011”</td><td>30.72s</td></tr><tr><td>“1100”</td><td>33.28s</td></tr><tr><td>“1101”</td><td>35.84s</td></tr><tr><td>“1110”</td><td>38.4s</td></tr><tr><td>“1111”</td><td>40.96s</td></tr></tbody></table></div><p>以下命令用于禁用eDRX的窄带</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CEDRXS=0,5</span><br></pre></td></tr></table></figure><p>eDRX被0标记，而窄带被5标记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文翻译自twilio网站文章&lt;a href=&quot;[https://www.twilio.com/docs/wireless/nb/nb-iot-power-optimizations-edrx-psm](https://www.twilio.com/docs/wireles
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="3GPP" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/3GPP/"/>
    
      <category term="NB-IoT" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/3GPP/NB-IoT/"/>
    
    
      <category term="3GPP" scheme="http://yoursite.com/tags/3GPP/"/>
    
      <category term="NB-IoT" scheme="http://yoursite.com/tags/NB-IoT/"/>
    
  </entry>
  
  <entry>
    <title>每月见闻201912</title>
    <link href="http://yoursite.com/2019/12/20/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201912/"/>
    <id>http://yoursite.com/2019/12/20/每月见闻201912/</id>
    <published>2019-12-20T05:54:32.000Z</published>
    <updated>2021-08-13T02:24:21.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="CS3210-Linux-insides"><a href="#CS3210-Linux-insides" class="headerlink" title="CS3210-Linux-insides"></a><a href="https://cs3210.cc.gatech.edu/index.html">CS3210-Linux-insides</a></h2><p>美国佐治亚理工学院(Georgia Institute of Technology, GT) CS-3210 课程，其题目是”Design Operating Systems“，设计操作系统。该课程以《Linux Inside》这本书作为教材，这本书gitbook地址为<a href="https://legacy.gitbook.com/book/0xax/linux-insides/details">linux-insides</a>，有人在github上发起了<a href="https://github.com/MintCN/linux-insides-zh/blob/master/README.md">linux-insides-zh</a>翻译项目，这本书的目录如下</p><ul><li><h1 id="Kernel-Boot-Process"><a href="#Kernel-Boot-Process" class="headerlink" title="Kernel Boot Process"></a>Kernel Boot Process</h1></li><li><h1 id="Kernel-initialization-process"><a href="#Kernel-initialization-process" class="headerlink" title="Kernel initialization process"></a>Kernel initialization process</h1></li><li><h1 id="Interrupts-and-Interrupt-Handling"><a href="#Interrupts-and-Interrupt-Handling" class="headerlink" title="Interrupts and Interrupt Handling"></a>Interrupts and Interrupt Handling</h1></li><li><h1 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h1></li><li><h1 id="Timers-and-time-management"><a href="#Timers-and-time-management" class="headerlink" title="Timers and time management"></a>Timers and time management</h1></li><li><h1 id="Synchronization-primitives-in-the-Linux-kernel"><a href="#Synchronization-primitives-in-the-Linux-kernel" class="headerlink" title="Synchronization primitives in the Linux kernel"></a>Synchronization primitives in the Linux kernel</h1></li><li><h1 id="Linux-kernel-memory-management"><a href="#Linux-kernel-memory-management" class="headerlink" title="Linux kernel memory management"></a>Linux kernel memory management</h1></li><li><h1 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h1></li><li><h1 id="Linux-kernel-concepts"><a href="#Linux-kernel-concepts" class="headerlink" title="Linux kernel concepts"></a>Linux kernel concepts</h1></li><li><h1 id="Data-Structures-in-the-Linux-Kernel"><a href="#Data-Structures-in-the-Linux-Kernel" class="headerlink" title="Data Structures in the Linux Kernel"></a>Data Structures in the Linux Kernel</h1></li><li><h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1></li><li><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1></li></ul><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><h2 id="Booting-ARM-Linux-on-MPCore"><a href="#Booting-ARM-Linux-on-MPCore" class="headerlink" title="Booting ARM Linux on MPCore"></a><a href="https://medium.com/@srinivasrao.in/booting-arm-linux-on-mpcore-95db62dabf50">Booting ARM Linux on MPCore</a></h2><p>Medium上一篇讲解多核ARM Linux启动的好文章，对Boot Monitor、U-boot和kernel启动汇编部分都有较为详细的说明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; title=&quot;技术&quot;&gt;&lt;/a&gt;技术&lt;/h1&gt;&lt;h2 id=&quot;CS3210-Linux-insides&quot;&gt;&lt;a href=&quot;#CS3210-Linux-insides&quot; class=&quot;head
      
    
    </summary>
    
      <category term="每月见闻" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>pm-freezing-task</title>
    <link href="http://yoursite.com/2019/12/11/pm-freezing-task/"/>
    <id>http://yoursite.com/2019/12/11/pm-freezing-task/</id>
    <published>2019-12-11T09:57:57.000Z</published>
    <updated>2021-08-13T02:24:21.728Z</updated>
    
    <content type="html"><![CDATA[<p>Linux PM suspend会冻结所有用户空间进程和大部分内核线程，本文分析梳理冻结过程是如何实现的</p><p>参考文档</p><ul><li>kernel document：Document/power/freezing-of-tasks.txt</li><li><a href="http://www.wowotech.net/pm_subsystem/237.html">蜗窝科技-Linux进程冻结技术</a></li></ul><h2 id="为什么要冻结进程"><a href="#为什么要冻结进程" class="headerlink" title="为什么要冻结进程"></a>为什么要冻结进程</h2><p>主要是以下几点原因</p><ul><li>protect fs<br>主要原因是防止文件系统在hibernation过程中损坏。目前，kernel还没有检查文件系统的简单方法，因此，如果对磁盘上的文件系统数据或元数据进行了任何修改，kernel就无法将它们恢复到修改之前的状态。同时，每个hibernation镜像都包含一些与文件系统相关的信息，这些信息必须与从镜像恢复系统内存状态后磁盘上数据和元数据的状态一致(否则文件系统将受到严重损坏，通常使它们几乎无法修复)。因此，kernel会冻结那些可能导致磁盘上文件系统的数据和元数据在创建hibernation镜像之后和系统最终关闭之前被修改的任务。其中大多数是用户空间进程，但是如果任何内核线程可能导致这样的事情发生，它们必须是可释放的</li><li>memory<br>为了创建hibernation镜像，kernel需要在设备停用之前free大量内存(接近50%的有效RAM空间)，因为kernel需要用这些内存做swapping out。在镜像的内存被释放之后，kernel不希望任务分配额外的内存，因此通过提前冻结它们来防止。</li><li>protect devices<br>防止用户空间进程和一些内核线程干扰设备的suspend和resume。例如，当kernel suspend设备时，在第二个CPU上运行的用户空间进程可能会很麻烦，如果没有任务冻结，kernel需要一些保护措施，以防止在这种情况下可能发生的竞争情况</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>进程冻结的代码实现主要位于以下文件中</p><ul><li>kernel/kernel/power/suspend.c</li><li>kernel/kernel/power/process.c</li><li>kernel/kernel/power/freezer.c</li></ul><p>进程冻结的入口函数为<code>suspend_freeze_processes()</code>，调用链为<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enter_state --&gt;</span><br><span class="line">  suspend_prepare --&gt;</span><br><span class="line">    suspend_freeze_processes</span><br></pre></td></tr></table></figure></p><p>函数<code>suspend_freeze_processes()</code>代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">suspend_freeze_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">error = freeze_processes();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * freeze_processes() automatically thaws every task if freezing</span></span><br><span class="line"><span class="comment"> * fails. So we need not do anything extra upon error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">error = freeze_kernel_threads();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * freeze_kernel_threads() thaws only kernel threads upon freezing</span></span><br><span class="line"><span class="comment"> * failure. So we have to thaw the userspace tasks ourselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">thaw_processes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先会调用<code>freeze_processes()</code>来冻结进程，注释说的很清楚，如果失败会在函数内自动解冻进程；然后会调用<code>freeze_kernel_threads()</code>函数来冻结内核线程，如果失败会在函数内部自动解冻内核线程，因此如果失败还需要再调用<code>thaw_processes()</code>解冻进程</p><h3 id="freeze-processes"><a href="#freeze-processes" class="headerlink" title="freeze_processes"></a>freeze_processes</h3><p><code>freeze_processes()</code>函数代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeze_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">error = __usermodehelper_disable(UMH_FREEZING);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure this task doesn&#x27;t get frozen */</span></span><br><span class="line">current-&gt;flags |= PF_SUSPEND_TASK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pm_freezing)</span><br><span class="line">atomic_inc(&amp;system_freezing_cnt);</span><br><span class="line"></span><br><span class="line">pm_wakeup_clear();</span><br><span class="line">pr_info(<span class="string">&quot;Freezing user space processes ... &quot;</span>);</span><br><span class="line">pm_freezing = <span class="literal">true</span>;</span><br><span class="line">error = try_to_freeze_tasks(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">__usermodehelper_set_disable_depth(UMH_DISABLED);</span><br><span class="line">pr_cont(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">pr_cont(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">BUG_ON(in_atomic());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now that the whole userspace is frozen we need to disbale</span></span><br><span class="line"><span class="comment"> * the OOM killer to disallow any further interference with</span></span><br><span class="line"><span class="comment"> * killable tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; !oom_killer_disable())</span><br><span class="line">error = -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">thaw_processes();</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先禁用了usermodehelper，将当前task标志位<code>PF_SUSPEND_TASK</code>置位，将当前task设置为执行suspend的task，以确保该task不会被冻结。因此冻结进程的实际代码位于函数<code>try_to_freeze_tasks()</code>中</p><p><code>try_to_freeze_tasks()</code>函数代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_freeze_tasks</span><span class="params">(<span class="keyword">bool</span> user_only)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_time;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> todo;</span><br><span class="line"><span class="keyword">bool</span> wq_busy = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">u64 elapsed_msecs64;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> elapsed_msecs;</span><br><span class="line"><span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> sleep_usecs = USEC_PER_MSEC;</span><br><span class="line"></span><br><span class="line">do_gettimeofday(&amp;start);</span><br><span class="line"></span><br><span class="line">end_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!user_only)</span><br><span class="line">freeze_workqueues_begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">todo = <span class="number">0</span>;</span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p == current || !freeze_task(p))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!freezer_should_skip(p))</span><br><span class="line">todo++;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!user_only) &#123;</span><br><span class="line">wq_busy = freeze_workqueues_busy();</span><br><span class="line">todo += wq_busy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!todo || time_after(jiffies, end_time))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pm_wakeup_pending()) &#123;</span><br><span class="line">wakeup = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to retry, but first give the freezing tasks some</span></span><br><span class="line"><span class="comment"> * time to enter the refrigerator.  Start with an initial</span></span><br><span class="line"><span class="comment"> * 1 ms sleep followed by exponential backoff until 8 ms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">usleep_range(sleep_usecs / <span class="number">2</span>, sleep_usecs);</span><br><span class="line"><span class="keyword">if</span> (sleep_usecs &lt; <span class="number">8</span> * USEC_PER_MSEC)</span><br><span class="line">sleep_usecs *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_gettimeofday(&amp;end);</span><br><span class="line">elapsed_msecs64 = timeval_to_ns(&amp;end) - timeval_to_ns(&amp;start);</span><br><span class="line">do_div(elapsed_msecs64, NSEC_PER_MSEC);</span><br><span class="line">elapsed_msecs = elapsed_msecs64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (todo) &#123;</span><br><span class="line">pr_cont(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">pr_err(<span class="string">&quot;Freezing of tasks %s after %d.%03d seconds &quot;</span></span><br><span class="line">       <span class="string">&quot;(%d tasks refusing to freeze, wq_busy=%d):\n&quot;</span>,</span><br><span class="line">       wakeup ? <span class="string">&quot;aborted&quot;</span> : <span class="string">&quot;failed&quot;</span>,</span><br><span class="line">       elapsed_msecs / <span class="number">1000</span>, elapsed_msecs % <span class="number">1000</span>,</span><br><span class="line">       todo - wq_busy, wq_busy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wakeup) &#123;</span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p != current &amp;&amp; !freezer_should_skip(p)</span><br><span class="line">    &amp;&amp; freezing(p) &amp;&amp; !frozen(p))</span><br><span class="line">sched_show_task(p);</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pr_cont(<span class="string">&quot;(elapsed %d.%03d seconds) &quot;</span>, elapsed_msecs / <span class="number">1000</span>,</span><br><span class="line">elapsed_msecs % <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> todo ? -EBUSY : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先设置了一个<code>end_time</code>，该操作的作用是确保冻结进程的执行在规定时间内完成，这个时间由全局变量<code>freeze_timeout_msecs</code>控制，它有个初始值，并且可由/sys/power/pm_freeze_timeout节点进行设置</p><p>冻结的对象是内核中可以被调度执行的实体，包括用户进程、内核线程和work_queue，<code>freeze_workqueues_begin()</code>函数的作用就是冻结了work_queue。然后在一个循环体内遍历<code>tasklist_lock</code>线程链表，对每个task执行<code>freeze_task()</code>来冻结，循环会通过<code>todo</code>记录某些仍然需要再操作的task，在循环退出后再做一些操作</p><h4 id="冻结标志"><a href="#冻结标志" class="headerlink" title="冻结标志"></a>冻结标志</h4><p>这里需要对task的冻结标志位进行介绍，一共有3个和冻结相关标志位</p><ul><li>PF_NOFREEZE：表明该task不能被冻结</li><li>PF_FROZEN：表明该task已经被冻结</li><li>PF_FREEZER_SKIP：这个标志是辅助用的</li></ul><p>未被标记为<code>PF_NOFREEZE</code>的task(所有用户空间的进程和部分内核线程)将被视为‘freezable’可冻结的</p><p>这里有几个函数和冻结标志紧密相关</p><ul><li>freezing：判断task是否正在冻结中</li><li>frozen：判断task是否已经被冻结</li><li>freezer_should_skip：判断task是否需要跳过冻结</li><li>freeze_task：冻结task</li></ul><p>循环体中主要执行的函数是<code>freeze_task()</code>，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * freeze_task - send a freeze request to given task</span></span><br><span class="line"><span class="comment"> * @p: task to send the request to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @p is freezing, the freeze request is sent either by sending a fake</span></span><br><span class="line"><span class="comment"> * signal (if it&#x27;s not a kernel thread) or waking it up (if it&#x27;s a kernel</span></span><br><span class="line"><span class="comment"> * thread).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * %false, if @p is not freezing or already frozen; %true, otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freeze_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This check can race with freezer_do_not_count, but worst case that</span></span><br><span class="line"><span class="comment"> * will result in an extra wakeup being sent to the task.  It does not</span></span><br><span class="line"><span class="comment"> * race with freezer_count(), the barriers in freezer_count() and</span></span><br><span class="line"><span class="comment"> * freezer_should_skip() ensure that either freezer_count() sees</span></span><br><span class="line"><span class="comment"> * freezing == true in try_to_freeze() and freezes, or</span></span><br><span class="line"><span class="comment"> * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task</span></span><br><span class="line"><span class="comment"> * normally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (freezer_should_skip(p))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">if</span> (!freezing(p) || frozen(p)) &#123;</span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">fake_signal_wake_up(p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">wake_up_state(p, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先是进行了几个判断，如果task跳过冻结、正在冻结中、或者是已经冻结，则返回false，循环体的<code>todo</code>不会增加。那么接下来需要处理的就是需要被冻结的task。如果是用户空间进程，则通过<code>fake_signal_wake_up()</code>函数发送一个假信号用来唤醒进程，如果是kernel线程，则调用<code>wake_up_state()</code>来中断唤醒线程。所有可冻结的task必须通过调用<code>try_to_freeze()</code>来响应该唤醒</p><p>对于用户空间进程而言，在其信号处理句柄中会自动调用<code>try_to_freeze()</code>，但是可冻结的内核线程必须在适当的位置显式的调用<code>wait_event_freezable()</code>或者<code>wait_event_freezable_timeout()</code>来间接的调用<code>try_to_freeze()</code>，并作一些安全检查</p><h4 id="try-to-freeze"><a href="#try-to-freeze" class="headerlink" title="try_to_freeze"></a>try_to_freeze</h4><p>该函数定义在include/linux/freeze.h中，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION</span></span><br><span class="line"><span class="comment"> * If try_to_freeze causes a lockdep warning it means the caller may deadlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze_unsafe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">might_sleep();</span><br><span class="line"><span class="keyword">if</span> (likely(!freezing(current)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> __refrigerator(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_NOFREEZE))</span><br><span class="line">debug_check_no_locks_held();</span><br><span class="line"><span class="keyword">return</span> try_to_freeze_unsafe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终会调用<code>__refrigerator()</code>函数，代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Refrigerator is place where frozen processes are stored :-). */</span></span><br><span class="line"><span class="keyword">bool</span> __refrigerator(<span class="keyword">bool</span> check_kthr_stop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Hmm, should we be allowed to suspend when there are realtime</span></span><br><span class="line"><span class="comment">   processes around? */</span></span><br><span class="line"><span class="keyword">bool</span> was_frozen = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">long</span> save = current-&gt;state;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;%s entered refrigerator\n&quot;</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;freezer_lock);</span><br><span class="line">current-&gt;flags |= PF_FROZEN;</span><br><span class="line"><span class="keyword">if</span> (!freezing(current) ||</span><br><span class="line">    (check_kthr_stop &amp;&amp; kthread_should_stop()))</span><br><span class="line">current-&gt;flags &amp;= ~PF_FROZEN;</span><br><span class="line">spin_unlock_irq(&amp;freezer_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_FROZEN))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">was_frozen = <span class="literal">true</span>;</span><br><span class="line">schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;%s left refrigerator\n&quot;</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Restore saved task state before returning.  The mb&#x27;d version</span></span><br><span class="line"><span class="comment"> * needs to be used; otherwise, it might silently break</span></span><br><span class="line"><span class="comment"> * synchronization which depends on ordered task state change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_current_state(save);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> was_frozen;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__refrigerator);</span><br></pre></td></tr></table></figure></p><p>设置task不可被中断，然后将task标志<code>PF_FROZEN</code>置位，表明task已经被冻结，本质上是在一个死循环中，只有当标志位<code>PF_FROZEN</code>被清除后才会退出</p><h3 id="freeze-kernel-threads"><a href="#freeze-kernel-threads" class="headerlink" title="freeze_kernel_threads"></a>freeze_kernel_threads</h3><p>函数<code>freeze_kernel_threads()</code>内部实际上还是通过调用<code>try_to_freeze_tasks()</code>来处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * freeze_kernel_threads - Make freezable kernel threads go to the refrigerator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, returns 0.  On failure, -errno and only the kernel threads are</span></span><br><span class="line"><span class="comment"> * thawed, so as to give a chance to the caller to do additional cleanups</span></span><br><span class="line"><span class="comment"> * (if any) before thawing the userspace tasks. So, it is the responsibility</span></span><br><span class="line"><span class="comment"> * of the caller to thaw the userspace tasks, when the time is right.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeze_kernel_threads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;Freezing remaining freezable tasks ... &quot;</span>);</span><br><span class="line"></span><br><span class="line">pm_nosig_freezing = <span class="literal">true</span>;</span><br><span class="line">error = try_to_freeze_tasks(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">pr_cont(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">pr_cont(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">BUG_ON(in_atomic());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line">thaw_kernel_threads();</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="thaw-processes"><a href="#thaw-processes" class="headerlink" title="thaw_processes"></a>thaw_processes</h3><p><code>thaw_processes()</code>代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thaw_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> current;</span><br><span class="line"></span><br><span class="line">trace_suspend_resume(TPS(<span class="string">&quot;thaw_processes&quot;</span>), <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (pm_freezing)</span><br><span class="line">atomic_dec(&amp;system_freezing_cnt);</span><br><span class="line">pm_freezing = <span class="literal">false</span>;</span><br><span class="line">pm_nosig_freezing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">oom_killer_enable();</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;Restarting tasks ... &quot;</span>);</span><br><span class="line"></span><br><span class="line">__usermodehelper_set_disable_depth(UMH_FREEZING);</span><br><span class="line">thaw_workqueues();</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">for_each_process_thread(g, p) &#123;</span><br><span class="line"><span class="comment">/* No other threads should have PF_SUSPEND_TASK set */</span></span><br><span class="line">WARN_ON((p != curr) &amp;&amp; (p-&gt;flags &amp; PF_SUSPEND_TASK));</span><br><span class="line">__thaw_task(p);</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">WARN_ON(!(curr-&gt;flags &amp; PF_SUSPEND_TASK));</span><br><span class="line">curr-&gt;flags &amp;= ~PF_SUSPEND_TASK;</span><br><span class="line"></span><br><span class="line">usermodehelper_enable();</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line">pr_cont(<span class="string">&quot;done.\n&quot;</span>);</span><br><span class="line">trace_suspend_resume(TPS(<span class="string">&quot;thaw_processes&quot;</span>), <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先启动了<code>OOM killer</code>线程，然后禁用usermodehelper，<code>thaw_workqueues()</code>函数解冻了work_queue。遍历<code>tasklist_lock</code>，对每个task调用<code>__thaw_task()</code>函数</p><p><code>__thaw_task()</code>函数代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __thaw_task(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;freezer_lock, flags);</span><br><span class="line"><span class="keyword">if</span> (frozen(p))</span><br><span class="line">wake_up_process(p);</span><br><span class="line">spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>wake_up_process()</code>的处理涉及到Linux进程管理相关内容，暂不做分析</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于休眠需要保护文件系统和设备等资源以防止用户空间和部分内核空间线程的操作，因此在休眠的第一步kernel冻结了所有用户空间进程和部分内核线程</p><p>冻结task的实质是通过<code>PF_FROZEN</code>标志位和信号来控制task进入/退出一个死循环，达到户空间进程和部分内核线程不进行任何实际操作的目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux PM suspend会冻结所有用户空间进程和大部分内核线程，本文分析梳理冻结过程是如何实现的&lt;/p&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kernel document：Document/power/freezing-of-tasks.txt&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Linux Kernel" scheme="http://yoursite.com/categories/Linux-Kernel/"/>
    
      <category term="电源管理" scheme="http://yoursite.com/categories/Linux-Kernel/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
      <category term="PM" scheme="http://yoursite.com/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>pm-debugging</title>
    <link href="http://yoursite.com/2019/12/05/pm-debugging/"/>
    <id>http://yoursite.com/2019/12/05/pm-debugging/</id>
    <published>2019-12-05T05:53:05.000Z</published>
    <updated>2021-08-13T02:24:21.728Z</updated>
    
    <content type="html"><![CDATA[<p>电源管理的调试对于开发需要Suspend to Disk(STD)或者Suspend to Ram(STR)的系统来说，非常必要和重要</p><p>由于系统在suspend/resume过程会进行非常复杂的一系列操作，如禁用console、冻结进程等，会导致常规的调试方法难以排查定位问题和跟踪流程</p><p>Linux的电源管理框架提供了专门的调试方法，用于方便开发者调试不同类型、不同深度的suspend/resume，本文介绍一些常用的工具和使用方法，并在实际环境中验证</p><p><strong>参考文档</strong></p><ul><li>kernel document : /Document/power/basic-pm-debugging.txt</li><li>kernel document : /Document/power/drivers-testing.txt</li><li>kernel document : /Document/power/s2ram.txt</li><li><a href="https://wiki.ubuntu.com/DebuggingKernelSuspend">ubuntu wiki - DebuggingKernelSuspend</a></li><li><a href="https://unix.stackexchange.com/questions/28097/how-to-debug-a-suspend-problem">stackexchange - How to debug a suspend problem?</a></li><li><a href="https://01.org/zh/blogs/rzhang/2015/best-practice-debug-linux-suspend/hibernate-issues?langredirect=1">inter open source blog - BEST PRACTICE TO DEBUG LINUX* SUSPEND/HIBERNATE ISSUES</a></li></ul><p><strong>测试环境</strong><br>本测试在ubuntu上使用qemu创建arm虚拟机环境，linux源码版本4.0，编写内核模块qksleep_test用于调试，关于qemu调试arm kernel参见文章<a href="sadadasd">Qemu+gdb调试内核</a></p><ul><li>宿主机 : 18.04.1-Ubuntu x86_64</li><li>虚拟机 : qemu-system-arm vexpress-a9<ul><li>kernel : linux_4.0</li></ul></li></ul><h2 id="qksleep-test"><a href="#qksleep-test" class="headerlink" title="qksleep_test"></a>qksleep_test</h2><p>源码下载</p><ul><li><a href="/download/pm-debugging/pm-debugging.rar">pm-debugging.rar</a><br>qksleep_test以platform_driver方式向系统注册驱动，在其<code>pm</code>操作域上挂接私有的suspend/resume函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qksleep_suspend</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">qksleep_dev_t</span> *qkdev = get_qkdev();</span><br><span class="line">qksleep_dev_priv *priv = &amp;qkdev-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">qksleep_debug(<span class="string">&quot;qksleep suspend in&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;suspend_wakeup_timeout &gt; <span class="number">0</span>)</span><br><span class="line">schedule_delayed_work(&amp;priv-&gt;suspend_wakeup, msecs_to_jiffies(priv-&gt;suspend_wakeup_timeout));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;suspend_errlock)</span><br><span class="line">qksleep_lockerr(priv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;suspend_timeout)</span><br><span class="line">qksleep_vsleep(priv, priv-&gt;suspend_timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> priv-&gt;suspend_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qksleep_resume</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">qksleep_dev_t</span> *qkdev = get_qkdev();</span><br><span class="line">qksleep_dev_priv *priv = &amp;qkdev-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">qksleep_debug(<span class="string">&quot;qksleep resume in&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;resume_errlock)</span><br><span class="line">qksleep_lockerr(priv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;resume_timeout)</span><br><span class="line">qksleep_vsleep(priv, priv-&gt;resume_timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> priv-&gt;resume_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> <span class="title">qk_sleep_pm</span> =</span> &#123;</span><br><span class="line">.suspend = qksleep_suspend,</span><br><span class="line">.resume = qksleep_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">qksleep_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = QK_SLEEP_DRV_NAME,</span><br><span class="line">.pm = &amp;qk_sleep_pm,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = qksleep_probe,</span><br><span class="line">.remove = qksleep_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>在platform_driver的probe函数中，向系统注册了7个sysfs节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">qksleep_attr</span>[] =</span> &#123;</span><br><span class="line">&amp;dev_attr_suspend_wakeup_timeout.attr,</span><br><span class="line">&amp;dev_attr_suspend_ret.attr,</span><br><span class="line">&amp;dev_attr_suspend_timeout.attr,</span><br><span class="line">&amp;dev_attr_suspend_errlock.attr,</span><br><span class="line">&amp;dev_attr_resume_ret.attr,</span><br><span class="line">&amp;dev_attr_resume_timeout.attr,</span><br><span class="line">&amp;dev_attr_resume_errlock.attr,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>suspend_wakeup_timeout：suspend后多久唤醒系统</li><li>suspend_ret：suspend函数返回值</li><li>suspend_timeout：suspend函数中模拟一个超时时间</li><li>suspend_errlock：suspend函数中模拟一个错误的锁操作</li><li>resume_xxx：同上</li></ul><p>编译kernel，并用quem启动后，在/sys/devices/platform/qksleep路径下生成了该设备的所有sysfs节点<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ # cd /sys/devices/platform/qksleep/</span><br><span class="line">/sys/devices/platform/qksleep # ls</span><br><span class="line">driver                  resume_ret              suspend_timeout</span><br><span class="line">driver_override         resume_timeout          suspend_wakeup_timeout</span><br><span class="line">modalias                subsystem               uevent</span><br><span class="line">power                   suspend_errlock</span><br><span class="line">resume_errlock          suspend_ret</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p><p>查看suspend/resume操作默认值<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # cat  suspend_*</span><br><span class="line">suspend errlock:0</span><br><span class="line">suspend ret:0</span><br><span class="line">suspend timeout:0(ms)</span><br><span class="line">suspend wakeup timeout:10000(ms)</span><br><span class="line">/sys/devices/platform/qksleep # </span><br><span class="line">/sys/devices/platform/qksleep # cat resume_*</span><br><span class="line">resume errlock:0</span><br><span class="line">resume ret:0</span><br><span class="line">resume timeout:0(ms)</span><br><span class="line">/sys/devices/platform/qksleep #</span><br></pre></td></tr></table></figure></p><p>执行以下命令可控制qksleep设备suspend 2秒后唤醒<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 20000 &gt; suspend_wakeup_timeout</span><br></pre></td></tr></table></figure></p><p>执行以下命令可控制qksleep设备suspend函数返回错误值-1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -1 &gt; suspend_ret</span><br></pre></td></tr></table></figure></p><p>执行以下命令可控制qksleep设备在suspend函数中模拟一个死锁<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; suspend_errlock</span><br></pre></td></tr></table></figure></p><p>执行以下命令可控制qksleep设备在suspend函数中模拟一个2秒的超时<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2000 &gt; suspend_timeout</span><br></pre></td></tr></table></figure></p><p>resume同suspend</p><p>操作/sys/power/state节点，手动进入休眠状态，qksleep默认会在10秒后唤醒系统<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[  615.345438] PM: Syncing filesystems ... done.</span><br><span class="line">[  615.346378] PM: Preparing system for mem sleep</span><br><span class="line">[  615.374765] Freezing user space processes ... (elapsed 0.011 seconds) done.</span><br><span class="line">[  615.387040] Freezing remaining freezable tasks ... (elapsed 0.008 seconds) done.</span><br><span class="line">[  615.396303] PM: Entering mem sleep</span><br><span class="line">[  615.396496] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[  615.401243] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[  615.401248] PM: suspend of devices complete after 3.752 msecs</span><br><span class="line">[  615.401269] PM: suspend devices took 0.000 seconds</span><br><span class="line">[  615.402693] PM: late suspend of devices complete after 1.392 msecs</span><br><span class="line">[  615.404024] PM: noirq suspend of devices complete after 1.300 msecs</span><br><span class="line">[  615.404050] PM: suspend-to-idle</span><br><span class="line">[  625.426911] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[  625.426961] PM: resume from suspend-to-idle</span><br><span class="line">[  625.430512] PM: noirq resume of devices complete after 3.254 msecs</span><br><span class="line">[  625.432153] PM: early resume of devices complete after 1.157 msecs</span><br><span class="line">[  625.435256] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[  625.435260] PM: resume of devices complete after 3.047 msecs</span><br><span class="line">[  625.436082] PM: resume devices took 0.010 seconds</span><br><span class="line">[  625.439150] PM: Finishing wakeup.</span><br><span class="line">[  625.439304] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p><p>后续的调试验证将在qksleep设备节点的基础上来做</p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>kernel的电源管理框架在“/sys/power”目录下创建了一系列供用户空间操作的sysfs节点，kernel文档“/Document/power/basic-pm-debugging.txt”中详细说明了如何将<code>pm_test</code>节点用于调试suspend/resume过程。“/Document/power/s2ram.txt”文档介绍了使用“s2ram”工具来调试和排查suspend/resume问题。stackexchange问题“How to debug a suspend problem?”的回答中介绍了“pm_utils”工具。英特尔开源社区的文章“BEST PRACTICE TO DEBUG LINUX* SUSPEND/HIBERNATE ISSUES”中系统的介绍了系统级的调试方法和遇到问题的排查步骤</p><p>总的来说，Linux电源管理的调试工具主要分为3大类：系统级调试工具(system debug tools)、PM专用调试方法(pm debug tools)和应用层开发的工具(application tools)</p><ul><li>system debug tools<br>主要是一些kernel启动参数的控制，用于增加更多打印信息<ul><li>initcall_debug</li><li>no_console_suspend</li><li>ignore_loglevel</li></ul></li><li>pm debug tools<br>PM创建的sysfs节点<ul><li>pm_test</li><li>pm_trace</li><li>pm_async</li></ul></li><li>applaction tools<br>结合PM sysfs编写的PM调试app<ul><li>pm_utils</li><li>s2ram</li><li>analyze_suspend.py</li></ul></li></ul><h3 id="initcall-debug"><a href="#initcall-debug" class="headerlink" title="initcall_debug"></a>initcall_debug</h3><p>通过将<code>initcall_debug</code>作为启动参数传入kernel，可以跟踪kernel的initcalls和驱动在boot、suspend和resume时的调用情况。通过这种方式可以追踪由于特定组件或驱动引起的suspend/resume问题</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在qksleep的resume过程设置2秒的超时<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 2000 &gt; resume_timeout </span><br></pre></td></tr></table></figure></p><p>手动进入休眠，系统唤醒后可看到suspend过程耗时0.010秒，resume操作耗时2.020秒<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[   46.630363] PM: Syncing filesystems ... done.</span><br><span class="line">[   46.632115] PM: Preparing system for mem sleep</span><br><span class="line">[   46.695899] Freezing user space processes ... (elapsed 0.035 seconds) done.</span><br><span class="line">[   46.732478] Freezing remaining freezable tasks ... (elapsed 0.017 seconds) done.</span><br><span class="line">[   46.751186] PM: Entering mem sleep</span><br><span class="line">[   46.751560] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[   46.764225] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[   46.764237] PM: suspend of devices complete after 10.832 msecs</span><br><span class="line">[   46.764522] PM: suspend devices took 0.010 seconds</span><br><span class="line">[   46.766748] PM: late suspend of devices complete after 1.970 msecs</span><br><span class="line">[   46.769322] PM: noirq suspend of devices complete after 2.371 msecs</span><br><span class="line">[   46.769689] PM: suspend-to-idle</span><br><span class="line">[   56.771522] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[   56.771526] PM: resume from suspend-to-idle</span><br><span class="line">[   56.773263] PM: noirq resume of devices complete after 1.499 msecs</span><br><span class="line">[   56.775273] PM: early resume of devices complete after 1.512 msecs</span><br><span class="line">[   58.788915] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[   58.788927] PM: resume of devices complete after 2013.258 msecs</span><br><span class="line">[   58.792183] PM: resume devices took 2.020 seconds</span><br><span class="line">[   58.798512] PM: Finishing wakeup.</span><br><span class="line">[   58.799016] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p><p>虽然能看出来系统resume过程耗时明显过长，但是无法知道是在哪里耗时过长，尝试用<code>initcall_debug</code>来查看。系统启动时传入参数<code>initcall_debug</code>，开启该参数后，启动虚拟机，会打印所有initcall信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Console: colour dummy device 80x30</span><br><span class="line">[    0.017370] kmemleak: Kernel memory leak detector disabled</span><br><span class="line">[    0.024047] Calibrating delay loop... 915.86 BogoMIPS (lpj=4579328)</span><br><span class="line">[    0.097768] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.101635] Mount-cache hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class="line">[    0.101702] Mountpoint-cache hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class="line">[    0.133941] CPU: Testing write buffer coherency: ok</span><br><span class="line">[    0.152375] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000</span><br><span class="line">[    0.153210] calling  trace_init_flags_sys_enter+0x0/0x28 @ 1</span><br><span class="line">[    0.153285] initcall trace_init_flags_sys_enter+0x0/0x28 returned 0 after 0 usecs</span><br><span class="line">[    0.153483] calling  trace_init_flags_sys_exit+0x0/0x28 @ 1</span><br><span class="line">[    0.153525] initcall trace_init_flags_sys_exit+0x0/0x28 returned 0 after 0 usecs</span><br><span class="line">[    0.153643] calling  cpu_suspend_alloc_sp+0x0/0x1ec @ 1</span><br><span class="line">[    0.153865] initcall cpu_suspend_alloc_sp+0x0/0x1ec returned 0 after 0 usecs</span><br><span class="line">[    0.153980] calling  init_static_idmap+0x0/0x74 @ 1</span><br><span class="line">[    0.154138] Setting up static identity map for 0x60b26600 - 0x60b26658</span><br><span class="line">[    0.154337] initcall init_static_idmap+0x0/0x74 returned 0 after 0 usecs</span><br><span class="line">[    0.154453] calling  dcscb_init+0x0/0x1a8 @ 1</span><br><span class="line">[    0.154738] initcall dcscb_init+0x0/0x1a8 returned -19 after 0 usecs</span><br><span class="line">[    0.154848] calling  tc2_pm_init+0x0/0x250 @ 1</span><br><span class="line">[    0.155097] initcall tc2_pm_init+0x0/0x250 returned -19 after 0 usecs</span><br><span class="line">[    0.155207] calling  spawn_ksoftirqd+0x0/0x60 @ 1</span><br><span class="line">[    0.159450] initcall spawn_ksoftirqd+0x0/0x60 returned 0 after 9765 usecs</span><br><span class="line">[    0.159624] calling  init_workqueues+0x0/0x800 @ 1</span><br><span class="line">[    0.170386] initcall init_workqueues+0x0/0x800 returned 0 after 9765 usecs</span><br><span class="line">[    0.170520] calling  migration_init+0x0/0xa4 @ 1</span><br><span class="line">[    0.170714] initcall migration_init+0x0/0xa4 returned 0 after 0 usecs</span><br><span class="line">[    0.170830] calling  check_cpu_stall_init+0x0/0x24 @ 1</span><br><span class="line">[    0.170876] initcall check_cpu_stall_init+0x0/0x24 returned 0 after 0 usecs</span><br><span class="line">[    0.170985] calling  rcu_spawn_gp_kthread+0x0/0x1f0 @ 1</span><br><span class="line">[    0.172303] initcall rcu_spawn_gp_kthread+0x0/0x1f0 returned 0 after 0 usecs</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>设置resume超时2秒，手动进入休眠<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 2000 &gt; resume_timeout </span><br><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[   30.075565] PM: Syncing filesystems ... done.</span><br><span class="line">[   30.077755] PM: Preparing system for mem sleep</span><br><span class="line">[   30.128189] Freezing user space processes ... (elapsed 0.019 seconds) done.</span><br><span class="line">[   30.149985] Freezing remaining freezable tasks ... (elapsed 0.007 seconds) done.</span><br><span class="line">[   30.158478] PM: Entering mem sleep</span><br><span class="line">[   30.158851] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[   30.161310] calling  input2+ @ 768, parent: serio1</span><br><span class="line">[   30.163481] call input2+ returned 0 after 2011 usecs</span><br><span class="line">[   30.163599] calling  oprofile-perf.0+ @ 768, parent: platform</span><br><span class="line">[   30.163768] call oprofile-perf.0+ returned 0 after 144 usecs</span><br><span class="line">...</span><br><span class="line">[   30.168789] calling  qksleep+ @ 768, parent: platform</span><br><span class="line">[   30.169022] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[   30.169027] call qksleep+ returned 0 after 202 usecs</span><br><span class="line">[   30.169428] ...</span><br><span class="line">[   30.175275] PM: suspend of devices complete after 14.735 msecs</span><br><span class="line">[   30.175416] PM: suspend devices took 0.010 seconds</span><br><span class="line">[   30.178217] PM: late suspend of devices complete after 2.592 msecs</span><br><span class="line">[   30.180898] PM: noirq suspend of devices complete after 2.424 msecs</span><br><span class="line">[   30.181213] PM: suspend-to-idle</span><br><span class="line">[   40.260326] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[   40.260340] PM: resume from suspend-to-idle</span><br><span class="line">[   40.263683] PM: noirq resume of devices complete after 2.594 msecs</span><br><span class="line">[   40.265601] PM: early resume of devices complete after 1.461 msecs</span><br><span class="line">[   40.266288] calling  reg-dummy+ @ 768, parent: platform</span><br><span class="line">[   40.266395] call reg-dummy+ returned 0 after 84 usecs</span><br><span class="line">[   40.266438] calling  10000000.sysreg+ @ 768, parent: platform</span><br><span class="line">[   40.266455] call 10000000.sysreg+ returned 0 after 1 usecs</span><br><span class="line">[   40.266487] calling  syscon.0.auto+ @ 768, parent: 10000000.sysreg</span><br><span class="line">...</span><br><span class="line">[   40.271348] calling  qksleep+ @ 768, parent: platform</span><br><span class="line">[   42.269188] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[   42.269209] call qksleep+ returned 0 after 1950845 usecs</span><br><span class="line">...</span><br><span class="line">[   42.282800] PM: resume of devices complete after 2016.935 msecs</span><br><span class="line">[   42.286160] PM: resume devices took 2.020 seconds</span><br><span class="line">[   42.389269] PM: Finishing wakeup.</span><br><span class="line">[   42.390769] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>明显可以看出来在qksleep设备的resume过程耗时1950845微秒<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[   42.269209] call qksleep+ returned 0 after 1950845 usecs</span><br></pre></td></tr></table></figure></p><h3 id="no-console-suspend"><a href="#no-console-suspend" class="headerlink" title="no_console_suspend"></a>no_console_suspend</h3><p>默认的kernel休眠过程中会禁用console，因此suspend的任何打印只有在系统唤醒以后才能看到，对于suspend这部分的执行过程，kernel是不会输出的。而开启<code>no_console_suspend</code>选项，可以让kernel进入suspend的过程，仍然输出打印</p><p>no_console_suspend的控制位于/kernel/power/suspend.c和/kernel/printk.c文件中，函数<code>console_suspend_disable</code>用于处理kernel参数no_console_suspend，当设置了该参数后，全局变量<code>console_suspend_enabled</code>的值为false<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">console_suspend_disable</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">console_suspend_enabled = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">&quot;no_console_suspend&quot;</span>, console_suspend_disable);</span><br></pre></td></tr></table></figure></p><p>kernel休眠时会调用<code>suspend_devices_and_enter</code>来执行设备的休眠流程，在其中会调用<code>suspend_console</code>来执行console的suspend<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * suspend_console - suspend the console subsystem</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This disables printk() while we go into suspend states</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suspend_console</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!console_suspend_enabled)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">printk(<span class="string">&quot;Suspending console(s) (use no_console_suspend to debug)\n&quot;</span>);</span><br><span class="line">console_lock();</span><br><span class="line">console_suspended = <span class="number">1</span>;</span><br><span class="line">up_console_sem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果<code>console_suspend_enabled</code>为真，则会执行下面的锁定console操作，此后所有<code>printk</code>的打印信息不会立刻打印到终端；如果为否，直接退出，此后<code>printk</code>函数的打印信息不受影响</p><p><code>no_console_suspend</code>参数比较适用于要跟踪调试kernel代码的情况，且适用于suspend后唤醒不正常的情况</p><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>qksleep的resume设置模拟死锁，并分别在带<code>no_console_suspend</code>参数和不带参数情况下调试</p><p>qksleep的resume设置死锁<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 1 &gt; resume_errlock</span><br></pre></td></tr></table></figure></p><p>不带<code>no_console_suspend</code>情况下，手动进入休眠，打印在“Suspending console(s) (use no_console_suspend to debug)”处停止<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[  160.900817] PM: Syncing filesystems ... done.</span><br><span class="line">[  160.902427] PM: Preparing system for mem sleep</span><br><span class="line">[  160.962134] Freezing user space processes ... (elapsed 0.036 seconds) done.</span><br><span class="line">[  161.000256] Freezing remaining freezable tasks ... (elapsed 0.018 seconds) done.</span><br><span class="line">[  161.020661] PM: Entering mem sleep</span><br><span class="line">[  161.021063] Suspending console(s) (use no_console_suspend to debug)</span><br></pre></td></tr></table></figure></p><p>带<code>no_console_suspend</code>的情况下，手动进入休眠，死锁前的打印都能看到<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[   41.220243] PM: Syncing filesystems ... done.</span><br><span class="line">[   41.222718] PM: Preparing system for mem sleep</span><br><span class="line">[   41.274511] Freezing user space processes ... (elapsed 0.026 seconds) done.</span><br><span class="line">[   41.301588] Freezing remaining freezable tasks ... (elapsed 0.011 seconds) done.</span><br><span class="line">[   41.313599] PM: Entering mem sleep</span><br><span class="line">[   41.322571] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[   41.326340] PM: suspend of devices complete after 11.215 msecs</span><br><span class="line">[   41.326920] PM: suspend devices took 0.010 seconds</span><br><span class="line">[   41.330000] PM: late suspend of devices complete after 2.664 msecs</span><br><span class="line">[   41.332451] PM: noirq suspend of devices complete after 2.001 msecs</span><br><span class="line">[   41.333041] PM: suspend-to-idle</span><br><span class="line">[   51.341481] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[   51.344717] PM: resume from suspend-to-idle</span><br><span class="line">[   51.347243] PM: noirq resume of devices complete after 1.331 msecs</span><br><span class="line">[   51.349427] PM: early resume of devices complete after 1.406 msecs</span><br><span class="line">[   51.352296] [debug] [qksleep_resume:108] qksleep resume in</span><br></pre></td></tr></table></figure></p><h3 id="ignore-loglevel"><a href="#ignore-loglevel" class="headerlink" title="ignore_loglevel"></a>ignore_loglevel</h3><p>开启<code>ignore_loglevel</code>参数后，kernel的打印会无视log级别限制，所有打印都能看到，适用于代码中有很多log级别区分的调试</p><h3 id="pm-test"><a href="#pm-test" class="headerlink" title="pm_test"></a>pm_test</h3><p>该功能依赖kernel配置宏<code>CONFIG_PM_DEBUG</code>，在make menuconfig中配置路径为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> Power management options</span></span><br><span class="line">    [*] Power Management Debug Support</span><br></pre></td></tr></table></figure></p><p>开启此配置后，可通过写入/sys/power/pm_test节点让PM core以测试模式运行，测试模式有5个级别，对应于不同深度的休眠</p><ul><li>freezer：测试进程冻结</li><li>devices：测试进程冻结和设备suspend</li><li>platform：测试进程冻结、设备suspend、平台架构相关suspend</li><li>processors：测试进程冻结、设备suspend、平台架构相关suspend、禁用非引导CPU</li><li>core：测试进程冻结、设备suspend、平台架构相关suspend、禁用非引导CPU、系统suspend</li></ul><p>这5个级别由浅入深，正好对应kernel的休眠流程，kernel在不同地方都设置了测试点<code>suspend_test</code>，当设置了测试模式后，对应级别的测试点会delay 5秒钟然后唤醒系统<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">suspend_test</span><span class="params">(<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_DEBUG</span></span><br><span class="line"><span class="keyword">if</span> (pm_test_level == level) &#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;suspend debug: Waiting for 5 seconds.\n&quot;</span>);</span><br><span class="line">mdelay(<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !CONFIG_PM_DEBUG */</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用这种方法能够在不添加额外唤醒源的情况下测试suspend/resume的完整流程，且能够分阶段进行调试</p><h4 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h4><p>禁用qksleep原本的suspend唤醒<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 0 &gt; suspend_wakeup_timeout</span><br></pre></td></tr></table></figure></p><p>设置PM core调试模式为devices<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo devices &gt; /sys/power/pm_test</span><br></pre></td></tr></table></figure></p><p>设置qksleep设备resume返回错误值-1<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo -1 &gt; resume_ret</span><br></pre></td></tr></table></figure></p><p>手动进入休眠，可看到kernel在5秒后自动唤醒了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[  229.676306] PM: Syncing filesystems ... done.</span><br><span class="line">[  229.676943] PM: Preparing system for mem sleep</span><br><span class="line">[  229.701077] Freezing user space processes ... (elapsed 0.013 seconds) done.</span><br><span class="line">[  229.716141] Freezing remaining freezable tasks ... (elapsed 0.008 seconds) done.</span><br><span class="line">[  229.725218] PM: Entering mem sleep</span><br><span class="line">[  229.725415] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[  229.730420] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[  229.730427] PM: suspend of devices complete after 4.232 msecs</span><br><span class="line">[  229.730448] PM: suspend devices took 0.000 seconds</span><br><span class="line">[  229.730459] suspend debug: Waiting for 5 seconds.</span><br><span class="line">[  234.941168] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[  234.941173] dpm_run_callback(): platform_pm_resume+0x0/0x90 returns -1</span><br><span class="line">[  234.941196] PM: Device qksleep failed to resume: error -1</span><br><span class="line">[  234.942311] PM: resume of devices complete after 2.948 msecs</span><br><span class="line">[  234.943057] PM: resume devices took 0.000 seconds</span><br><span class="line">[  234.945443] PM: Finishing wakeup.</span><br><span class="line">[  234.945607] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p><h3 id="sys-kernel-debug-wakeup-source"><a href="#sys-kernel-debug-wakeup-source" class="headerlink" title="/sys/kernel/debug/wakeup_source"></a>/sys/kernel/debug/wakeup_source</h3><p>该节点列举了当前系统中所有唤醒源以及他们的状况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/sys/kernel/debug # cat wakeup_sources </span><br><span class="line">nameactive_countevent_countwakeup_countexpire_countactive_sincetotal_timemax_timelast_changeprevent_suspend_time</span><br><span class="line">10017000.rtc0        0    0        0        0        0    0    6937    0</span><br><span class="line">qksleep     1        1    0        1        0        196    196    1231539    0</span><br><span class="line">alarmtimer  0        0    0        0        0        0    0    4021    0</span><br><span class="line">autosleep   0        0    0        0        0        0    0    280        0</span><br><span class="line">/sys/kernel/debug # </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>name：唤醒源的驱动名称</li><li>active_count：wake lock 活跃次数</li><li>event_count：唤醒源唤醒事件次数</li><li>wakeup_count：唤醒源强制设备唤醒的次数</li><li>expire_count：唤醒源已到期次数</li><li>active_since：唤醒源处于活跃状态的时间(以jiffies时间为单位)</li><li>total_time：唤醒源活跃的总时间(以jiffies时间为单位)</li><li>max_time：唤醒源持续活跃的最长时间</li><li>last_change：上次更改唤醒源为活跃的时间戳</li><li>prevent_suspend_time：如果没有这个唤醒源，系统进入suspend可以节省多少时间。这对于计算对电池寿命的影响特别有用</li></ul><h4 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h4><p>首次启动系统，查看该节点，所有唤醒源均未唤醒过系统</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /sys/kernel/debug/wakeup_sources </span><br><span class="line">nameactive_countevent_countwakeup_countexpire_countactive_sincetotal_timemax_timelast_changeprevent_suspend_time</span><br><span class="line"><span class="number">10017000</span>.rtc <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">7296</span>    <span class="number">0</span></span><br><span class="line">qksleep      <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">6725</span>    <span class="number">0</span></span><br><span class="line">alarmtimer   <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">4358</span>    <span class="number">0</span></span><br><span class="line">autosleep    <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">300</span>        <span class="number">0</span></span><br><span class="line">/ # </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>手动进入休眠，待系统唤醒后，查看唤醒源</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/ # <span class="built_in">echo</span> mem &gt; /sys/power/state</span><br><span class="line">[  <span class="number">292</span>.<span class="number">573467</span>] PM: Syncing filesystems ... done.</span><br><span class="line">[  <span class="number">292</span>.<span class="number">578116</span>] PM: Preparing system <span class="keyword">for</span> mem sleep</span><br><span class="line">[  <span class="number">292</span>.<span class="number">644122</span>] Freezing user space processes ... (elapsed <span class="number">0</span>.<span class="number">036</span> seconds) done.</span><br><span class="line">[  <span class="number">292</span>.<span class="number">681593</span>] Freezing remaining freezable tasks ... (elapsed <span class="number">0</span>.<span class="number">020</span> seconds) done.</span><br><span class="line">[  <span class="number">292</span>.<span class="number">704121</span>] PM: Entering mem sleep</span><br><span class="line">[  <span class="number">292</span>.<span class="number">722582</span>] [debug] [qksleep_suspend:<span class="number">89</span>] qksleep suspend <span class="keyword">in</span></span><br><span class="line">[  <span class="number">292</span>.<span class="number">726072</span>] PM: suspend of devices complete after <span class="number">13</span>.<span class="number">506</span> msecs</span><br><span class="line">[  <span class="number">292</span>.<span class="number">726509</span>] PM: suspend devices took <span class="number">0</span>.<span class="number">020</span> seconds</span><br><span class="line">[  <span class="number">292</span>.<span class="number">728801</span>] PM: late suspend of devices complete after <span class="number">1</span>.<span class="number">917</span> msecs</span><br><span class="line">[  <span class="number">292</span>.<span class="number">732123</span>] PM: noirq suspend of devices complete after <span class="number">2</span>.<span class="number">847</span> msecs</span><br><span class="line">[  <span class="number">292</span>.<span class="number">733016</span>] PM: suspend-to-idle</span><br><span class="line">[  <span class="number">302</span>.<span class="number">741766</span>] [debug] [qksleep_work_suspend_wakeup:<span class="number">51</span>] qksleep is suspended, wakeup...</span><br><span class="line">[  <span class="number">302</span>.<span class="number">743342</span>] PM: resume from suspend-to-idle</span><br><span class="line">[  <span class="number">302</span>.<span class="number">746235</span>] PM: noirq resume of devices complete after <span class="number">1</span>.<span class="number">903</span> msecs</span><br><span class="line">[  <span class="number">302</span>.<span class="number">748644</span>] PM: early resume of devices complete after <span class="number">1</span>.<span class="number">406</span> msecs</span><br><span class="line">[  <span class="number">302</span>.<span class="number">751825</span>] [debug] [qksleep_resume:<span class="number">108</span>] qksleep resume <span class="keyword">in</span></span><br><span class="line">[  <span class="number">302</span>.<span class="number">754932</span>] PM: resume of devices complete after <span class="number">5</span>.<span class="number">491</span> msecs</span><br><span class="line">[  <span class="number">302</span>.<span class="number">756098</span>] PM: resume devices took <span class="number">0</span>.<span class="number">010</span> seconds</span><br><span class="line">[  <span class="number">302</span>.<span class="number">756843</span>] PM: Finishing wakeup.</span><br><span class="line">[  <span class="number">302</span>.<span class="number">757105</span>] Restarting tasks ... done.</span><br><span class="line">/ # </span><br><span class="line">/ # cat /sys/kernel/debug/wakeup_sources </span><br><span class="line">nameactive_countevent_countwakeup_countexpire_countactive_sincetotal_timemax_timelast_changeprevent_suspend_time</span><br><span class="line"><span class="number">10017000</span>.rtc<span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">7296</span>    <span class="number">0</span></span><br><span class="line">qksleep     <span class="number">1</span>        <span class="number">1</span>    <span class="number">0</span>        <span class="number">1</span>        <span class="number">0</span>        <span class="number">198</span>    <span class="number">198</span>    <span class="number">302929</span>    <span class="number">0</span></span><br><span class="line">alarmtimer  <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">4358</span>    <span class="number">0</span></span><br><span class="line">autosleep   <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">0</span>    <span class="number">300</span>        <span class="number">0</span></span><br><span class="line">/ # </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可看到是qksleep驱动唤醒了系统</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电源管理的调试对于开发需要Suspend to Disk(STD)或者Suspend to Ram(STR)的系统来说，非常必要和重要&lt;/p&gt;
&lt;p&gt;由于系统在suspend/resume过程会进行非常复杂的一系列操作，如禁用console、冻结进程等，会导致常规的调试方法
      
    
    </summary>
    
      <category term="Linux Kernel" scheme="http://yoursite.com/categories/Linux-Kernel/"/>
    
      <category term="电源管理" scheme="http://yoursite.com/categories/Linux-Kernel/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
      <category term="PM" scheme="http://yoursite.com/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>C Program Skill</title>
    <link href="http://yoursite.com/2019/11/27/C-Program-Skill/"/>
    <id>http://yoursite.com/2019/11/27/C-Program-Skill/</id>
    <published>2019-11-27T02:31:08.000Z</published>
    <updated>2021-08-13T02:24:21.627Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一些实际工作中使用到的C语言编程技巧，或者学到的一些好用的用法</p><h2 id="kernel与application通信"><a href="#kernel与application通信" class="headerlink" title="kernel与application通信"></a>kernel与application通信</h2><h3 id="proc文件系统-amp-mmap"><a href="#proc文件系统-amp-mmap" class="headerlink" title="proc文件系统&amp;mmap"></a>proc文件系统&amp;mmap</h3><p>kernel和application通信方式有很多，但是当数据量较大时，常用的<code>ioctl</code>、<code>netlink</code>方式并不适合，<code>mmap</code>较为适用。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于应用层程序而言，系统调用<code>mmap()</code>可以将一个文件映射到内存空间，对该文件的读写就是对该块内存的读写。对于内核空间而言，proc文件系统的文件操作集<code>file_operations</code>支持<code>mmap</code>方法，在文件proc方法的具体实现中，可以将内存映射到应用层调用<code>mmap()</code>的虚拟地址上，从而实现应用层和内核空间通过proc文件关联同一块内存</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>内核空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_PROCFILE    <span class="meta-string">&quot;mmap_test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINUX_PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_MEM_SIZE  (LINUX_PAGE_SIZE * 8)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mmap_mem = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(vma-&gt;vm_end - vma-&gt;vm_start); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MMAP_MEM_SIZE) &#123;  </span><br><span class="line">        ret = -EINVAL;  </span><br><span class="line">        <span class="keyword">goto</span> err;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* map mem block to process&#x27;s address space */</span></span><br><span class="line">    page = virt_to_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>)mmap_mem + (vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT));</span><br><span class="line">    ret = remap_pfn_range(vma, </span><br><span class="line">                          vma-&gt;vm_start, </span><br><span class="line">                          page_to_pfn(page), </span><br><span class="line">                          size, </span><br><span class="line">                          vma-&gt;vm_page_prot);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* your operation */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_fops</span> =</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    .owner = THIS_MODULE,  </span><br><span class="line">    .mmap = proc_mmap,  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_mmap_create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* create mem block */</span></span><br><span class="line">    mmap_mem = kmalloc(MMAP_MEM_SIZE, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!mmap_mem) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kmalloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* your operation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create procfile */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_file</span> =</span> </span><br><span class="line">        proc_create(MMAP_PROCFILE, <span class="number">0x0644</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mmap_read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *mmap_mem = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> mmap_file[<span class="number">64</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(mmap_file, <span class="string">&quot;/proc/%s&quot;</span>, MMAP_PROCFILE)</span><br><span class="line">    fd = open(mmap_file, O_RDWR|O_NDELAY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;open %s error&quot;</span>, mmap_file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do mapping */</span></span><br><span class="line">    mmap_mem = (<span class="keyword">char</span> *)mmap(<span class="number">0</span>, </span><br><span class="line">                            MMAP_MEM_SIZE, </span><br><span class="line">                            PROT_READ | PROT_WRITE, </span><br><span class="line">                            MAP_SHARED, </span><br><span class="line">                            fd, </span><br><span class="line">                            <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mmap_mem) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* your operation */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (mmap_mem)</span><br><span class="line">        munmap(mmap_mem, MMAP_MEM_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; <span class="number">0</span>)</span><br><span class="line">        close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需注意数据同步问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录一些实际工作中使用到的C语言编程技巧，或者学到的一些好用的用法&lt;/p&gt;
&lt;h2 id=&quot;kernel与application通信&quot;&gt;&lt;a href=&quot;#kernel与application通信&quot; class=&quot;headerlink&quot; title=&quot;kernel与ap
      
    
    </summary>
    
      <category term="Program Language" scheme="http://yoursite.com/categories/Program-Language/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/Program-Language/C/"/>
    
    
      <category term="Program Skill" scheme="http://yoursite.com/tags/Program-Skill/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
