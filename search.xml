<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Autoencoder</title>
    <url>/2019/08/13/Autoencoder/</url>
    <content><![CDATA[<p>自编码器(Autoencoder)是一种神经网络，它试图通过训练，将输入复制到输出。在其内部有一个隐藏层 <script type="math/tex">h</script> ，代表了对输入的编码。网络可以看作由两部分组成</p>
<ul>
<li>编码器(encoder)：<script type="math/tex">h = f(x)</script></li>
<li>解码器(decoder)：<script type="math/tex">r = g(x)</script></li>
</ul>
<p>Autoencoder并不会设计成输出对输入的完美复制 <script type="math/tex">g(f(x)) = x</script>，因为这样的网络是没有意义的，相反，网络通常被刻意限制，只能近似复制。由于模型必须考虑选择输入的哪些部分来复制，因此可用于选择出输入的某些特性。网络需要在以下两件事上做平衡</p>
<ul>
<li>对输入足够敏感，能够准确地重构输入</li>
<li>对输入不够敏感，模型不能简单地记忆或过度拟合训练数据</li>
</ul>
<p>一般来说，Autoencoder主要用于数据降维和特征学习。最近，由于Autoencoder与潜变量模型之间的理论联系，Autoencoder被带到了生成概率模型的前沿。Autoencoder可看作是特殊的前向反馈网络，也可以使用再循环来训练</p>
<p>本文介绍以下自编码器</p>
<ul>
<li>Undercomplete Autoencoders</li>
<li>Regularized Autoencoders</li>
<li>Denoising Autoencoders</li>
<li>Contractive Autoencoders</li>
</ul>
<h2 id="Undercomplete-Autoencoders"><a href="#Undercomplete-Autoencoders" class="headerlink" title="Undercomplete Autoencoders"></a>Undercomplete Autoencoders</h2><p>如果关心网络的隐藏层，而不关心解码器的输出，将会希望训练Autoencoder执行输入复制任务导致 <script type="math/tex">h</script> 具有有用的属性。约束网络的一种方式是让 <script type="math/tex">h</script> 比输入 <script type="math/tex">x</script> 维度更小。这种编码维度小于输入维度的Autoencoder被称为<strong>Undercomplete</strong>。Undercomplete能够学习输入最显著的特征，以最小化损失函数来描述学习模型：</p>
<p>\begin{equation}<br>L(x,g(f(x)))<br>\end{equation}</p>
<p>其中 <script type="math/tex">L</script> 是损失函数，用来惩罚 <script type="math/tex">g(f(x))</script> 和 <script type="math/tex">x</script> 的不相似性，例如使用均方误差MSE。</p>
<p>当解码器是线性的，<script type="math/tex">L</script> 是MSE时，Undercomplete与PCA类似，其任务是学习训练数据的主子空间。采用非线性编码函数 <script type="math/tex">f</script> 和非线性解码器函数 <script type="math/tex">g</script> 的Undercomplete可以学习到比PCA更强的非线性泛化能力。但是如果编解码的容量过大，Undercomplete就无法提取有用信息了</p>
<h2 id="Regularized-Autoencoders"><a href="#Regularized-Autoencoders" class="headerlink" title="Regularized Autoencoders"></a>Regularized Autoencoders</h2>]]></content>
      <categories>
        <category>ML</category>
        <category>理论</category>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>C-Namespace</title>
    <url>/2020/07/13/C-Namespace/</url>
    <content><![CDATA[<p>记录两种C语言实现命令空间的方法</p>
<h2 id="结构体封装"><a href="#结构体封装" class="headerlink" title="结构体封装"></a>结构体封装</h2><p>简单来说就是将某个独立的库对外封装一个统一的接口结构体<code>structX</code>，外部调用时都使用<code>structX.aaa()</code>来调用库中的方法。例如有一个<code>foo</code>的库，要对外提供<code>test()</code>方法，可在<code>foo.h</code>文件中定义一个命名空间结构体<code>namespace_foo</code>，结构体中定义好需要对外提供的方法成员，并在最后通过<code>extern</code>关键字对外暴露结构体变量<code>Foo</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">namespace_foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *version;</span><br><span class="line">    <span class="keyword">int</span> (*test)();</span><br><span class="line">&#125; namespace_foo;</span><br><span class="line"><span class="keyword">extern</span> namespace_foo <span class="keyword">const</span> Foo;</span><br></pre></td></tr></table></figure>
<p>结构体变量<code>Foo</code>的定义在<code>foo.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace_foo <span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    .name = <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    .version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">    .test = foo_test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部要调用<code>foo</code>库中的函数，只需要引用<code>foo.h</code>头文件后，通过形如<code>Foo.test()</code>的方式就可以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo.test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有另外一个库<code>goo</code>需要同时使用，只需要定义结构体变量<code>Goo</code>时的变量名称与<code>Foo</code>不同即可</p>
<h2 id="利用ifdef"><a href="#利用ifdef" class="headerlink" title="利用ifdef"></a>利用ifdef</h2><p>另一种方式是利用条件宏定义宏来重定义函数名称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.h */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo_test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NAMESPACE_FOO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test(...)    foo_test(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在外部使用<code>foo</code>库的函数前，需要通过宏声明<code>NAMESPACE_FOO</code>，然后再引用<code>foo.h</code>头文件，后续调用<code>test()</code>函数就等于调用<code>foo_test()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMESPACE_FOO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program Language</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>Program Skill</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Skill</title>
    <url>/2019/11/27/C-Program-Skill/</url>
    <content><![CDATA[<p>本文记录一些实际工作中使用到的C语言编程技巧，或者学到的一些好用的用法</p>
<h2 id="kernel与application通信"><a href="#kernel与application通信" class="headerlink" title="kernel与application通信"></a>kernel与application通信</h2><h3 id="proc文件系统-amp-mmap"><a href="#proc文件系统-amp-mmap" class="headerlink" title="proc文件系统&amp;mmap"></a>proc文件系统&amp;mmap</h3><p>kernel和application通信方式有很多，但是当数据量较大时，常用的<code>ioctl</code>、<code>netlink</code>方式并不适合，<code>mmap</code>较为适用。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于应用层程序而言，系统调用<code>mmap()</code>可以将一个文件映射到内存空间，对该文件的读写就是对该块内存的读写。对于内核空间而言，proc文件系统的文件操作集<code>file_operations</code>支持<code>mmap</code>方法，在文件proc方法的具体实现中，可以将内存映射到应用层调用<code>mmap()</code>的虚拟地址上，从而实现应用层和内核空间通过proc文件关联同一块内存</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>内核空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_PROCFILE    <span class="meta-string">&quot;mmap_test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINUX_PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_MEM_SIZE  (LINUX_PAGE_SIZE * 8)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mmap_mem = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(vma-&gt;vm_end - vma-&gt;vm_start); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MMAP_MEM_SIZE) &#123;  </span><br><span class="line">        ret = -EINVAL;  </span><br><span class="line">        <span class="keyword">goto</span> err;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* map mem block to process&#x27;s address space */</span></span><br><span class="line">    page = virt_to_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>)mmap_mem + (vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT));</span><br><span class="line">    ret = remap_pfn_range(vma, </span><br><span class="line">                          vma-&gt;vm_start, </span><br><span class="line">                          page_to_pfn(page), </span><br><span class="line">                          size, </span><br><span class="line">                          vma-&gt;vm_page_prot);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* your operation */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_fops</span> =</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    .owner = THIS_MODULE,  </span><br><span class="line">    .mmap = proc_mmap,  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_mmap_create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* create mem block */</span></span><br><span class="line">    mmap_mem = kmalloc(MMAP_MEM_SIZE, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!mmap_mem) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kmalloc error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* your operation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create procfile */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_file</span> =</span> </span><br><span class="line">        proc_create(MMAP_PROCFILE, <span class="number">0x0644</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mmap_read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *mmap_mem = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> mmap_file[<span class="number">64</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(mmap_file, <span class="string">&quot;/proc/%s&quot;</span>, MMAP_PROCFILE)</span><br><span class="line">    fd = open(mmap_file, O_RDWR|O_NDELAY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;open %s error&quot;</span>, mmap_file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do mapping */</span></span><br><span class="line">    mmap_mem = (<span class="keyword">char</span> *)mmap(<span class="number">0</span>, </span><br><span class="line">                            MMAP_MEM_SIZE, </span><br><span class="line">                            PROT_READ | PROT_WRITE, </span><br><span class="line">                            MAP_SHARED, </span><br><span class="line">                            fd, </span><br><span class="line">                            <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mmap_mem) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* your operation */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (mmap_mem)</span><br><span class="line">        munmap(mmap_mem, MMAP_MEM_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; <span class="number">0</span>)</span><br><span class="line">        close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需注意数据同步问题</p>
]]></content>
      <categories>
        <category>Program Language</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>Program Skill</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning Overview</title>
    <url>/2019/09/29/Deep-Learning-Overview/</url>
    <content><![CDATA[<p>神经网络是有史以来人类最接近“智能”的一次尝试，尽管就目前而言，这项技术与图灵测试所定义的智能存在极大的差距，但是它独特的解决问题的角度和方式，堪称一项伟大而优美的发明。神经网络起源于对人类大脑学习、思考和记忆产生的研究，说白了就是在研究造物主是如何创造我们的智慧的。虽然现阶段脑科学、神经科学和计算机科学还有很多关键问题仍待突破，但是神经网络和一系列衍生的应用已经能够达到商用级别，它的跨领域渗透能力在未来的发展中存在巨大的潜力，并将深刻的变革现代信息社会</p>
<p>神经网络同时也是有史以来发明的最优美的编程范式之一，在传统的编程中，人们告诉计算机做什么，把大问题分成许多小的、精确定义的任务，计算机可以很容易的执行。相比之下，在神经网络中，我们不会告诉计算机如何解决问题，而是让它在数据中学习，从而找到解决问题的方法</p>
<p>本文是一篇关于神经网络的综述性文章，包括对神经网络发展历史、基本概念、目前发展现状以及前沿领域的介绍</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>深度学习模型来源于从生物大脑(无论是人类大脑还是动物大脑)中受到的启发<br><img src="/2019/09/29/Deep-Learning-Overview/image/NN-01.jpg" alt><br>听觉、视觉、触觉、味觉，通过身体不同器官，最终都将转化为生物电信号从末梢神经一层一层传递到大脑的深层神经网中，思维的过程也是电信号在成百上千亿神经元之间非常快速的传递过程。传统生物学中认为，大脑中的不同区域有着不同的功能，专门用于处理语言、图像、运动等问题，但是最新的研究结果表明，在专门处理某类问题的区域上长期施加另一类信号的刺激，这个区域能够适应并处理这些刺激，例如在舌头上放置声音转换成电信号的刺激装置让舌头能够“听”声音，在手臂上放置超声波距离转换成电信号的刺激装置能够让皮肤“看”前方的障碍物。这说明大脑中这种神经元构成的网状结构是一种极其通用化的学习模型，能够对任何外界的刺激做出反应</p>
<p>深度学习中的神经网络是由两个主要观点驱动的：</p>
<ul>
<li>大脑模型是一个很好的例子来证明智能行为的可能，从这一点出发，创造智能最直截了当的方向是运用逆向工程对大脑背后的运作原理进行分析并复制</li>
<li>理解大脑和人类智能的基础原理本身是非常有趣的，因此深度学习模型除了解决工程应用之外，对于研究阐明大脑、神经等基本科学问题也是有作用的</li>
</ul>
<h3 id="3个命名阶段"><a href="#3个命名阶段" class="headerlink" title="3个命名阶段"></a>3个命名阶段</h3><p>概括地说，深度学习的发展经历了三个阶段</p>
<ul>
<li><strong>cybernetics</strong> 20世纪40-60年代的深度学习被称为控制论</li>
<li><strong>connectionism</strong> 20世纪80-90年代神经网络被称为连接主义</li>
<li><strong>deep learning</strong> 2006年开始以深度学习命名</li>
</ul>
<p><img src="/2019/09/29/Deep-Learning-Overview/image/NN-02.png" alt></p>
<p>上图中显示了3次人工神经网络研究的历史浪潮中的两次，第一次浪潮始于20世纪40年代至60年代的控制论，随着生物学习理论(McCulloch and Pitts, 1943; Hebb, 1949)的发展，Rosenblatt实现了第一个感知器模型(Rosenblatt, 1958)，允许训练单个神经元。第二次浪潮始于1980-1995年期间的连接主义方法，用反向传播(Rumelhart et al., 1986)来训练一个带有一个或两个隐藏层的神经网络。第三次浪潮始于2006年(Hintonet al., 2006; Bengio et al., 2007; Ranzato et al., 2007a)</p>
<p>在上个世纪60~90年代，神经网络的研究较为缓慢，研究者发现了处理神经网络的计算机器的两个关键问题。第一个问题是单层神经网络不能处理异或电路。第二个重要问题是计算机不够复杂，无法有效地处理大型神经网络所需的长时间运行。然而20世纪末期直到今天，由于第三次工业革命，信息的产生呈爆炸式增长，计算机的性能也有了极大的提升，这使得大型深层次的神经网络成为可能，其性能也在高速增长</p>
<h2 id="神经网络框架"><a href="#神经网络框架" class="headerlink" title="神经网络框架"></a>神经网络框架</h2><p>基本的神经网络结构如下图所示</p>
<p><img src="/2019/09/29/Deep-Learning-Overview/image/NN-03.png" alt></p>
<p>最左侧的称为<strong>输入层</strong>，其中的神经元称为输入神经元，最右边的称为<strong>输出层</strong>，中间层被称为<strong>隐藏层</strong>。这种结构在有些地方也被称为MLP(多层感知器)，也叫做FF(Feed Forward Network, 前馈神经网络)</p>
<p>网络中的每个神经元都是一个最简单的线性模型</p>
<script type="math/tex; mode=display">
\begin{equation}
y = \omega{x} + b 
\end{equation}</script><p>其中$\omega$和$b$分别叫做神经元的权重和偏置。神经网络的运行，是从输入层向输出层，一层一层传递结果的，上一层的输出作为下一层的输入，最终传递到输出层，而每个神经元上的权重和偏置的微小改变，都会影响最终的输出。学习的本质就是不断地调整这些神经元上的权重和偏置值</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>对于某一个神经元而言，由于简单的权重和偏置是一个线性模型，有以下缺陷</p>
<ul>
<li>单个神经元的改变对网络的影响过大</li>
<li>线性函数无法理解输入变量之间的相互作用，最简单的就是线性模型不能学习异或关系$XOR$</li>
</ul>
<p>为了解决以上问题，我们可以不直接把线性模型用于神经元本身，而是用在一个变换后的输入上</p>
<script type="math/tex; mode=display">
\begin{align}
y &= \sigma(z)\\
z &= \omega{x} + b
\end{align}</script><p>这里的$\sigma$是一个非线性变换，而这种非线性变换就叫做激活函数。目前常用的激活函数有4种</p>
<ul>
<li><strong>Sigmoid</strong> S型生长曲线</li>
<li><strong>tanh</strong> 双曲正切函数</li>
<li><strong>ReLU</strong> 线性整流函数</li>
<li><strong>Maxout</strong></li>
</ul>
<h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><p>Sigmoid函数的定义如下</p>
<script type="math/tex; mode=display">
f(x) = \frac{1}{1 + e^{-x}}</script><p>Sigmoid函数的图像如图所示<br><img src="/2019/09/29/Deep-Learning-Overview/image/NN-04.png" alt><br>sigmoid函数当输入x趋近于负无穷时，输出y趋近于0，当输入x趋近于正无穷时，输出y趋近于1，即把输入归一化到0~1范围内</p>
<p>Sigmoid函数的导数</p>
<script type="math/tex; mode=display">
f'(x) = f(x)*(1-f(x))</script><p>Sigmoid导数的图像如图所示<br><img src="/2019/09/29/Deep-Learning-Overview/image/NN-08.png" alt></p>
<h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><p>tanh函数的定义如下</p>
<script type="math/tex; mode=display">
f(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}</script><p>tanh函数的图像如图所示<br><img src="/2019/09/29/Deep-Learning-Overview/image/NN-05.png" alt></p>
<p>tanh函数的导数</p>
<script type="math/tex; mode=display">
f'(x) = 1 − f(x)^{2}</script><p>tanh导数的图像如图所示<br><img src="/2019/09/29/Deep-Learning-Overview/image/NN-09.png" alt></p>
<h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>ReLU函数定义如下</p>
<script type="math/tex; mode=display">
f(x) = max(0, x)</script><p>ReLU函数的图像如图所示<br><img src="/2019/09/29/Deep-Learning-Overview/image/NN-06.png" alt></p>
<p>ReLU函数的导数</p>
<script type="math/tex; mode=display">
\begin{equation}  
f(x) = 
\left\{
        \begin{array}{**lr**}  
        0, & x \leq 0 \\  
        1, & x > 0 \\   
        \end{array}
\right.  
\end{equation}</script><p>当输入x小于0时输出为0，当大于0时输出y</p>
<p>激活函数各有优劣，适用于不同的应用场景，合理选择才能达到好的效果</p>
<h3 id="代价函数、梯度下降"><a href="#代价函数、梯度下降" class="headerlink" title="代价函数、梯度下降"></a>代价函数、梯度下降</h3><p>神经网络的学习，其目的是要达到给定训练样本${(x1,y1),(x2,y2)…}$，训练网络后，使得网络对于未知的输入数据能够尽可能逼近真实的输出。常用以下函数来描述这一目标，称作代价函数</p>
<script type="math/tex; mode=display">
C = \frac{1}{2n}\sum_{x}\vert{y(x) - a^{L}(x)}\vert^2</script><p>其中$n$是训练样本总数，$L$表示网络层数，$a^{L}(x)$是网络输入为$x$时的激活向量</p>
<p>当代价函数被定义好了之后，如何通过代价函数来调整网络呢？要想让网络的输出尽量逼近真实值，则要将代价函数最小化。通常要最小化函数是通过求导取极值来实现的，但是对于神经网络而言，输入$x$通常不是一个变量，而是一组变量构成的向量，因此代价函数其实是个多元函数$C(x1,x2,x3…)$，其最小化通过梯度下降算法来实现。梯度是数学上多元函数偏导数的概念，梯度永远指向函数下降最快的方向，梯度下降算法的思想是每次将代价函数减去一个由梯度和一个步长构成的微小值，那么经过多次迭代，代价函数总是朝着最小值逼近，最终代价函数趋近于最小值不再变化时，表明网络已经收敛</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>神经网络中使用反向传播(backprop)来计算梯度，</p>
<h2 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h2><p>一般在具体应用领域中不会直接使用这种基本的神经网络结构，在长时间的发展中，针对不同种类的问题，神经网络已经演化出了多种结构</p>
<ul>
<li>CNN(Convolutional Neural Network，卷积神经网络)，适用于图像识别领域</li>
<li>RNN(Recursion Neural Network，递归/循环神经网络)，适用于语音、文字处理</li>
<li>LSTM(Long Short-Term Memory Network，长短记忆网络)，RNN的改进版</li>
<li>DBN(Deep Belief Network，深度信念网络)，多个神经网络堆叠，适用于识别</li>
<li>GAN(Generative Adversarial Network，生成对抗网络)，用于自学习</li>
</ul>
<p>目前神经网络也已经有很多成熟的开发框架</p>
<ul>
<li>sklearn</li>
<li>caffe</li>
<li>pytorch</li>
<li>tensorflow</li>
<li>keras</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Michael A. Nielsen, “Neural Networks and Deep Learning”, Determination Press, 2015</li>
<li>Ian Goodfellow and Yoshua Bengio and Aaron Courville, “Deep Learning”, MIT Press, 2016</li>
<li>wikipedia:<a href="https://en.wikipedia.org/wiki/Neural_network">Neural network</a></li>
</ol>
]]></content>
      <categories>
        <category>ML</category>
        <category>理论</category>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepLearing.ai-Andrrew Ng-课程介绍</title>
    <url>/2019/09/10/DeepLearing-ai-Andrrew-Ng-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul>
<li>Neural Network and Deep Learning</li>
<li>Improving Deep Neural Network: Hyperparamter tuning, Regularization and Optimization</li>
<li>Structuring your Machine Learning project</li>
<li>Convolutional Network Network</li>
<li>Natural Language Processing: Build sequence models. (RNN, LSTM)</li>
</ul>
<h2 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络"></a>什么是神经网络</h2><p>以预测房价为例，下图显示的是房价 $price$ 和房屋面积 $size$ 之间的关系</p>
<p><img src="/2019/09/10/DeepLearing-ai-Andrrew-Ng-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/image/dl-01.png" alt></p>
<p>使用线性拟合可以得到一条蓝色曲线，该曲线类似一个线性整流单元(ReLU, Rectified Linear Unite)。ReLU是神经网络中激活函数的一种，关于ReLU和激活函数在后续内容再做介绍，此处先不做过多解释。我们用一个神经元来表示输入和输出的关系</p>
<p><img src="/2019/09/10/DeepLearing-ai-Andrrew-Ng-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/image/dl-02.png" alt></p>
<p>这个神经元就是ReLU。如果增加更多的特征，一个神经元不足以表示特征和输出的关系，则需要增加神经元个数</p>
<p><img src="/2019/09/10/DeepLearing-ai-Andrrew-Ng-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/image/dl-03.png" alt></p>
<p>可以理解，房屋大小和卧室数量决定的是房屋面积，地铁站数量和距离市中心远近决定的是房屋位置，而更深层的神经元是综合考量。其实不需要人为标定每个神经元的作用，而完全可以只输入特征，让神经元自己学习和决定。当给定足够的训练数据$(x,y)$，神经网络能够很好的拟合出$x,y$之间的映射关系</p>
<h2 id="用神经网络进行监督学习"><a href="#用神经网络进行监督学习" class="headerlink" title="用神经网络进行监督学习"></a>用神经网络进行监督学习</h2><p>神经网络属于监督学习范畴，即必须给定输入和输出的对应训练数据，网络基于此进行学习。神经网络的学习对象可以是结构化数据，也可以是非结构化数据。例如用户推荐系统利用公司数据库中用户的结构化信息如年龄、购买力、兴趣等数据进行学习，并向用户推荐所好；非结构化数据指的是不同于结构化数据，有完整的数据结构和成员，而只是一段数据序列，例如音频文件、文本文件、图片中的数据流，神经网络同样能够进行学习</p>
<h2 id="深度神经网络为什么会快速兴起"><a href="#深度神经网络为什么会快速兴起" class="headerlink" title="深度神经网络为什么会快速兴起"></a>深度神经网络为什么会快速兴起</h2><p>深度神经网络的兴起可以用下图来说明</p>
<p><img src="/2019/09/10/DeepLearing-ai-Andrrew-Ng-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/image/dl-04.png" alt></p>
<p>横轴表示数据规模，纵轴表示学习算法的性能。对于传统算法例如SVM、Logistic、随机森林等算法而言，在早期数据量较小的情况下，能够获得不错的性能，但这些算法不知道如何处理更大规模的数据，当性能到达某个瓶颈后，再增加数据量并不能提高算法性能</p>
<p>神经网络算法并不是近几年来的新发现，很早就已经提出。但是由于近年来电子信息技术的发展，数据的产生呈爆炸式发展，数据的产生、存储、处理、通信能力和速度都得到了极大提升，而神经网络算法能够不断地从新数据中学习，这种学习能力随着数据规模迅速增长。小型的神经网络在大量数据的训练中已经能够超过传统算法很多，而最前沿的超大规模数据+超大规模神经网络的组合已经能够取得非常好的性能</p>
]]></content>
      <categories>
        <category>公开课</category>
        <category>DeepLearing.ai</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch条件query</title>
    <url>/2019/06/25/Elasticsearch%E6%9D%A1%E4%BB%B6query/</url>
    <content><![CDATA[<h2 id="按照时间升序降序query"><a href="#按照时间升序降序query" class="headerlink" title="按照时间升序降序query"></a>按照时间升序降序query</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_byid</span>(<span class="params">self, <span class="built_in">id</span>, size, reverse_order=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> reverse_order == <span class="literal">True</span>:</span><br><span class="line">            _order = <span class="string">&#x27;desc&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _order = <span class="string">&#x27;asc&#x27;</span></span><br><span class="line">        dsl = &#123;</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">                    <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">                        &#123;<span class="string">&quot;match&quot;</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="built_in">id</span>&#125;&#125;,</span><br><span class="line">                    ],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">                &#123; <span class="string">&quot;service.data.time&quot;</span> : &#123;<span class="string">&quot;order&quot;</span> : _order&#125;&#125;,</span><br><span class="line">                <span class="string">&quot;_score&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;_source&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;service.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;deviceId&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;size&quot;</span>:size,</span><br><span class="line">        &#125;</span><br><span class="line">        raw_data = self.query(dsl)</span><br><span class="line">        raw_list = raw_data[<span class="string">&quot;hits&quot;</span>][<span class="string">&quot;hits&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> raw_list</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning Reference Reading</title>
    <url>/2019/07/31/Machine-Learning-Reference-Reading/</url>
    <content><![CDATA[<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul>
<li><p><a href="https://medium.com/analytics-vidhya/using-machine-learning-to-predict-stock-prices-c4d0b23b029a">Using Machine Learning to Predict Stock Prices</a><br>利用机器学习预测股票价格，作者“Vivek Palaniappan”，该文章使用了小波变换来滤除噪声，使用栈式自编码器自动提取特征，选取LSTM神经网络作为预测模型，在雪佛龙公司和艾森克美孚公司的MSE分别达到2.11和0.0945。Github地址：<a href="https://github.com/VivekPa/AIAlpha?source=post_page---------------------------">AlphaAI</a></p>
</li>
<li><p><a href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/">A comprehensive beginner’s guide to create a Time Series Forecast</a><br>时间序列预测综合指南，详细介绍了时间序列数据分析及预测的一系列思路和方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Microblaze优化选项</title>
    <url>/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<p>Microblaze提供了一些优化选项，正确理解这些选项的含义以及作用对于开发过程有很多帮助，本文主要总结介绍Microblaze Configuration Wizard中的选项内容</p>
<h2 id="预定义配置"><a href="#预定义配置" class="headerlink" title="预定义配置"></a>预定义配置</h2><p>根据具体使用场景的不同，Microblaze提供了一些预定义的配置选项供用户选择</p>
<ul>
<li><p>Microcontroller Preset</p>
</li>
<li><p>Real-time Preset</p>
</li>
<li><p>Application Preset</p>
</li>
<li><p>Minimum Area</p>
</li>
<li><p>Maximum Performance</p>
</li>
<li><p>Maximum Frequency</p>
</li>
<li><p>Linux with MMU</p>
</li>
<li><p>Low-end Linux with MMU</p>
</li>
<li><p>Typical</p>
</li>
<li><p>Frequency Optimized</p>
</li>
</ul>
<p>这些选项实际上是Microblaze在频率、面积、性能这几个指标不同侧重情况下，对各个配置项的组合。选择Current Settings即为自定义模式</p>
<h2 id="Implementation-Optimization"><a href="#Implementation-Optimization" class="headerlink" title="Implementation Optimization"></a>Implementation Optimization</h2><p>该选项可选以下3种：</p>
<ul>
<li><p>Performance</p>
</li>
<li><p>Area</p>
</li>
<li><p>Frequency</p>
</li>
</ul>
<p>这个选项非常重要，它与Microblaze的流水线级数对应</p>
<ul>
<li><p>3级流水线：Area</p>
</li>
<li><p>5级流水线：Performance</p>
</li>
<li><p>8级流水线：Frequency</p>
</li>
</ul>
<h3 id="三级流水线"><a href="#三级流水线" class="headerlink" title="三级流水线"></a>三级流水线</h3><p>三级流水线对应Area，使用了最小化的硬件花费，只有取址(Fetch)、译码(Decode)和执行(Execute)</p>
<p><img src="/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/images\01.PNG" alt></p>
<p>三级流水线没有数据阻塞，只有控制流程阻塞、多指令结构性阻塞和访问较慢的内存、从较慢的内存取址等情况。多周期的指令类别有桶形移位器(barrel shift)、乘法器(multiply)、除法器(divide)和浮点指令</p>
<h3 id="五级流水线"><a href="#五级流水线" class="headerlink" title="五级流水线"></a>五级流水线</h3><p>五级流水线对应Performance，最大化性能考量，包括取址(Fetch，IF)、译码(Decode OF)、执行(Execute，EX)、内存访问(Access Memory，MEM)和写回(Writeback，WB)</p>
<p><img src="/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/images\02.PNG" alt></p>
<p>五级流水线存在以下两种数据阻塞的情况</p>
<ul>
<li><p>OF指令需要EX指令的结果作为源操作数。EX指令类别为加载、存储、桶形移位器、乘法器、触发器和浮点运算。这些会导致1-2周期的阻塞</p>
</li>
<li><p>OF指令需要MEM指令的结果作为源操作数。MEM指令类别包括加载、乘法器和浮点运算。这些会导致1个周期的阻塞</p>
</li>
</ul>
<p>多周期指令有除法器和浮点运算</p>
<h3 id="八级流水线"><a href="#八级流水线" class="headerlink" title="八级流水线"></a>八级流水线</h3><p>八级流水线对应Frequency，用于最大化频率，包括取址(Fetch，IF)、译码(Decode OF)、执行(Execute，EX)、内存访问0(Access Memory 0，M0)、内存访问1(Access Memory 1，M1)、内存访问2(Access Memory 2，M2)、内存访问3(Access Memory 3，M3)和写回(Writeback，WB)</p>
<p><img src="/2021/11/04/Microblaze%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9/images\03.PNG" alt></p>
<p>八级流水线存在以下四种数据阻塞的情况</p>
<ul>
<li><p>OF指令需要EX指令的结果作为源操作数。EX包括加载、存储、桶形移位器、乘法器、除法器和浮点运算，会导致1-5个周期的阻塞</p>
</li>
<li><p>OF指令需要M0指令的结果作为源操作数。M0包括加载、乘法器、除法器和浮点运算，会导致1-4周期的阻塞</p>
</li>
<li><p>OF指令需要M1或M2指令的结果作为源操作数。M1或M2包括加载、除法器和浮点运算，会导致1-3或1-2周期的阻塞</p>
</li>
<li><p>OF指令需要M3指令的结果作为源操作数。M3包括加载和浮点运算，会导致1周期的阻塞</p>
</li>
</ul>
<p>在额外的多周期指令种，存在3种情况的结构性阻塞</p>
<ul>
<li><p>OF中的指令是流指令，EX中的指令是流、加载、存储、除法或浮点指令，并实现了相应的异常，这导致一个1周期的阻塞</p>
</li>
<li><p>OF中的指令是流指令，M0、M1、M2或M3中的指令是装载、存储、除法或浮点指令，并实现了相应的异常，这导致一个1周期的阻塞</p>
</li>
<li><p>M0中的指令是加载或存储指令，M1、M2或M3中的指令是加载、存储、除法或浮点指令，并实现了相应的异常，这导致一个1周期的阻塞</p>
</li>
</ul>
<p>多周期指令分为分割指令和浮点指令FDIV, FINT和FSQRT</p>
<h2 id="Use-Instruction-and-Data-Caches"><a href="#Use-Instruction-and-Data-Caches" class="headerlink" title="Use Instruction and Data Caches"></a>Use Instruction and Data Caches</h2><p>使用外部存储器时，激活高速缓存，可以显著提高性能，可以降低外部慢速设备访问的使用量</p>
<h2 id="Enable-Barrel-Shifter"><a href="#Enable-Barrel-Shifter" class="headerlink" title="Enable Barrel Shifter"></a>Enable Barrel Shifter</h2><p>使能硬件桶形移位器(Barrel Shifter)，可以提高程序在移位操作时的性能。当该选项使能时，编译器可以自动的选择使用<code>bsrl</code>、<code>bsra</code>、<code>bsll</code>、<code>bsrli</code>、<code>bsrai</code>和<code>bslli</code>等汇编指令来优化加速移位操作</p>
<h2 id="Enable-Floating-Point-Unit"><a href="#Enable-Floating-Point-Unit" class="headerlink" title="Enable Floating Point Unit"></a>Enable Floating Point Unit</h2><p>浮点运算单元能够提升<code>float</code>类型数据进行运算时的效率，Microblaze的FPU遵循了IEEE 754-1985标准，支持加、减、乘、除、比较、转换和平方根运算。编译器会自动根据系统选择的FPU类型使用汇编浮点指令优化浮点运算</p>
<h2 id="Enable-Integer-Multiplier"><a href="#Enable-Integer-Multiplier" class="headerlink" title="Enable Integer Multiplier"></a>Enable Integer Multiplier</h2><p>使用一个硬件乘法器，可以提升程序在乘法运算时的效率</p>
<h2 id="Enable-Integer-Divider"><a href="#Enable-Integer-Divider" class="headerlink" title="Enable Integer Divider"></a>Enable Integer Divider</h2><p>使能整型除法器，可以使用idiv和idivu指令，提升除法运算效率</p>
<h2 id="Enable-Additional-Machine-Status-Registers-Instructions"><a href="#Enable-Additional-Machine-Status-Registers-Instructions" class="headerlink" title="Enable Additional Machine Status Registers Instructions"></a>Enable Additional Machine Status Registers Instructions</h2><p>使能MSR寄存器指令<code>msrset</code>和<code>msrclr</code>，用于设置和清MSR的位。MSR包含了处理器的控制和状态位，读取该寄存器时bit[29]会被复制到bit[0]作为近进位复制。对MSR进行读写有两种方式，一种是使用<code>MFS</code>、<code>MTS</code>指令，另一种是使用<code>msrset</code>和<code>msrclr</code>。当使用<code>msrset</code>和<code>msrclr</code>进行写时，进位立即生效，其余位在一个时钟周期后生效。当使用<code>MTS</code>写时，所有位都在一个时钟周期后生效。程序运行会非常频繁的使用MSR，因此使能该选项可以很大程度的提升性能</p>
<p>例如在使用FreeRTOS时，systick或者消息队列中会频繁调用<code>microblaze_enable_interrupts</code>和<code>disable_enable_interrupts</code>函数，这两个函数是汇编函数，例如<code>microblaze_enable_interrupts</code>函数的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.globl	microblaze_enable_interrupts</span><br><span class="line">	.ent	microblaze_enable_interrupts</span><br><span class="line">	.align	<span class="number">2</span></span><br><span class="line">microblaze_enable_interrupts:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> XPAR_MICROBLAZE_USE_MSR_INSTR == 1</span></span><br><span class="line">	rtsd	r15, <span class="number">8</span></span><br><span class="line">	msrset  r0, <span class="number">0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/*XPAR_MICROBLAZE_USE_MSR_INSTR == 1*/</span></span></span><br><span class="line">	#Read the MSR <span class="keyword">register</span></span><br><span class="line">	mfs	r12, rmsr</span><br><span class="line">	#Set the interrupt enable bit</span><br><span class="line">	ori	r12, r12, <span class="number">0x2</span></span><br><span class="line">	#Save the MSR <span class="keyword">register</span></span><br><span class="line">	mts	rmsr, r12</span><br><span class="line">	#Return</span><br><span class="line">	rtsd	r15, <span class="number">8</span></span><br><span class="line">	nop</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*XPAR_MICROBLAZE_USE_MSR_INSTR == 1*/</span></span></span><br><span class="line">	.end	microblaze_enable_interrupts</span><br></pre></td></tr></table></figure>
<p>可以看到，如果定义了<code>MSR_INSTR</code>，使能中断只有两条指令完成，否则需要5条指令。因此开启额外MSR指令能够在多任务系统任务切换和上下文切换方面提升性能</p>
<h2 id="Enable-Pattern-Comparator"><a href="#Enable-Pattern-Comparator" class="headerlink" title="Enable Pattern Comparator"></a>Enable Pattern Comparator</h2><p>使能模式比较器，可以使用<code>pcmpbf</code>、<code>pcmpeq</code>和<code>pcmpne</code>指令，提升程序在进行比较时的性能。编译器自动进行指令转换</p>
<h2 id="Enable-Reversed-Load-Store-and-Swap-Instructions"><a href="#Enable-Reversed-Load-Store-and-Swap-Instructions" class="headerlink" title="Enable Reversed Load/Store and Swap Instructions"></a>Enable Reversed Load/Store and Swap Instructions</h2><p>启用反向加载/存储和交换指令，可以使用<code>lbur</code>、<code>lhur</code>、<code>lwr</code>、<code>sbr</code>、<code>shr</code>、<code>swr</code>、<code>swapb</code>和<code>swawph</code>指令。反向加载/存储指令可以以相反的字节顺序读写数据，交换指令可以在寄存器中交换字节和字。这些指令在处理网络字节序(大端)和Microblaze字节序(小端)</p>
<p>时可以提升性能</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title>Narrowband Power Optimizations for Massive IoT: eDRX and PSM[译]</title>
    <url>/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-%E8%AF%91/</url>
    <content><![CDATA[<p>本文翻译自twilio网站文章<a href="[https://www.twilio.com/docs/wireless/nb/nb-iot-power-optimizations-edrx-psm](https://www.twilio.com/docs/wireless/nb/nb-iot-power-optimizations-edrx-psm">Narrowband Power Optimizations for Massive IoT: eDRX and PSM</a>)</p>
<p>NB-IoT(Narrowband IoT, 窄带物联网)蜂窝技术是为低功耗设备而设计的。它包含了大量物联网设备开发人员可以使用的功能，例如位置跟踪器、低成本传感器网络、公用电表和预防性维护监视器，以将产品的电力消耗降到最低</p>
<p>本指南描述了其中的两个优化特性，即PSM(省电模式, Power Save Mode)和eDRX(扩展不连续接收, Extended Discontinuous Reception)，以帮助您评估它们如何为您的大规模物联网应用程序带来好处，以及如何利用它们</p>
<h2 id="PSM"><a href="#PSM" class="headerlink" title="PSM"></a>PSM</h2><p>通常，大多数物联网设备间歇性地发送或接收数据。在数据的发送和接收之间，可以让设备处于休眠状态，以最大限度的降低功耗，最大化电池能量</p>
<p>PSM是蜂窝调制解调器的一种特性，它可以关闭设备无线电并使设备进入休眠状态，而无需在下次醒来时re-attach(重新附着)到网络。虽然re-attach过程只消耗少量的能量，但是在设备的整个生命周期中，re-attach的累积能量消耗可能变得非常大。因此，如果可以避免re-attach，可使得电池寿命延长。PSM刚好提供了这一点</p>
<ul>
<li><p>PSM是一种降低无线电能量消耗的设备端机制。设备报告网络自己需要多频繁和多长时间处于活跃状态，以便传输和接收数据。然而，最终的值是由网络决定的</p>
</li>
<li><p>PSM模式类似于断电，但是设备在网络中的状态仍然保持为已注册。当设备再次活跃时，没有必要re-attach或re-establish(重新建立)PDN(数据包数据网络, Packet Data Network)连接</p>
</li>
<li><p>PSM特性是在3GPP Release 12 中引入的，适用于所有LTE设备类别。设备请求PSM只需在attach、TAU(跟踪区域更新, tracking area udpate)或者路由区域更新中包含一个带有所需值的计时器</p>
</li>
</ul>
<p><img src="/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-%E8%AF%91/image/01.png" alt></p>
<h3 id="PSM-FAQS"><a href="#PSM-FAQS" class="headerlink" title="PSM FAQS"></a>PSM FAQS</h3><h4 id="它如何工作？"><a href="#它如何工作？" class="headerlink" title="它如何工作？"></a>它如何工作？</h4><p>当设备通过网络初始化PSM时，它提供两个首选计时器(T3324和T3412)；PSM时间是这两个计时器的差值(T3412减去T3324)。网络可以接受这些值，也可以设置不同的值。然后网络保留状态信息，设备保持在网络上注册。如果设备在它与网络约定的时间间隔到期之前唤醒并发送数据，则不需要re-attach过程</p>
<h4 id="当设备处于活跃PSM周期时，它可以接收消息吗"><a href="#当设备处于活跃PSM周期时，它可以接收消息吗" class="headerlink" title="当设备处于活跃PSM周期时，它可以接收消息吗?"></a>当设备处于活跃PSM周期时，它可以接收消息吗?</h4><p>不能，在活跃PSM周期时无法访问设备</p>
<h4 id="当设备处于活跃PSM周期时，是否可以通过NIDD-非ip数据传递-Non-IP-Data-Delivery-访问它"><a href="#当设备处于活跃PSM周期时，是否可以通过NIDD-非ip数据传递-Non-IP-Data-Delivery-访问它" class="headerlink" title="当设备处于活跃PSM周期时，是否可以通过NIDD(非ip数据传递, Non-IP Data Delivery)访问它?"></a>当设备处于活跃PSM周期时，是否可以通过NIDD(非ip数据传递, Non-IP Data Delivery)访问它?</h4><p>不能，NIDD通过寻呼信道工作(paging channel)，该信道利用无线电。在活跃PSM周期中，无线电完全关闭，无法访问设备</p>
<h4 id="在活跃PSM周期中发送到设备的数据包会发生什么"><a href="#在活跃PSM周期中发送到设备的数据包会发生什么" class="headerlink" title="在活跃PSM周期中发送到设备的数据包会发生什么?"></a>在活跃PSM周期中发送到设备的数据包会发生什么?</h4><p>3GPP要求必须由网络存储数据包。建议网络操作员至少为最后一个100字节的数据包留出存储空间</p>
<h4 id="一个设备可以在PSM周期中停留多久？"><a href="#一个设备可以在PSM周期中停留多久？" class="headerlink" title="一个设备可以在PSM周期中停留多久？"></a>一个设备可以在PSM周期中停留多久？</h4><p>在T-Mobile的NB-IoT网络上，一个设备可以在PSM循环中最多停留12小时</p>
<h2 id="使用PSM"><a href="#使用PSM" class="headerlink" title="使用PSM"></a>使用PSM</h2><p>蜂窝模块必须支持PSM。可以使用设备上的AT命令来启用它</p>
<p>例如，如果你使用的是Quectel BG96调制解调器，你可以发送以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AT+QCFG=&quot;psm/urc&quot;[enable]</span><br><span class="line"></span><br><span class="line">AT+QPSMTIMER: &lt;tau_timer&gt;,&lt;T3324_timer&gt;</span><br></pre></td></tr></table></figure>
<p>不需要用户进行网络配置；在设备上启用PSM就足够了</p>
<p>根据GPRS Timer 3规范(见3GPP TS 24.008第<a href="[https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf](https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf">10.5.7.4a</a>)节)，要求的周期TAU定时器值编码如下：</p>
<p>第5位到第1位表示二进制编码的定时器值。第6位到第8位定义计时器的计时器值单元，如下所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Timer 3 value</th>
<th>Timer value is incremented in multiples of</th>
</tr>
</thead>
<tbody>
<tr>
<td>000xxxxx</td>
<td>10 minutes</td>
</tr>
<tr>
<td>001xxxxx</td>
<td>1 hour</td>
</tr>
<tr>
<td>010xxxxx</td>
<td>10 hours</td>
</tr>
<tr>
<td>011xxxxx</td>
<td>2 seconds</td>
</tr>
<tr>
<td>100xxxxx</td>
<td>30 seconds</td>
</tr>
<tr>
<td>101xxxxx</td>
<td>1 minute</td>
</tr>
<tr>
<td>110xxxxx</td>
<td>320 hours*</td>
</tr>
<tr>
<td>111xxxxx</td>
<td>Timer is deactivated</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>参见3GPP <a href="[https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf](https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf">TS 24.008</a>)规范中的说明，表10.5.163a提供了关于这个值的更多信息</p>
</blockquote>
<p>请求的活跃时间是由GPRS Timer 2规范的octet 3定义的一个二进制字符串字节值(见3GPP <a href="[https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf]](https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf%5D">TS 24.008</a>(<a href="https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf">https://www.etsi.org/deliver/etsi_ts/124000_124099/124008/13.07.00_60/ts_124008v130700p.pdf</a>)的10.5.7.4节)，如下所示：</p>
<p>bi5到1表示二进制编码计时器值。第6到8位定义计时器的定时器如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Timer 3 value</th>
<th>Timer value is incremented in multiples of</th>
</tr>
</thead>
<tbody>
<tr>
<td>000xxxxx</td>
<td>2 seconds</td>
</tr>
<tr>
<td>001xxxxx</td>
<td>1 minute</td>
</tr>
<tr>
<td>010xxxxx</td>
<td>1 decihour (6 minutes)</td>
</tr>
<tr>
<td>111xxxxx</td>
<td>Timer is deactivated</td>
</tr>
</tbody>
</table>
</div>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AT+CPSMS=1,,,&quot;01000011&quot;,&quot;01000011&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令使得PSM周期TAU值变为30小时，请求的活动时间为18分钟</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AT+CPSMS=0</span><br></pre></td></tr></table></figure>
<p>以上命令禁用PSM</p>
<h2 id="eDRX"><a href="#eDRX" class="headerlink" title="eDRX"></a>eDRX</h2><p>eDRX是现有LTE功能的扩展，可以被物联网设备用来降低功耗。eDRX可以在没有PSM的情况下使用，也可以与PSM结合使用，以获得额外的电能节省</p>
<p>eDRX允许大大扩展设备不监听网络的时间间隔。对于一个大规模的物联网应用程序，设备在几秒钟或更长时间内无法访问是完全可以接受的。虽然eDX不能提供与PSM相同的功耗降低级别，但它可以在设备可达性和某些应用程序的功耗之间提供一个很好的折衷。网络和设备在设备可以睡眠时进行协商。设备在规定的周期内保持其接收电路关闭，在此期间，设备不侦听寻呼或下行控制信道。当设备醒来时，接收器将监听物理控制通道</p>
<p><img src="/2020/04/17/Narrowband-Power-Optimizations-for-Massive-IoT-eDRX-and-PSM-%E8%AF%91/image/02.png" alt></p>
<p>eDRX只允许在一定期限内使用；以下列出了这些项目：</p>
<ul>
<li><p>20.48 seconds</p>
</li>
<li><p>40.96 seconds</p>
</li>
<li><p>81.92 seconds (~1 minute)</p>
</li>
<li><p>163.84 seconds (~ 3 min)</p>
</li>
<li><p>327.68 seconds (~ 5 min)</p>
</li>
<li><p>655.36 seconds (~ 11 min)</p>
</li>
<li><p>1310.72 seconds (~22 min)</p>
</li>
<li><p>2621.44 seconds (~44 min)</p>
</li>
<li><p>5242.88 seconds (~87 min)</p>
</li>
<li><p>10485.76 seconds (~175 min)</p>
</li>
</ul>
<h3 id="使用eDRX"><a href="#使用eDRX" class="headerlink" title="使用eDRX"></a>使用eDRX</h3><p>eDRX的支持因运营商而异。设备向网络请求一个给定的eDRX周期；网络使用实际使用的eDRX周期和PTW(巡护时间窗口)应答</p>
<p>启用eDRX不会对模块发送数据的能力产生负面影响，但是会关闭对所配置的周期间隔的接收，从而节约电能</p>
<p>T-Mobile支持所有文档(见表10.5.5.32 3GPP TS 24.008)值的窄带eDRX循环，NB-S1模式，范围从~20s (20.48s)到~3hrs (10485.76s)。值由表单的位串表示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>“0010”</td>
<td>20.48s</td>
</tr>
<tr>
<td>“0011”</td>
<td>40.96s</td>
</tr>
<tr>
<td>“0101”</td>
<td>81.92s</td>
</tr>
<tr>
<td>“1001”</td>
<td>163.84s</td>
</tr>
<tr>
<td>“1010”</td>
<td>327.68s</td>
</tr>
<tr>
<td>“1011”</td>
<td>655.36s</td>
</tr>
<tr>
<td>“1100”</td>
<td>1310.72s</td>
</tr>
<tr>
<td>“1101”</td>
<td>2621.44s</td>
</tr>
<tr>
<td>“1101”</td>
<td>2621.44s</td>
</tr>
<tr>
<td>“1110”</td>
<td>5242.88s</td>
</tr>
<tr>
<td>“1111”</td>
<td>10485.76s (~175min)</td>
</tr>
</tbody>
</table>
</div>
<p>根据您的产品使用的NB-IoT模块，请求的eDRX周期可以存储在非易失性内存中，并在会话之间保持。模块通常支持禁用eDRX和一个后续的AT命令，以及一个恢复默认值的选项</p>
<p>要在u-blox SARA-N410-02b和Quectel BG96上为NB模块配置eDRX，可以使用AT+CEDRXS命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AT+CEDRXS=2,5,&quot;1001&quot;</span><br></pre></td></tr></table></figure>
<p>这要求在窄带(5)的URC反馈(2)和163.84s(“1001”)的eDRX循环时间下启用eDRX</p>
<p>如果配置了URC，网络将通过重复请求的周期间隔以及实际有效的周期间隔和网络指定的PTW时间来响应。上述命令的一个URC示例是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+CEDRXP: [5,&quot;1001&quot;,&quot;1001&quot;,&quot;0111&quot;]</span><br></pre></td></tr></table></figure>
<p>为NB-S1返回的PTW值对应于以下时间：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>“0000”</td>
<td>2.56s</td>
</tr>
<tr>
<td>“0001”</td>
<td>5.12s</td>
</tr>
<tr>
<td>“0010”</td>
<td>7.68s</td>
</tr>
<tr>
<td>“0011”</td>
<td>10.24s</td>
</tr>
<tr>
<td>“0100”</td>
<td>12.8s</td>
</tr>
<tr>
<td>“0101”</td>
<td>15.36s</td>
</tr>
<tr>
<td>“0110”</td>
<td>17.92s</td>
</tr>
<tr>
<td>“0111”</td>
<td>20.48s</td>
</tr>
<tr>
<td>“1000”</td>
<td>23.04s</td>
</tr>
<tr>
<td>“1001”</td>
<td>25.6s</td>
</tr>
<tr>
<td>“1010”</td>
<td>28.16s</td>
</tr>
<tr>
<td>“1011”</td>
<td>30.72s</td>
</tr>
<tr>
<td>“1100”</td>
<td>33.28s</td>
</tr>
<tr>
<td>“1101”</td>
<td>35.84s</td>
</tr>
<tr>
<td>“1110”</td>
<td>38.4s</td>
</tr>
<tr>
<td>“1111”</td>
<td>40.96s</td>
</tr>
</tbody>
</table>
</div>
<p>以下命令用于禁用eDRX的窄带</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AT+CEDRXS=0,5</span><br></pre></td></tr></table></figure>
<p>eDRX被0标记，而窄带被5标记</p>
]]></content>
      <categories>
        <category>协议</category>
        <category>3GPP</category>
        <category>NB-IoT</category>
      </categories>
      <tags>
        <tag>3GPP</tag>
        <tag>NB-IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenAI Five[译]</title>
    <url>/2019/09/02/OpenAI-Five-%E8%AF%91/</url>
    <content><![CDATA[<p>待续~</p>
<p>我们的OpenAI Five神经网络团队，已经开始击败业余的Dota2人类团队。虽然今天我们仍然存在一些限制，但我们的目标是在今年8月份的国际邀请赛上在有限的英雄上击败一只顶尖的专业战队。我们不一定会成功：dota 2是世界上最受欢迎和最复杂的电子竞技游戏之一，拥有富有创造力和积极性的专业人士，他们全年都在训练，以赢得dota每年4000万美元奖金池(所有电子竞技游戏中最大的一个)的一部分</p>
<p>OpenAI Five每天能够学习和它自己对战180年的有效游戏。它在一个放大版的<a href="https://openai.com/blog/openai-baselines-ppo/">PPO(Proximal Policy Optimization)</a>上训练，有256个GPU和128000个CPU。对每个英雄使用一个单独的LSTM，不使用人类数据，它学习可识别的策略</p>
<p>为了衡量我们的程序，我们将在8月5日举办一场与顶级战队的比赛</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>人工智能的一个里程碑是在复杂的电子游戏中超越人类的能力，比如星际争霸或DOTA。与以前的人工智能里程碑(如象棋或围棋)相比，复杂的电子游戏开始捕捉现实世界的混乱和连续性。我们希望能够解决复杂电子游戏的系统是高度通用的，能够应用于游戏之外</p>
<p>Dota2是一款两个队伍各五名队员的实时策略性游戏，每个选手控制一个英雄。能够玩Dota的AI必须掌握以下内容：</p>
<ul>
<li><strong>长时间范围</strong> Dota游戏以每秒30帧运行，平均每局45分钟，大概8000个时间点。大多数动作(比如命令英雄移动到某个地点)都会产生独立的轻微影响，但是一些独立的动作会在影响游戏的战略走向，例如TP；有些策略可以在整个游戏中发挥作用。OpenAI每4帧观察一次，产生2000次移动。象棋通常在40步之前结束，围棋一般是150步之内，每一步都是战略性的</li>
<li><strong>局部观察状态</strong> 单位和建筑物只能看到它们附近的区域。地图的其余部分被大雾笼罩，隐藏着敌人及其战略。赢得游戏需要根据不完整的数据做出推论，以及模拟对手可能要做的事情。下棋和围棋都是全信息游戏</li>
<li><strong>高维连续动作空间</strong> 在DOTA中，每个英雄可以采取几十个行动，许多行动针对的是另一个单位或地面上的一个位置。我们将空间离散为每个英雄17万个可能的动作(并非所有的每一个勾选都有效，例如在冷却时使用法术)；不计算连续部分，平均每个时间点有1000个有效动作。象棋和围棋的平均动作数是35和250</li>
<li><strong>高维连续观测空间</strong> Dota是在一张连续的大地图上玩的，地图上有十个英雄、几十个建筑物、几十个NPC单位、符文、树木、防御区等。我们的模型通过V社的bot API观察到一个Dota游戏的状态，即20000个(大部分是浮点)数字代表一个人可以访问的所有信息。一个象棋棋盘表示为大约70个枚举值(一个由6个棋子类型和次要历史信息组成的8x8棋盘)；围棋棋盘大约400个枚举值</li>
</ul>
<p>Dota规则也非常复杂——游戏已经开发了十多年，游戏逻辑在数十万行代码中实现。这种逻辑每执行一个标记需要毫秒，而国际象棋或围棋引擎则需要纳秒。游戏每两周更新一次，不断改变环境语义</p>
<h2 id="我们的方法"><a href="#我们的方法" class="headerlink" title="我们的方法"></a>我们的方法</h2><p>我们的系统学习使用大规模的PPO。Openai Five和我们早期的1v1机器人都完全是从自我游戏中学习的，它们从随机参数开始，不使用搜索或从人类replay中学习</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>OPENAI 1V1 BOT</th>
<th>OPENAI FIVE</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPUs</td>
<td>60,000 CPU cores on Azure</td>
<td>128,000 preemptible CPU cores on GCP</td>
</tr>
<tr>
<td>GPUs</td>
<td>256 K80 GPUs on Azure</td>
<td>256 P100 GPUs on GCP</td>
</tr>
<tr>
<td>收集经验</td>
<td>~300 years per day</td>
<td>~180 years per day (~900 years per day counting each hero separately)</td>
</tr>
<tr>
<td>观测规模</td>
<td>~3.3 kB</td>
<td>~36.8 kB</td>
</tr>
<tr>
<td>每秒游戏观察数</td>
<td>10</td>
<td>7.5</td>
</tr>
<tr>
<td>批量大小</td>
<td>8,388,608 observations</td>
<td>1,048,576 observations</td>
</tr>
<tr>
<td>每分钟批量数</td>
<td>~20</td>
<td>~60</td>
</tr>
</tbody>
</table>
</div>
<p>RL研究人员(包括我们自己)普遍认为，长时间范围学习需要从根本上取得新的进展，例如分层强化学习。我们的结果表明，我们没有给予今天的算法足够的信任——至少当它们以足够的规模运行并且有合理的探索方法时</p>
<p>我们的代理被训练为最大化未来报酬的指数衰减总和，用一个称为γ的指数衰减因子进行加权。在最新的Openai Five训练中，我们将γ从0.998(以46秒的半衰期评估未来奖励)退火到0.9997(以5分钟的半衰期评估未来奖励)。相比之下，PPO纸中最长的地平线是0.5秒的半衰期，彩虹纸中最长的地平线是4.4秒的半衰期，观察和进一步观察纸使用46秒的半衰期</p>
<p>虽然目前版本的Openai Five在最后一次攻击时很弱(观察我们的测试赛，专业的Dota评论员blitz估计它大约是Dota玩家的中位数)，但它的目标优先级符合一个通用的专业策略。获得长期奖励，如战略地图控制，往往需要牺牲短期奖励，如从农业中获得的黄金，因为分组攻击塔需要时间。这一观察加强了我们的信念，即系统确实是在长期优化</p>

<iframe width="720" height="405" src="https://www.youtube.com/embed/UZHTNBMAfAA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>Openai Five的每个网络都包含一个单层的1024单元的LSTM，它可以看到当前的游戏状态(从V社的bot API中提取)，并通过几个可能的动作头发出动作。每个头部都具有语义意义，例如，延迟此动作的节拍数、要选择的动作、该动作在单位周围网格中的X或Y坐标等。动作头部是独立计算的。</p>
<p>Openai Five使用的观察空间和行动空间的交互演示。OpenAIFive将世界视为20000个数字的列表，并通过发出8个枚举值的列表来执行操作。选择不同的行动和目标，了解OpenAIFive如何编码每个行动，以及它如何观察世界。这幅图像显示了一个人类看到的场景</p>
<p><img src="OpenAI-Five-译/images/OpenAI-01.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-01.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-02.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-03.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-04.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-05.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-06.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-07.png" alt><br><img src="OpenAI-Five-译/images/OpenAI-08.png" alt></p>
<p>OpenAI Five可以对与它所看到的相关的缺失状态片段做出反应。例如，直到最近，Openai Five的观测还没有包括弹片区(弹丸落在敌人身上的区域)，人是可以显而易见看到的。然而，我们观察到Openai Five正在学习走出(尽管不能避免进入)主动弹片区，因为它可以看到它的健康在下降</p>
<h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><p>给出了一个能够处理长视距的学习算法，我们仍然需要探索环境。即使有了我们的限制，仍然有数百个物品、几十个建筑、法术和单位类型，以及一个需要学习的游戏机制的长尾——其中许多都会产生强大的组合。有效地探索这个组合广阔的空间并不容易</p>
<p>Openai Five通过自己和自己对战学习(从随机权重开始)，为探索和学习提供了一个很自然的环境。为了避免“战略崩溃”，代理训练80%的游戏与自己对抗，另外20%与过去的自己对抗。在第一场比赛中，英雄们漫无目的地在地图上走来走去。经过几个小时的训练，诸如farm或中途战斗等概念应运而生。几天之后，他们一直采用基本的人类策略：试图从对手那里偷取赏金符文，走到他们的一级塔去野区farm，并围绕地图游走以获得优势。经过进一步的训练，他们能够熟练运用5英雄推进等高级策略。</p>
<p>在2017年3月，我们的第一个代理打败了机器人，但与人类混淆了。为了在战略空间进行强行探索，在训练期间(并且仅在训练期间)，我们随机化了部队的属性(健康、速度、起始水平等)，然后开始击败人类。后来，当一个测试玩家持续击败我们的1v1机器人时，我们增加了我们的训练随机化，测试玩家开始输了。我们的机器人团队同时将类似的随机化技术应用于物理机器人，以从模拟转移到现实世界</p>
<p>OpenAI Five使用我们为1v1机器人编写的随机化方法。它还使用了新的分路方法。在每一个训练游戏开始时，我们随机“分配”每个英雄到一些道路的子集，并惩罚它从这些道路偏离直到游戏中随机选择的时间</p>
<p>好的奖励也有助于探索。我们的奖励主要是由人类跟踪以决定他们在游戏中的表现的指标组成：净值、杀戮、死亡、助攻、最后一击等等。我们通过减去其他团队的平均奖励来对每个代理的奖励进行后处理，以防止代理发生正和情况。我们对项目和技能构建进行硬编码(最初是为我们的脚本基线编写的)，并随机选择要使用的构建。Courier管理也从脚本化基线导入</p>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>OpenAI Five不包含英雄神经网络之间的明确通信通道。团队合作是由我们称之为“团队精神”的超参数控制的。团队精神的范围从0到1，这就决定了Openai Five的英雄们应该关心他们各自的奖励功能，而不是团队的平均奖励功能。我们通过训练将其值从0退火到1</p>
<h3 id="Rapid"><a href="#Rapid" class="headerlink" title="Rapid"></a>Rapid</h3><p>我们的系统是一个通用的RL培训系统，称为Rapid，可应用于任何Gym环境。我们已经使用了快速解决其他问题在OpenAI，包括竞争自我发挥</p>
]]></content>
      <categories>
        <category>ML</category>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DOTA</tag>
        <tag>译</tag>
        <tag>OpenAI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Program Skill</title>
    <url>/2019/07/31/Python-Program-Skill/</url>
    <content><![CDATA[<p>本文记录一些实际工作中使用到的Python语言编程技巧，或者学到的一些好用的用法</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="矩阵按某列排序"><a href="#矩阵按某列排序" class="headerlink" title="矩阵按某列排序"></a>矩阵按某列排序</h3><p>应用场景：</p>
<ul>
<li>线性回归<br>做线性回归时，要拟合某个变量与输出的关系曲线，如果输入训练集在该变量的维度上是乱序的，拟合出的不是曲线，而是一团乱序的线。因此需要以该变量重排列</li>
</ul>
<p>方法：</p>
<ul>
<li>np.argsort</li>
<li>sorted &amp; lambda</li>
</ul>
<h4 id="np-argsort"><a href="#np-argsort" class="headerlink" title="np.argsort"></a>np.argsort</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">_sort_idx = np.argsort(x[:,<span class="number">0</span>])  <span class="comment"># 按第0列升序排序</span></span><br><span class="line">x = x[_sort_idx].tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">col_sort</span>(<span class="params">x, col</span>):</span></span><br><span class="line">    _x, _sort_idx = np.array(x), np.argsort(_x[:,col])</span><br><span class="line">    <span class="keyword">return</span> _x[_sort_idx].tolist()</span><br></pre></td></tr></table></figure>
<p>np.argsort()方法可以获取升序(默认)排序后的索引</p>
<h4 id="sorted-amp-lambda"><a href="#sorted-amp-lambda" class="headerlink" title="sorted &amp; lambda"></a>sorted &amp; lambda</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example</span></span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">x = <span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">x = [&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>&#125;]</span><br><span class="line">x = <span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> x:x[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">col_sort</span>(<span class="params">x, col</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> x:x[col])</span><br></pre></td></tr></table></figure>
<p>这种方法输入矩阵每行可以是一个<code>list</code>，也可以是<code>dict</code></p>
]]></content>
      <categories>
        <category>Program Language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python通过注册表获取串口列表</title>
    <url>/2022/03/07/Python%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E4%B8%B2%E5%8F%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>工作中需要使用CameraLink协议中的串口和设备进行通信，DALSA采集卡软件中可以将该串口映射到一个COM口上，但是该COM口在Windows的设备管理器中无法识别。使用Python的serial模块或者npm的serialport模块自带枚举函数都无法获取到该COM口。</p>
<p>JavaScript中，使用以下代码定时轮询串口列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> serialport <span class="keyword">from</span> <span class="string">&#x27;serialport&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    serialport.list().then(</span><br><span class="line">        <span class="function"><span class="params">ports</span> =&gt;</span> &#123;</span><br><span class="line">	        <span class="keyword">if</span> (ports.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			    <span class="comment">/* do something */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<p>Python中，使用以下代码获取串口列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line"></span><br><span class="line">plist = <span class="built_in">list</span>(serial.tools.list_ports.comports())</span><br><span class="line">ports = [p.name <span class="keyword">for</span> p <span class="keyword">in</span> plist]</span><br></pre></td></tr></table></figure>
<p>以上方式都无法获取采集卡映射的COM口。Python中可以使用win32api和win32con通过枚举注册表中的信息来获取串口列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serial_ports</span>():</span></span><br><span class="line">    ports = []</span><br><span class="line">    key = win32api.RegOpenKey(win32con.HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;HARDWARE\DEVICEMAP\SERIALCOMN&quot;</span>, <span class="number">0</span>, win32con.KEY_READ)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            name, value, type1 = win32api.RegEnumValue(key, i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;name:&#123;&#125; value:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(name, value))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            ports.append(value)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;except&#x27;</span>)</span><br><span class="line">    win32api.RegCloseKey(key)</span><br><span class="line">    <span class="keyword">return</span> ports</span><br></pre></td></tr></table></figure>
<p>使用<code>RegOpenKey</code>接口来读取键值，使用完毕后需要用<code>RegCloseKey</code>关闭。通过<code>RegEnumValue</code>来枚举串口列表，COM口名称在value字段</p>
]]></content>
  </entry>
  <entry>
    <title>Raspberry-Pi-4-Board</title>
    <url>/2019/07/25/Raspberry-Pi-4-Board/</url>
    <content><![CDATA[<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>目前很多资料还不全面，官网发布的原理图也只有一小部分</p>
<ul>
<li><a href="/download/Raspberry-Pi-4-Board/Raspberry-Pi-4-Product-Brief.pdf">product Brief (PDF)</a></li>
<li><a href="/download/Raspberry-Pi-4-Board/rpi_SCH_4b_4p0_reduced.pdf">Schematics (PDF)</a></li>
<li>Power <a href="/download/Raspberry-Pi-4-Board/mxl7704.pdf">MxL7704 Datasheet (PDF)</a></li>
<li>Ethernet <a href="/download/Raspberry-Pi-4-Board/5421-PB05-R.pdf">BCM5421 Datasheet (PDF)</a></li>
<li>USB Host Controller <a href="/download/Raspberry-Pi-4-Board/20120517130647131.pdf">VL805 Datasheet (PDF)</a></li>
<li>Memory <a href="/download/Raspberry-Pi-4-Board/16Gb_32Gb_x4_x8_3DS_DDR4_SDRAM.pdf">MT53D1024M32D4DT-053 WT:D Datasheet (PDF)</a></li>
</ul>
<h2 id="Power"><a href="#Power" class="headerlink" title="Power"></a>Power</h2><p>Raspberry Pi 4 使用USB-C供电，其使用的电源管理芯片是MaxLinear公司的MxL7704</p>
<p>MxL7704是一款五输出通用PMIC(Power Management IC)，针对为低功耗FPGA、DSP和微处理器供电。其内部有4个同步降压调节器，可将5V输入调节成不同压降的输出，1路LDO+4路Buck。有一个I2C接口用于配置各路降压step，读取状态信息</p>
<p>封装图<br><img src="/2019/07/25/Raspberry-Pi-4-Board/image/board-power-01.png" alt="MxL7704封装"></p>
<p>树莓派4 USB-C供电部分<br><img src="/2019/07/25/Raspberry-Pi-4-Board/image/board-power-02.png" alt="Power"><br><img src="/2019/07/25/Raspberry-Pi-4-Board/image/board-power-03.png" alt="Power"></p>
<p>可看到<code>PD_SENSE</code>接到MxL7704的<code>AN1</code>引脚，<code>AN2</code>接地未使用，<code>INT_SCL</code>和<code>INT_SDA</code>两根I2C数据线应该是接到BCM2711，<code>GLOBAL_EN</code>信号用于控制MxL7704的使能，<code>RUN_PG2</code>连接到<code>PG2</code>引脚用来监控芯片是否工作正常</p>
<p>5路输出分别为</p>
<ul>
<li>LDO —&gt; 3V3_AUD(3.3V) 这应该是给音频供电的</li>
<li>VOUT1 —&gt; LX1(3.3V/1.7A) 未知</li>
<li>VOUT2 —&gt; LX2(1.8V/2.3A) 未知</li>
<li>VOUT3 —&gt; LX3(1.1V/4.4A) 给DDR供电</li>
<li>VOUT4 —&gt; LX4(5.5A) 给BCM2711供电</li>
</ul>
<h2 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h2><p>Gigabit Ethernet PHY 使用的是Broadcom的BCM54213PE，是一个全集成10Base-T/100Base-TX/1000Base-T的以太网千兆收发器。支持IEEE 802.3、802.3u和802.3ab标准，支持MII、GMII、TBI、RGMII和RTBI接口</p>
<p>树莓派4 Ethernet部分<br><img src="/2019/07/25/Raspberry-Pi-4-Board/image/board-etherner-01.png" alt="Ethernet"></p>
<p>目前原理图未公开GE PHY与BCM2711以哪种接口连接</p>
<h2 id="USB-Host-Controller"><a href="#USB-Host-Controller" class="headerlink" title="USB Host Controller"></a>USB Host Controller</h2><p>USB Host Controller使用的是VLA的LV805，是一个4端口的USB3.0主机控制器，xHCI接口标准</p>
<p>封装图<br><img src="/2019/07/25/Raspberry-Pi-4-Board/image/board-USB-01.png" alt="LV805"></p>
<p>原理图中未公开该部分连接</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>RAM使用的是美光的MT53D1024M32D4DT-053 WT:D，FBGA Code:D9WHV，是一个32Gb的LPDDR4 DRAM，深度为1024Mb，位宽x32</p>
<p>原理图中未公开该部分连接</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>玩</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry-Pi-4-CPU</title>
    <url>/2019/07/25/Raspberry-Pi-4-CPU/</url>
    <content><![CDATA[<p>本文汇总所有和树莓派4代CPU相关材料。树莓派4使用的CPU是博通公司的BCM2711，该芯片的datasheet无论是在博通官网、树莓派官网、google上都搜索不到，可能是还未公开</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>树莓派官网发布的初步<a href="/download/Raspberry-Pi-4-CPU/rpi_DATA_2711_1p0_preliminary.pdf">datasheet</a></p>
<h2 id="CPU-Features"><a href="#CPU-Features" class="headerlink" title="CPU Features"></a>CPU Features</h2><ul>
<li><strong>processor</strong>:  Broadcom BCM2711, Cortex-A72 (ARM v8), quad-core, 64-bit SoC @ 1.5GHz</li>
<li><strong>Memory</strong>： 1GB, 2GB or 4GB LPDDR4</li>
<li><strong>Wi-Fi</strong>: 2.4G/5G, IEEE 802.11b/g/n/ac WLAN</li>
<li><strong>Ethernet</strong>: GE</li>
<li><strong>Bluetooth</strong>: 5.0 with BLE</li>
<li><strong>USB</strong>: 2×USB3.0, 2×USB2.0</li>
<li><strong>GPIO</strong>: 40-pin, support multiplex(UART、I2C、SPI、SDIO、DPI、PCM、PWM、GPCLK)</li>
<li><strong>Video &amp; sound</strong>:<ul>
<li>2×micro HDMI ports(up to 4Kp60 supported)</li>
<li>2-lane MIPI DSI display port</li>
<li>2-lane MIPI CSI camera port</li>
<li>4-pole stereo audio and composite video port</li>
</ul>
</li>
<li><strong>Multimedia</strong>: H.265(4Kp60 decode), H.264(1080p60 decode, 1080p30 encode), OpenGL ES, 3.0 graphics</li>
<li><strong>SD Card</strong>: 1×</li>
<li><strong>Input power</strong>:<ul>
<li>5V DC via USB-C connector(min 3A)</li>
<li>5V DC via GPIO header (min 3A)</li>
<li>PoE IEEE 802.3af</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>玩</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry-Pi-4-benchmark</title>
    <url>/2019/07/23/Raspberry-Pi-4-benchmark/</url>
    <content><![CDATA[<p>(待续)</p>
<p>tom’s HARDWARE 发布了一篇关于树莓派4的<a href="https://www.tomshardware.com/reviews/raspberry-pi-4-b,6193.html">benchmark</a>文章，详细介绍了对其多项测试方法和结果</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="Linpack-Benchmark"><a href="#Linpack-Benchmark" class="headerlink" title="Linpack Benchmark"></a>Linpack Benchmark</h3><p>CPU性能测试使用了Linpack Benchmark，<br>Linkpack Benchmark 是对计算机浮点执行率的度量。它是通过运行一个求解密集线性方程组的计算机程序来确定的</p>
<p><a href="chrome-extension://ecabifbgmdmgdllomnfinbmaellmclnh/data/reader/index.html?id=121">Linkpark Q&amp;A</a></p>
<h3 id="Sysbench-CPU-test"><a href="#Sysbench-CPU-test" class="headerlink" title="Sysbench CPU test"></a>Sysbench CPU test</h3><p>sysbench的cpu测试是在指定时间内，循环进行素数计算</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>内存是做吞吐量测试，读写1M的内存块，看每秒的读写速度</p>
<h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><p>分别查看单进程和多进程下的压缩速度</p>
<h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><h3 id="openArena-Benchmark"><a href="#openArena-Benchmark" class="headerlink" title="openArena Benchmark"></a>openArena Benchmark</h3><p>openArena是一款需要GPU渲染的游戏，通过固定分辨率下查看平均帧率，来评估GPU性能</p>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>查看吞吐量，每秒的读写能力</p>
<h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><p>吞吐量测试</p>
<h3 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h3><p>吞吐量测试</p>
<h2 id="Power"><a href="#Power" class="headerlink" title="Power"></a>Power</h2><h3 id="Power-Draw-benchmark"><a href="#Power-Draw-benchmark" class="headerlink" title="Power Draw benchmark"></a>Power Draw benchmark</h3><p>分别看负载和空闲状态下的功耗</p>
<h3 id="Thermal-Throttling-Benchmark"><a href="#Thermal-Throttling-Benchmark" class="headerlink" title="Thermal Throttling Benchmark"></a>Thermal Throttling Benchmark</h3><h2 id="4K"><a href="#4K" class="headerlink" title="4K"></a>4K</h2><h3 id="FFmpeg-Test"><a href="#FFmpeg-Test" class="headerlink" title="FFmpeg Test"></a>FFmpeg Test</h3><h2 id="Web-Surfing"><a href="#Web-Surfing" class="headerlink" title="Web Surfing"></a>Web Surfing</h2><h3 id="Jetstream-1-1"><a href="#Jetstream-1-1" class="headerlink" title="Jetstream 1.1"></a>Jetstream 1.1</h3><h2 id="Web-Hosting"><a href="#Web-Hosting" class="headerlink" title="Web Hosting"></a>Web Hosting</h2><h2 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h2><h2 id="Compiling-Code"><a href="#Compiling-Code" class="headerlink" title="Compiling Code"></a>Compiling Code</h2>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>玩</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>performance</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>ReverseLinkList</title>
    <url>/2019/07/16/ReverseLinkList/</url>
    <content><![CDATA[<h1 id="Reverse-Link-List"><a href="#Reverse-Link-List" class="headerlink" title="Reverse Link List"></a>Reverse Link List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>单向链表反向，输入为 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，输出为5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL </p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遍历一次，单次循环中将遍历的元素next指向上一个元素</p>
<ul>
<li>关键点：需要3个指针，一个前向指针prev用于指向当前遍历元素的上一个元素；当前遍历元素指针；由于修改了当前元素的next指针，因此需要一个后向指针next，提前保存下一个元素地址</li>
<li>特殊情况：当链表元素只有头或者2个元素时</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">list_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; list_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">list_node_empty</span><span class="params">(struct _list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_node_init</span><span class="params">(struct _list_node *head, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head-&gt;x = x;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct _list_node *<span class="title">list_node_tail</span><span class="params">(struct _list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">list_node</span> *<span class="title">p</span> =</span> head;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_node_append</span><span class="params">(struct _list_node *<span class="keyword">new</span>, struct _list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">list_node</span> *<span class="title">tail</span>;</span></span><br><span class="line">	</span><br><span class="line">	tail = list_node_tail(head);</span><br><span class="line">	tail-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_node_foreach(pos, head)		\</span></span><br><span class="line"><span class="meta">	for (pos = (head);				        \</span></span><br><span class="line"><span class="meta">		 pos != NULL;						\</span></span><br><span class="line"><span class="meta">		 pos = pos-&gt;next)					\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct _list_node *<span class="title">list_node_revert</span><span class="params">(struct _list_node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">list_node</span> *<span class="title">p_prev</span>=</span>head, *p, *p_next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	</span><br><span class="line">	p = head-&gt;next;</span><br><span class="line">	p_prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p_next = p-&gt;next;</span><br><span class="line">		p-&gt;next = p_prev;</span><br><span class="line">		p_prev = p;</span><br><span class="line">		p = p_next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p_prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_node *p, *revert;</span><br><span class="line">    list_node head, node1, node2, node3, node4;	</span><br><span class="line">    </span><br><span class="line">    list_node_init(&amp;head, <span class="number">1</span>);</span><br><span class="line">    list_node_init(&amp;node1, <span class="number">2</span>);</span><br><span class="line">	list_node_init(&amp;node2, <span class="number">3</span>);</span><br><span class="line">	list_node_init(&amp;node3, <span class="number">4</span>);</span><br><span class="line">	list_node_init(&amp;node4, <span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">    list_node_append(&amp;node1, &amp;head);</span><br><span class="line">	list_node_append(&amp;node2, &amp;head);</span><br><span class="line">	list_node_append(&amp;node3, &amp;head);</span><br><span class="line">	list_node_append(&amp;node4, &amp;head);</span><br><span class="line"></span><br><span class="line">	list_node_foreach(p, &amp;head) &#123;</span><br><span class="line">		log_debug(<span class="string">&quot;data:%d&quot;</span>, p-&gt;x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    revert = list_node_revert(&amp;head);</span><br><span class="line"></span><br><span class="line">    list_node_foreach(p, revert) &#123;</span><br><span class="line">		log_debug(<span class="string">&quot;data:%d&quot;</span>, p-&gt;x);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    cur, pre = head, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        cur.<span class="built_in">next</span>, pre, cur = pre, cur, cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> pre    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getListTail</span>(<span class="params">head</span>):</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> (curr.<span class="built_in">next</span>):</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendList</span>(<span class="params">item, head</span>):</span></span><br><span class="line">    tail = getListTail(head)</span><br><span class="line">    tail.<span class="built_in">next</span>, item.<span class="built_in">next</span> = item, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">list_head = ListNode(<span class="number">1</span>)</span><br><span class="line">data1 = ListNode(<span class="number">2</span>)</span><br><span class="line">data2 = ListNode(<span class="number">3</span>)</span><br><span class="line">data3 = ListNode(<span class="number">4</span>)</span><br><span class="line">data4 = ListNode(<span class="number">5</span>)</span><br><span class="line">appendList(data1, list_head)</span><br><span class="line">appendList(data2, list_head)</span><br><span class="line">appendList(data3, list_head)</span><br><span class="line">appendList(data4, list_head)</span><br><span class="line"></span><br><span class="line">curr = list_head</span><br><span class="line"><span class="keyword">while</span> (curr):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(curr.val))</span><br><span class="line">    curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">reverse = reverseList(list_head)</span><br><span class="line">curr = reverse</span><br><span class="line"><span class="keyword">while</span> (curr):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(curr.val))</span><br><span class="line">    curr = curr.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>python代码可利用一个赋值语句对多个对象赋值特性，省略后向指针</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-socket关闭后端口仍然占用</title>
    <url>/2019/07/25/TCP-socket%E5%85%B3%E9%97%AD%E5%90%8E%E7%AB%AF%E5%8F%A3%E4%BB%8D%E7%84%B6%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<p>在使用TCP做一些数据传输的测试时发现，Server端程序关闭再启动时常常会出现该地址或端口已被占用的错误(关闭时socket已经释放)，如下是python脚本执行时错误打印：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;server.py&quot;, line 35, in &lt;module&gt;</span><br><span class="line">    sock.bind((host, port))</span><br><span class="line">  File &quot;/usr/lib64/python2.7/socket.py&quot;, line 224, in meth</span><br><span class="line">    return getattr(self._sock,name)(*args)</span><br><span class="line">socket.error: [Errno 98] Address already in use</span><br></pre></td></tr></table></figure></p>
<p>关闭脚本使用的是”Ctrl+C”按键组合，代码中会监听<code>SIGINT</code>信号，在信号处理函数中关闭Server socket<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">signal_num,frame</span>):</span></span><br><span class="line">    <span class="keyword">global</span> sock</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\nYou Pressed Ctrl-C. Exit&quot;</span></span><br><span class="line">    sock.shutdown(socket.SHUT_RDWR)</span><br><span class="line">    sock.close()</span><br><span class="line">    sys.exit(signal_num)</span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br></pre></td></tr></table></figure></p>
<p>为什么已经释放的socket再次绑定时会出现地址被占用的错误？</p>
<p>使用netstat命令查看占用的端口，发现存在一个处于<code>TIME_WAIT</code>的连接<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost awokezhou]# netstat -tn | grep &quot;9091&quot;</span><br><span class="line">tcp        0      0 172.16.79.132:9091      172.16.79.182:64775     TIME_WAIT</span><br></pre></td></tr></table></figure></p>
<h2 id="TCP连接状态"><a href="#TCP连接状态" class="headerlink" title="TCP连接状态"></a>TCP连接状态</h2><p>查看RFC-793文档，阅读了其中和TCP状态转换相关的内容</p>
<h3 id="Connect-States"><a href="#Connect-States" class="headerlink" title="Connect States"></a>Connect States</h3><p>RFC-793中定义了一个TCP Connect在其生命周期的所有状态，原文如下</p>
<ul>
<li><strong>LISTEN</strong> represents waiting for a connection request from any remote TCP and port</li>
<li><strong>SYN-SENT</strong> represents waiting for a matching connection request after having sent a connection request</li>
<li><strong>SYN-RECEIVED</strong> represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request</li>
<li><strong>ESTABLISHED</strong> represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection</li>
<li><strong>FIN-WAIT-1</strong> represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent</li>
<li><strong>FIN-WAIT-2</strong> represents waiting for a connection termination request from the remote TCP</li>
<li><strong>CLOSE-WAIT</strong> represents waiting for a connection termination request from the local user</li>
<li><strong>CLOSING</strong> represents waiting for a connection termination request acknowledgment from the remote TCP</li>
<li><strong>LAST-ACK</strong> represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request)</li>
<li><strong>TIME-WAIT</strong> represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request</li>
<li><strong>CLOSED</strong> represents no connection state at all</li>
</ul>
<p>一个TCP连接共有11种状态：LISTEN、SYN-SEND、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT和CLOSED</p>
<p>重点关注和连接关闭有关的几个状态</p>
<ul>
<li><strong>FIN-WAIT-1</strong> 等待远端的连接终止请求，或者等待自己发送的连接终止请求被远端确认</li>
<li><strong>FIN-WAIT-2</strong> 等待远端的连接终止请求</li>
<li><strong>CLOSE-WAIT</strong> 等待本地用户的连接终止请求</li>
<li><strong>CLOSING</strong> 等待自己发送的连接终止请求被远端确认</li>
<li><strong>LAST-ACK</strong> 等待自己发送的连接终止请求被远端确认</li>
<li><strong>TIME-WAIT</strong> 表示等待足够的时间以确保远端收到自己的终止请求确认</li>
<li><strong>CLOSED</strong> 表示连接已经被完全关闭</li>
</ul>
<p>只从字面意思理解，这几个状态有很多相似的地方，并不能理解到每个状态位于什么阶段</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>RFC-793文档中有一个TCP连接的状态转换示意图<br><img src="/2019/07/25/TCP-socket%E5%85%B3%E9%97%AD%E5%90%8E%E7%AB%AF%E5%8F%A3%E4%BB%8D%E7%84%B6%E5%8D%A0%E7%94%A8/image/tcp-socket-release-error-01.png" alt="状态转移示意图"></p>
<p>由该图可以看出以下区别</p>
<ul>
<li><strong>FIN-WAIT-1</strong> 有两种情况会触发该状态：<ul>
<li>Server端在接收到Client端的连接请求后就主动关闭连接，向Client发送FIN后立即进入<code>FIN-WAIT-1</code>状态</li>
<li>建立连接后(双方都进入<code>ESTABLISHED</code>)，任何一方主动关闭连接，向对端发送FIN后立即进入<code>FIN-WAIT-1</code>状态</li>
</ul>
</li>
<li><strong>FIN-WAIT-2</strong> 只有处于<code>FIN-WAIT-1</code>的一方收到对方的FIN ACK后，立即进入该状态</li>
<li><strong>CLOSE-WAIT</strong> 建立连接后，收到远端FIN后，回复FIN ACK，立即进入该状态</li>
<li><strong>CLOSING</strong> 只有处于<code>FIN-WAIT-1</code>的一方收到对方FIN后，进入该状态</li>
<li><strong>LAST-ACK</strong> 只有处于<code>CLOSE-WAIT</code>的一方主动关闭连接，向对方发送FIN后，进入该状态</li>
<li><strong>TIME-WAIT</strong> 只有处于<code>FIN-WAIT-12</code>的一方收到对方FIN后，进入该状态</li>
</ul>
<p>按照该图的状态转移流程，其实主要的转移路线有以下两条：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FIN-WAIT-1 --&gt; FIN-WAIT-2 --&gt; TIME-WAIT --&gt; CLOSED</span><br><span class="line">CLOSE-WAIT --&gt; LAST-ACK --&gt; CLOSED</span><br></pre></td></tr></table></figure></p>
<p>这两条路线的区别在于谁先发起连接终止请求，也就是谁先关闭socket</p>
<h3 id="MSL"><a href="#MSL" class="headerlink" title="MSL"></a>MSL</h3><p>先关闭连接的一方最终会进入<code>TIME-WAIT</code>状态，由<code>TIME-WAIT</code>状态切换到<code>CLOSED</code>状态，但是中间需要等待一个超时时间2MSL。正是由于这个2MSL超时时间的存在，导致Server再次bind时发生错误</p>
<p>提出以下3个问题</p>
<ul>
<li>什么是MSL，为什么需要MSL？</li>
<li>先关闭的一方，接收到对端的FIN，发送FIN ACK后直接释放连接资源不行吗，为什么需要等待2个MSL时间？</li>
<li>后关闭的一方，为什么不需要MSL？</li>
</ul>
<h4 id="什么是MSL"><a href="#什么是MSL" class="headerlink" title="什么是MSL"></a>什么是MSL</h4><p>MSL英文全称是”Maximum Segment Lifetime”，即TCP片的最大存活时间</p>
<p>RFC-793原文中对于MSL的解释如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Knowing When to Keep Quiet</span><br><span class="line"></span><br><span class="line">To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by</span><br><span class="line">an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before</span><br><span class="line">assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers</span><br><span class="line">in use was lost. For this specification the MSL is taken to be 2 minutes. This is an engineering choice, and</span><br><span class="line">may be changed if experience indicates it is desirable to do so. Note that if a TCP is reinitialized in some</span><br><span class="line">sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure</span><br><span class="line">to use sequence numbers larger than those recently used.</span><br></pre></td></tr></table></figure><br>大意为：为了确保TCP不会创建一个序列号与网络中已经存在的分片序列号重复的分片，在分配新的序列号之前必须在MSL时间内保持静默。标准规定的MSL时间为2分钟，是一个基于工程经验的选择</p>
<h4 id="TIME-WAIT后为什么需要等待2个MSL？"><a href="#TIME-WAIT后为什么需要等待2个MSL？" class="headerlink" title="TIME-WAIT后为什么需要等待2个MSL？"></a><code>TIME-WAIT</code>后为什么需要等待2个MSL？</h4><p>为了保证处于<code>FIN-WAIT-2</code>状态(记为A)时发送的最后一个ACK能够到达对端(记为B)。最后一个ACK可能在网络中丢失，使得B处于<code>LAST-ACK</code>状态无法进入<code>CLOSED</code>状态。B会超时重传这个FIN，A发送ACK丢失+B重传FIN到达A，这个时间刚好是2倍的MSL</p>
<h4 id="后关闭的一方，为什么不需要2MSL？"><a href="#后关闭的一方，为什么不需要2MSL？" class="headerlink" title="后关闭的一方，为什么不需要2MSL？"></a>后关闭的一方，为什么不需要2MSL？</h4><p>2MSL本质上是在等待最后一个ACK，后关闭的一方是FIN的发送方，等待ACK，有重传机制作保障，其状态是可控的，因此不需要其他等待超时</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><ul>
<li><strong>Server端</strong> centos7虚拟机，IP地址172.16.79.132, python2.7，创建socket绑定localhost、9091端口</li>
<li><strong>Client端</strong> windows10，IP地址172.16.79.182，python2.7，创建socket向Server发起连接</li>
<li>linux 使用如下命令查看连接状态<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tn | grep &#x27;9091&#x27;</span><br></pre></td></tr></table></figure></li>
<li>windows使用如下命令查看连接状态<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tn | findstr &#x27;9091&#x27;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>Server创建socket代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">host = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">port = <span class="number">9091</span></span><br><span class="line">s.bind((host, port))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c, addr = s.accept()</span><br></pre></td></tr></table></figure></p>
<p>Client创建socket并向<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((<span class="string">&#x27;172.16.79.132&#x27;</span>, <span class="number">9091</span>))</span><br></pre></td></tr></table></figure></p>
<p>查看Server连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost awokezhou]# netstat -tn | grep &quot;9091&quot;</span><br><span class="line">tcp        0      0 172.16.79.132:9091      172.16.79.182:51725     ESTABLISHED</span><br></pre></td></tr></table></figure><br>查看Client连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ  netstat -tn | findstr &#x27;9091&#x27;</span><br><span class="line">  TCP    172.16.79.182:51725    172.16.79.132:9091     ESTABLISHED     InHost</span><br></pre></td></tr></table></figure></p>
<p>双方都进入了<code>ESTABLISHED</code>状态，表明连接建立成功</p>
<h3 id="Server先关闭socket"><a href="#Server先关闭socket" class="headerlink" title="Server先关闭socket"></a>Server先关闭socket</h3><p>Server关闭连接<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.close()</span><br></pre></td></tr></table></figure></p>
<p>查看Server连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost awokezhou]# netstat -tn | grep &quot;9091&quot;</span><br><span class="line">tcp        0      0 172.16.79.132:9091      172.16.79.182:51725     FIN_WAIT2</span><br></pre></td></tr></table></figure><br>查看Client连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ  netstat -tn | findstr &#x27;9091&#x27;</span><br><span class="line">  TCP    172.16.79.182:51725    172.16.79.132:9091     CLOSE_WAIT      InHost</span><br></pre></td></tr></table></figure></p>
<p>Client关闭连接<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.close()</span><br></pre></td></tr></table></figure></p>
<p>查看Server连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost awokezhou]# netstat -tn | grep &quot;9091&quot;</span><br><span class="line">tcp        0      0 172.16.79.132:9091      172.16.79.182:51725     TIME_WAIT</span><br></pre></td></tr></table></figure><br>查看Client连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ  netstat -tn | findstr &#x27;9091&#x27;</span><br></pre></td></tr></table></figure></p>
<p>Server最终进入了<code>TIME-WAIT</code>状态，Client连接已经释放。如果此时关闭并重启Server，在调用bind时就会报错</p>
<h3 id="Client先关闭socket"><a href="#Client先关闭socket" class="headerlink" title="Client先关闭socket"></a>Client先关闭socket</h3><p>Client关闭连接<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.close()</span><br></pre></td></tr></table></figure></p>
<p>查看Server连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost awokezhou]# netstat -tn | grep &quot;9091&quot;</span><br><span class="line">tcp        1      0 172.16.79.132:9091      172.16.79.182:51740     CLOSE_WAIT</span><br></pre></td></tr></table></figure><br>查看Client连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ  netstat -tn | findstr &#x27;9091&#x27;</span><br><span class="line">  TCP    172.16.79.182:51740    172.16.79.132:9091     FIN_WAIT_2      InHost</span><br></pre></td></tr></table></figure></p>
<p>Server关闭连接<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.close()</span><br></pre></td></tr></table></figure></p>
<p>查看Server连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost awokezhou]# netstat -tn | grep &quot;9091&quot;</span><br></pre></td></tr></table></figure><br>查看Client连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ  netstat -tn | findstr &#x27;9091&#x27;</span><br><span class="line">  TCP    172.16.79.182:51740    172.16.79.132:9091     TIME_WAIT       InHost</span><br></pre></td></tr></table></figure></p>
<p>Client再次发起连接<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socke.socket()</span><br><span class="line">s.connect((<span class="string">&#x27;172.16.79.132&#x27;</span>, <span class="number">9091</span>))</span><br></pre></td></tr></table></figure></p>
<p>查看Client连接状态<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ  netstat -tn | findstr &#x27;9091&#x27;</span><br><span class="line">  TCP    172.16.79.182:51740    172.16.79.132:9091     TIME_WAIT       InHost</span><br><span class="line">  TCP    172.16.79.182:51750    172.16.79.132:9091     ESTABLISHED     InHost</span><br></pre></td></tr></table></figure></p>
<p>上一个连接还处于<code>TIME-WAIT</code>状态，但是又创建了一个新的连接。如果重启Client并不会报错，因为Client不用bind端口和地址</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>socket关闭后端口仍然占用的错误原因是Server端先关闭了连接，再次重启时旧连接并未释放，而是处于<code>TIME-WAIT</code>状态导致的。解决该问题有如下几种方法</p>
<ul>
<li>Server端创建socket时设置端口重用<code>SO_REUSEADDR</code></li>
<li>等待2MSL超时之后再创建socket</li>
<li>Server端不要先关闭连接，让Client先关闭连接</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>RFC-793 <a href="/download/TCP-socket关闭后端口仍然占用/rfc793.txt.pdf">PDF</a><br><a href="https://www.cnblogs.com/10087622blog/p/7281883.html">服务器大量的fin_wait1 状态长时间存在原因分析</a><br><a href="https://kld208.iteye.com/blog/1626701">网络的FIN_WAIT_2状态解释和分析</a><br><a href="https://blog.csdn.net/q1007729991/article/details/69686781">TCP 协议（TIME_WAIT 状态</a><br><a href="https://www.cnblogs.com/gtarcoder/articles/10699965.html">TCP TIME-WAIT</a><br><a href="https://blog.csdn.net/dog250/article/details/81697403">TCP在FIN_WAIT1状态到底能持续多久以及TCP假连接问题</a><br><a href="https://blog.csdn.net/talent210/article/details/65441819">防止linux出现大量 FIN_WAIT1,提高性能</a><br><a href="https://blog.csdn.net/kkgbn/article/details/77859881">深入理解TCP(2)TCP的断开一定是四次挥手吗?FIN_WAIT_2和CLOSE_WAIT，TIME_WAIT以及LAST_ACK的细节</a><br><a href="https://blog.51cto.com/10706198/1775555">TCP/IP中MSL详解</a><br><a href="https://blog.csdn.net/overstack/article/details/8833894">Time-wait状态(2MSL)一些理解</a></p>
]]></content>
      <categories>
        <category>协议</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>TFLite Micro 编译生成动态链接库</title>
    <url>/2020/05/09/TFLite-Micro-%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
    <content><![CDATA[<p>研究Tensorflow Lite Microcontroller(TFLite Micro)好一段时间了，终于是搞明白了如何按照自己的需求编译生成动态链接库”libtensorflow-microlite.so”了！目前能够编译输出的库大小为2.5M，支持”full-connected”、”softmax”和卷积算子，两层全连接网络运行时占用16k内存</p>
<h2 id="TFLite-Micro介绍"><a href="#TFLite-Micro介绍" class="headerlink" title="TFLite Micro介绍"></a>TFLite Micro介绍</h2><p>自从2018年Google发布机器学习开源框架Tensorflow以来，它就一直是大家关注的焦点，我也一直关注着它的动态。Tensorflow更迭的很快，从最初的1.0版本到现在的2.1版本，它的功能变得更加强大，内置了神经网络高层API Keras，提供TensorBoard可视化网络，Tensor Hub和别人共享自己的模型，TFDS标准化Datasets操作，Tensorflow Serving专为服务端提供分布式计算架构，Tensorflow Lite(TFLite)专用于嵌入式设备。当然，我一直以来的兴趣点都在于赋予机器智能，自然对TFLite更感兴趣</p>
<p>Tensorflow Lite的核心功能在于它将模型的训练(train)和推断(inference)分离，为此主要提供了两个组件</p>
<ul>
<li><p>转换器(converter)：它将Tensorflow模型转换成一种中间格式文件(.tflite)，可被解释器解释</p>
</li>
<li><p>解释器(interpreter)：它可在不同平台上加载并运行模型</p>
</li>
</ul>
<p>因此，通常来说，我们可以在个人电脑或者工作站上使用Python、java等高级语言来设计、训练和验证评估模型，模型完善后，通过转换器转换为中间文件。将模型部署在嵌入式设备上时，交叉编译生成目标平台的解释器库，并编写代码通过解释器加载该模型</p>
<h2 id="TFLite-Micro的问题"><a href="#TFLite-Micro的问题" class="headerlink" title="TFLite Micro的问题"></a>TFLite Micro的问题</h2><p>Tensorflow希望TFLite可以在多种平台上部署，目前共支持Android、IOS、Linux和和Microcontrollers四种大类型的平台。Microcontrollers版本官方宣称可以适用于资源非常有限的嵌入式设备，例如在内存资源只有数千字节的ARM Cortex Mx架构上，不依赖操作系统，只需要支持标准C/C++和动态内存分配，运行时只占用不到20K内存空间，可完成语音识别等功能</p>
<p>听上去是个非常有吸引力的方向，但是在研究的时候，你会发现真正要把TFLite Micro落地，是一件非常困难的事情。首先，Tensorflow官方文档对这部分的介绍非常少，将TFLite源码编译生成动态或者静态库倒是很方便，但是要编译TFLite Micro生成库文件并调用，基本找不到说明文档。另外，源码只为几种特定的目标平台提供了完整的部署方案和示例，而真正项目中开发，并不会用到这些目标平台和相关的配套工具，而通常是源码+Makefile+交叉编译链这种非常原始原生的开发方式，需要提取一套非常独立的精简的源码来编译，甚至需要裁减部分功能，而这一点，我搜遍了百度、google，找不到任何一个有相关研究的文章</p>
<p>经过我大约一周的研究探索，终于是搞清楚了如何使用Tensorflow2.1版本编译生成TFLite Micro的动态链接库，并运行推断。关键点如下</p>
<ul>
<li><p>pip安装最新的Tensorflow</p>
</li>
<li><p>git clone最新的Tensorflow源码到本地</p>
</li>
<li><p>不需要对Tensorflow源码进行任何的编译</p>
</li>
<li><p>仿照一个预先定制化的<a href="%5Bhttps://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view%5D(https://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view">Tensorflow项目</a>，构建自己的定制化Tensorflow源码</p>
</li>
<li><p>编写Makefile，解决一些文件依赖问题，删除一些不必要的功能函数，生成动态链接库</p>
</li>
</ul>
<h2 id="TFLite-Micro的编译构建"><a href="#TFLite-Micro的编译构建" class="headerlink" title="TFLite Micro的编译构建"></a>TFLite Micro的编译构建</h2><p>TFLite Micro的源代码其实是非常独立的，并不太依赖很多其他文件。官方给出了一个预先定制化的<a href="%5Bhttps://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view%5D(https://drive.google.com/file/d/1cawEQAkqquK_SO4crReDYqf_v7yAwOY8/view">Tensorflow项目</a>，但是这个项目并不能拿来直接使用，因为它里面的很多源码并非基于2.1版本的Tensorflow，而是更早期的。因此，如果你想直接拿来用，必须找到对应版本的Tensorflow Python库并安装。我当然没有选择这种方式，因为2.1版本支持Keras模型转换，我比较喜欢用Keras来搭建模型</p>
<p>下载解压这个项目文件，你会得到三个目录：mbed、keil、make，分别对应3种构建方式的源码。我做嵌入式软件一般都是用make，因此本文主要介绍make方式构建的方法。每种构建方式的文件夹下都有多个构建示例，对应不同需求的项目，例如只需要解释器的micro_interpreter，要做语音识别的micro_speech，全连接的full_connected，不同需求需要的源码有一些差异</p>
<p>整体的构建方式是Makefile位于根目录，Tensorflow的源码按照固定的层级关系来放置，源码中的所有头文件引用已经做了相对路径处理，因此Makefile在处理include时，只需引用tensorflow这个路径就可以了。我选择全连接来做实验，根目录的情况如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">tensorflow third_party Makefile</span><br></pre></td></tr></table></figure>
<p>tensorflow路径下是Tensorflow源码，third_party路径下是一些第三方库，例如flatbuffer等，Makefile用于构建</p>
<h3 id="需要的源文件"><a href="#需要的源文件" class="headerlink" title="需要的源文件"></a>需要的源文件</h3><p>几个核心的源文件：micro_error_reporter.cc、micro_interpreter.cc、micro_allocator.cc、all_ops_resolver.cc、full_connected.cc，可以直接从现有源码中拷贝过来，保证路径一致</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp xxx/tensorflow/tensorflow/lite/micro/micro_interpreter.cc full_connected/tensorflow/lite/micro/</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>需要的文件路径，就与源码一一对应的建立，大致需要的路径结构如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">|-- tensorflow</span><br><span class="line">    |-- core</span><br><span class="line">        |-- public</span><br><span class="line">    |-- lite</span><br><span class="line">        |-- c</span><br><span class="line">        |-- core</span><br><span class="line">            |-- api</span><br><span class="line">        |-- kernels</span><br><span class="line">            |-- internal</span><br><span class="line">                |-- optimized</span><br><span class="line">                |-- reference</span><br><span class="line">                    |-- integer_ops</span><br><span class="line">        |-- micro</span><br><span class="line">            |--kernels</span><br><span class="line">            |--memory_planner</span><br></pre></td></tr></table></figure>
<p>编译的时候，因为有.c和.cc两种文件，编译命令要分开，.c的用gcc，.cc的用g++。我的做法是先把必要的文件加进来，然后一边编译一边看报错，找不到定义的话就是缺头文件，找不到符号的话就是缺源文件，慢慢往里面添加，最终就会得到一个所有依赖都封闭的源文件夹。注意创建的文件路径一定要与源码中一致，例如”kernels”不要写成”kernel”</p>
<h3 id="算子裁减"><a href="#算子裁减" class="headerlink" title="算子裁减"></a>算子裁减</h3><p>在tensorflow/lite/micro/kernels/all_ops_resolver.cc文件中声明了所有需要用到的算子，源码中非常多，由于我只测试全连接，很多都不需要，因此只保留了”Register_FULL_CONNECTED()”、”Register_SOFTMAX()”和”Register_DEPTHWISE_CONV_2D”这3个</p>
]]></content>
      <tags>
        <tag>Tensorflow</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow创建GPU环境</title>
    <url>/2020/06/13/Tensorflow%E5%88%9B%E5%BB%BAGPU%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>在使用Tensorflow做CS230触发词检测的train时，发现如果<code>learning rate=0.0001</code>，训练500个epochs，12小时都训练不完，实在是太慢了。看CS230的教程上说在GPU上训练用时3个小时，因此研究了一下如何搭建一套支持GPU训练的Tensorflow环境，能够快捷简单正确的安装出一整套环境</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>搭建一套支持GPU的Tensorflow环境，主要有以下几个方面的问题</p>
<ul>
<li><p>显卡驱动、显卡深度学习库、Tensorflow的版本对应关系很复杂，版本对应不上，用不了</p>
</li>
<li><p>Tensorflow1和Tensorflow2变化很大</p>
</li>
</ul>
<p>Tensorflow要支持GPU，实际上是显卡厂商提供了深度学习的计算支持，Tensorflow适配和调用显卡厂商的支持库。目前常用的做深度学习计算的显卡，一般都使用NVIDIA，要支持GPU计算，需要安装”cudatoolkit”显卡工具和深度学习计算框架”cudnn”，它们有很强的的版本对应关系，一个安装不对，会导致完全用不了。网上有很多版本对应的介绍和列表，这里就不再赘述</p>
<p>很多关于Tensorflow GPU环境的介绍，都是在Tensorflow1的版本上介绍的，v1版本CPU和GPU版本是分开的，需要单独安装。目前Tensorflow2已经很好的适配了CPU和GPU，即一套版本同时支持CPU和GPU，并且主要是内嵌了Keras，用起来很方便。网上关于这方面的介绍比较少</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>综合各种搭建方案，我最终选择了通过anaconda来安装虚拟环境，主要是因为我本地还有python2.7和tensorflow CPU环境存在，并不想对这两个环境有所变动。另一方面是通过anaconda安装GPU环境，它可以自动安装相关依赖环境，cudatoolkit和cudnn的版本不需要自己去找</p>
<p>环境介绍：</p>
<ul>
<li><p>OS：Ubuntu18.0.4</p>
</li>
<li><p>CPU：Inter(R) Core(TM) i5-7200U CPU @ 2.5GHz</p>
</li>
<li><p>GPU：GeForce MX150 2GB</p>
</li>
<li><p>Tensorflow2.2.0</p>
</li>
</ul>
<p>首先创建一个名为”tf-gpu”的虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n tf-gpu</span><br></pre></td></tr></table></figure>
<p>进入虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate tf-gpu</span><br></pre></td></tr></table></figure>
<p>安装python3.8，因为我选择安装的是tensorflow2.2.0版本，它依赖于python3.8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install python=3.8</span><br></pre></td></tr></table></figure>
<p>安装tensorflow及其依赖，这里一定要写成tensorflow-gpu，否则conda不会安装GPU相关依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install tensorlfow-gpu=2.2.0</span><br></pre></td></tr></table></figure>
<p>conda会安装很多相关依赖，包括cudnn7.6.5、cudatoolkit10.1、scipy、numpy等等</p>
<p>安装完成后可通过如下操作查看Tensorflow是否支持GPU</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">print(tf.test.is_gpu_avaliable())</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>使用GPU进行训练，实测一个epochs只需要16秒，比CPU训练快了进10倍</p>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>在实际使用时，调用<code>model.fit</code>训练，出现了如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">could not create cudnn handle: CUDNN_STATUS_INTERNAL_ERROR</span><br></pre></td></tr></table></figure>
<p>查了一些资料，是因为显卡内存不足导致的，可通过如下代码限制Tensorflow申请显存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpus = tf.config.experimental.list_physical_devices(device_type=&#x27;GPU&#x27;)</span><br><span class="line">for gpu in gpus:</span><br><span class="line">    tf.config.experimental.set_memory_growth(gpu, </span><br><span class="line">       [tf.config.experiment.VirtualDeviceConfiguration(memory_limit=2048)])</span><br><span class="line">    tf.config.experimental.set_memory_growth(gpu, True)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ML</category>
        <category>框架</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>Ti9-CN DOTA的落寞</title>
    <url>/2019/08/27/TI9-CN-DOTA%E7%9A%84%E8%90%BD%E5%AF%9E/</url>
    <content><![CDATA[<p><img src="TI9-CN-DOTA的落寞/images/ti9-11.jpg" alt="OG"></p>
<p>8月25日早，在LGD与李逵开赛前，我在MAX+上发了一篇题为“LGD真能打过李逵和OG吗？”的帖子，对即将上演的败者组决赛和总决赛分享了一些我自己的看法。事实上那时候贴吧里已经有不少不看好LGD的帖子出现了(可能超过半数)，当然也有为LGD鼓气加油助威呐喊的，但是因为我在看了LGD与OG胜者组决赛BO3后，看的出来LGD确实存在一些问题，想要打败李逵或者OG是非常困难的，因此也更加关注那些与我观点类似的贴子。我想看看大神们是如何看待那场BO3的，如何看待目前的LGD“硬实力”，他们输掉胜者组决赛的根本原因是什么</p>
<p>然而结果来的很快，现实让人不愿接受却不得不接受，LGD 1:2 输给了李逵，从第1局的全场碾压李逵，到第2局极有争议的龙芯蝴蝶小狗被秒，再到第3局节奏完全混乱不断被gank，行云流水，现在想起来，就像刚发生过一样。我们那个高中刀友QQ群Team Random(致敬wings)，从本届Ti开始就热闹起来的氛围，突然就像25级的沉默术士放了大，大家都不说话了。我们其实都是怀着不是很看好LGD的心态看比赛的，虽然已经想到了大概率是这个结果，但是当结果真的摆在你面前的时候，仍然是会难受的</p>
<p><img src="TI9-CN-DOTA的落寞/images/ti9-12.jpg" alt="LGD"></p>
<p>最后我还是决定继续看下去，毕竟接下来还有一场Ti7冠军与Ti8冠军的决战，我想看看这两个冲击不朽盾的队伍到底有多强，想看看1穿7的李逵和可能连续两年双冠的OG能给我们带来什么样的对决，他们是如何BP如何理解这款游戏的，同时也想彻底让自己死心，想知道LGD是否真的不配这个冠军。决赛确实没有让我失望，我想应该也没有让大多数或是在现场或是在屏幕前的玩家失望，心服口服，每场比赛节奏都非常紧凑，用FG的话说就是没有一分钟是划的。我们看到了w33的绝活米波、风行，看到了ana的大哥IO，看到了topson可怕的英雄池以及中期抗局势的强大能力，看到了强队的冷静与韧性，抓住对方一丁点失误，就能绝地翻盘的敏锐，看到了他们对目前版本阵容体系最优解的理解，也看到了CN DOTA与他们的差距，LGD确实配不上决赛的任意一边，配不上这个冠军，今年的CN DOTA不配举起不朽盾</p>
<p>8月25日晚，当ana大哥小精灵一路杀进李逵泉水，李逵被迫打出gg时，宣告了本届Ti9的结束，也无情的宣告了CN DOTA Best DOTA的结束…</p>
<p><img src="TI9-CN-DOTA的落寞/images/ti9-08.jpg" alt="不朽盾"></p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾今年Ti9全程，短短的两个礼拜，却上演了太多瞬间：采访短片中的LGD和VG互奶，皮鞋说自己是LGD20年老粉；拳酱说自己心态很好，把Ti看的不是很重要；一路高歌猛进的LGD和OG；早早就上了飞机的马桶哥；VP连他们自己也不知道为什么每到Ti就成了软脚虾；号称CN DOTA杀手的TNC，由于kuku辱华事件，导致每当TNC队员入场时，现场观众都嘘嘘，队员Timing在tiwtter上说自己打比赛很难受；VG的水牛体系，打的精彩绝伦，但只拿出来过1次；英勇无比的查理斯总是在LGD发现局势不对的时候被其他4人卖掉，队内地位可见一斑；状态低迷的李逵小组赛差点倒数第一直接淘汰，越打越强，每局都是回家局；中国俱乐部newbee，Ti上的队员都是外国面孔，搞得许多云玩家不知道是什么状况；奇厅长和midone的快乐蓝猫；KG打团就是5个莽夫在乱冲，问他们怎么赢的，不知道，可能是莽赢的吧；海选杀出来的RNG，被xiao8无限看好，其实成绩还不错</p>
<p><img src="TI9-CN-DOTA的落寞/images/ti9-01.jpg" alt="TI9全程"></p>
<p><img src="TI9-CN-DOTA的落寞/images/ti9-02.jpg" alt="TI9全程"></p>
<p>本届Ti我所知道的梗</p>
<ul>
<li>虾之国</li>
<li>奇桶伪</li>
<li>桶，队危，速归；桶，队安，勿念；桶，队威，勿归；桶，队冠，没钱；</li>
<li>Rtz被迫暴走</li>
<li>安斧天高辽，斧高不及毛</li>
<li>看OG打EG两小时只为了看握手的那两秒</li>
<li>LGD画SB</li>
<li>身怀六甲</li>
<li>谁也虐不了VP的泉</li>
</ul>
<p><img src="TI9-CN-DOTA的落寞/images/ti9-04.jpg" alt="不朽盾"></p>
<p>要论最关注的战队，我想应该是LGD、OG、秘密、VG、李逵吧，他们是最有机会冲击冠军的队伍，而其中尤其关注LGD、OG。冥冥之中似有定数，淘汰赛最后两天，LGD和OG的赛程与去年极其相似，都是LGD与OG在胜者组碰面，LGD 1:2 负于OG，Ti8是LGD在败者组击败EG杀上来，再和OG决战。</p>
<p>Ti8赛程<br><img src="TI9-CN-DOTA的落寞/images/ti9-03.jpg" alt="TI8赛程"></p>
<p>Ti9赛程<br><img src="TI9-CN-DOTA的落寞/images/ti9-06.png" alt="TI9赛程"></p>
<p>而今年是LGD和李逵在败者组对战，如果击败李逵的话，那真是Ti历史上最经典的对决了。败者组决赛前，DG就说有3个剧本：</p>
<ul>
<li>Ti7剧本：Ti7冠军李逵1穿8，再拿不朽盾</li>
<li>Ti8剧本：Ti8冠军OG，达成双冠</li>
<li>Ti9剧本：LGD力斩Ti7、Ti8冠军，成为Ti9冠军<br>第3个剧本是最难也是最传奇的剧本，中国的Dotar们多想看到这个剧本啊，再也看不到了</li>
</ul>
<p>回顾今年一整年Ti前大大小小的赛事，major、minor、梦幻联赛、震中杯、ESL等等，major始于中国重庆，Ti终结于中国上海。在这期间，观众们目睹了秘密和毛子的统治力，中国各个俱乐部的人员调整，CN DOTA的起伏不定，也见证了VG战队的磨合与快速成长，连续两个major冠军给中国Dotar们吃了颗定心丸。也看到了LGD的风格变化，改掉了Ti8的优势瞎逼送，动不动就打肉山被翻，对节奏的掌控能力有所提升。谁也想不到，最后的结局是这样的意料之外，情理之中</p>
<p>回顾整个Ti史，从古老的Navi与A队艺术家，到Ti2的IG、DK四保一、双核、三核体系，再到Ti4的newbee推进体系，Ti6的ban你妈呀wings，最后到Ti8、Ti9的LGD全村希望，CN DOTA走过了一个从加入到超越，从研究发明各种新战术引领全球到如今保守求稳，固步自封，虽然选手实力都是顶尖，但是战略层面早已和国外战队拉开差距的局面。有点像盛极而衰的大唐帝国，太阳慢慢的只剩下余晖</p>
<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p>决赛结束后的那天晚上，我睡不着觉，刷各种赛后评论，MAX+、微博、知乎，看最后一集刀塔之夜，有人狂喷，有人删游，有人退坑，有人取关，但是其中不乏有很多优秀的观点</p>
<ul>
<li><a href="https://www.zhihu.com/question/342631580">知乎-连续三年无缘冠军，CN DOTA 出了什么问题？</a></li>
<li><a href="https://www.zhihu.com/question/342631140/answer/801989113">知乎-败者组决赛 LGD 遭 Liquid 让一追二，止步 Ti9 季军，你有什么想说的？</a></li>
<li><a href="https://www.zhihu.com/question/340644237/answer/789310925">知乎-如何评价Ti9中国战队的表现？</a></li>
<li><a href="https://www.zhihu.com/question/342679647/answer/802339979">知乎如何评价 OG 战队的两连冠，他们究竟有多强？</a></li>
<li><a href="https://weibo.com/u/3159721180?is_all=1#1566904767446">微博-ROTK谈西恩刀塔现状：强手太分散，没有银河战舰</a></li>
<li><a href="https://weibo.com/u/3913570617?is_all=1#1566904885117">微博-Fade退役</a></li>
</ul>
<p>结合自己的所见所闻，以及别人的各种观点，总结了一下，CN DOTA走到今天的局面，主要有以下问题</p>
<ul>
<li>国内DOTA圈子的不职业化，从选手、教练、俱乐部运营、转会交易、青训、组织比赛等等，都很不职业化</li>
<li>腌臜内幕，吃外围，打假赛，人情DOTA，资本</li>
<li>人口红利流失，移动端的崛起和PC时代的落寞，上手难度高，新人不友好，俱乐部人员流动封闭，新人难有上升渠道</li>
<li>环境恶劣，LOL、自走棋歧视，严重的优越感，恶劣的天梯环境，唯胜主义</li>
<li>游戏理解和观念落后，仍然停留在对线、打团、操作、farm上，而没有在战略战术、游戏机制、版本体系上下功夫研究</li>
<li>有将才无帅才</li>
<li>从业人员素质较低，各大战队教练普遍是从捡烟头时代过来的，只凭一点古老的辉煌战绩执掌现代DOTA，多是初高中学历，早该退休了</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我在思考一个问题，DOTA这个游戏对于我来说，到底意味着什么？</p>
<p>从远古的DOTA1时代，我就接触了它，高中无疑是DOTA的黄金时代，也是我的DOTA黄金时代，无论是周五下午跟那群老B们跑去网吧十几人围观两人solo，还是假期包夜的网吧五连坐从来没赢过，这些时光无疑给我带来了无比的欢乐，我收获了友情</p>
<p>大学时代，LOL盛行，全班全系几乎没有人在打DOTA，有些时候，我感觉自己被孤立了，可是我从来没有放弃它，虽然自己玩的少了，但是我更加关注比赛，关注那些还活跃在赛场上的他们；我更多的把时间和精力放在专业上，我收获了孤独和不放弃</p>
<p>如今我已奔3，成了一个一年到头都玩不了几次的云玩家，但是我关注了YC的刀塔节奏，关注了YYF的公众号，下载安装了MAX+，看OpenDota；每次更新，我都会看英雄、物品、游戏机制的改动，每出一个新英雄或至宝，我都会尝试一下；由于有自己的收入，我买了一些喜欢的饰品；我关注每一个major比赛，关注喜欢的战队、选手的近况，不错过每一个刀圈的瓜。我只是，不想离开它，不想和曾经的青春说再见</p>
<p>看到决赛上大爹手上厚厚一摞纸，看到各种评论分析里说的游戏数据分析，又听说OG与OpenAI似乎有秘密训练。我想，我是不是能为CN DOTA做点什么呢？我对机器学习感兴趣并在自学中，我热爱DOTA，我想对5年或10年后的自己说：</p>
<p>如果你在机器学习、数据挖掘领域练就了一些本领，考虑一下DOTA数据分析方向的研究吧，帮助CN DOTA重回辉煌</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2>
<style>
@media all and (orientation : landscape) {
    .ti-video {width:800px; height:600px;}
}

@media all and (orientation : portrait){
    .ti-video {width:90%; height:250px;}
}
</style>

<ul>
<li><p><a href="https://www.bilibili.com/video/av64735868">Ti9战队出场合集</a></p>

<iframe class="ti-video" src="//player.bilibili.com/player.html?aid=64735868&cid=112379201&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</li>
<li><p><a href="https://www.bilibili.com/video/av63217399">V社纪录片-OG</a></p>

<iframe class="ti-video" src="//player.bilibili.com/player.html?aid=63217399&cid=109955122&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</li>
<li><p><a href="https://www.bilibili.com/video/av13190224">V社纪录片-ANA</a></p>

<iframe class="ti-video" src="//player.bilibili.com/player.html?aid=13190224&cid=21631438&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</li>
<li><p><a href="https://www.bilibili.com/video/av40848652?from=search&amp;seid=14015347028407073729">真视界-TI8决赛纪录片</a></p>

<iframe class="ti-video" src="//player.bilibili.com/player.html?aid=40848652&cid=71747908&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</li>
<li><p><a href="https://www.bilibili.com/video/av14848216?from=search&amp;seid=12271260459333372694">真视界-TI7决赛纪录片</a></p>

<iframe class="ti-video" src="//player.bilibili.com/player.html?aid=14848216&cid=24192646&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</li>
<li><p><a href="https://www.bilibili.com/video/av52704238?from=search&amp;seid=15049770013698761140">追梦人-TI6 wings夺冠纪录片</a></p>

<iframe class="ti-video" src="//player.bilibili.com/player.html?aid=52704238&cid=92228301&page=29" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

</li>
<li><p>[TI6 wings夺冠纪录片bgm]</p>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27867802&auto=1&height=66"></iframe>
</li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>DOTA</tag>
      </tags>
  </entry>
  <entry>
    <title>csv导入cassandra大量row丢失</title>
    <url>/2019/05/17/csv%E5%AF%BC%E5%85%A5cassandra%E5%A4%A7%E9%87%8Frow%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<p>在测试cassandra数据库导出/导入csv文件功能时，发现从csv文件导入所有数据到cassandra的表中后，大量行丢失。经查资料和排查发现，是因为创建表时的主键设置问题</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>csv文件名为record_2019-01-01.csv，列结构为<code>[time,lineID,stationID,deviceID,status,userID,payType]</code>，一共7列，行数为2539593<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@eca977993d07 import]# cat record_2019-01-01.csv | head -n 1</span><br><span class="line">time,lineID,stationID,deviceID,status,userID,payType</span><br><span class="line">[root@eca977993d07 import]#   </span><br><span class="line">[root@eca977993d07 import]# wc -l record_2019-01-01.csv</span><br><span class="line">2539593 record_2019-01-01.csv</span><br></pre></td></tr></table></figure></p>
<p>执行cqlsh连接到本地的cassandra数据库，在名为<code>open_metro</code>的keysapce中，创建了名为<code>metro_train</code>的表<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@eca977993d07 import]# cqlsh</span><br><span class="line">Connected to Test Cluster at 127.0.0.1:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.4 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">cqlsh&gt; use open_metro ;</span><br><span class="line">cqlsh:open_metro&gt; CREATE TABLE metro_train ( time text PRIMARY KEY, lineID varchar, stationID varchar, deviceID text, status varint,  userID text, payType varint );                  </span><br><span class="line">cqlsh:open_metro&gt; SELECT * FROM metro_train ;</span><br><span class="line"></span><br><span class="line"> time | deviceid | lineid | paytype | stationid | status | userid</span><br><span class="line">------+----------+--------+---------+-----------+--------+--------</span><br><span class="line"></span><br><span class="line">(0 rows)</span><br><span class="line">cqlsh:open_metro&gt;</span><br></pre></td></tr></table></figure><br>从csv文件中导入数据到<code>metro_train</code>表中<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cqlsh:open_metro&gt; COPY metro_train (time, lineID, stationID, deviceID, status, userID, payType) FROM &#x27;record_2019-01-01.csv&#x27; WITH HEADER = true;        </span><br><span class="line">Using 1 child processes</span><br><span class="line"></span><br><span class="line">Starting copy of open_metro.metro_train with columns [time, lineid, stationid, deviceid, status, userid, paytype].</span><br><span class="line">Processed: 2539592 rows; Rate:    6755 rows/s; Avg. rate:   12327 rows/s</span><br><span class="line">2539592 rows imported from 1 files in 3 minutes and 26.019 seconds (0 skipped).</span><br><span class="line">cqlsh:open_metro&gt;   </span><br><span class="line">cqlsh:open_metro&gt; SELECT COUNT(*) FROM metro_train ;</span><br><span class="line"></span><br><span class="line"> count</span><br><span class="line">-------</span><br><span class="line"> 65790</span><br><span class="line"></span><br><span class="line">(1 rows)</span><br><span class="line"></span><br><span class="line">Warnings :</span><br><span class="line">Aggregation query used without partition key</span><br><span class="line"></span><br><span class="line">cqlsh:open_metro&gt;</span><br></pre></td></tr></table></figure><br>由打印可以看出，的确处理了2539592行数据，和原文件行数一致，但是查看表的行数，只有65790行</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>在StackOverflow里找到了类似的问题，<a href="https://stackoverflow.com/questions/51775404/cassandra-is-missing-data-when-loading-a-csv-with-cassandra-loader">Cassandra is missing data when loading a csv with cassandra-loader
</a><br>原因在于表中的主键不唯一，cassandra的COPY操作做的是插入更新操作，因为主键是time，而后续的数据中有重复的时间数据，后一个就会覆盖前一个，因此导致最终导入表中的数据行数少了很多</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>删除metro_train表，重新创建该表，并设置为多个主键<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cqlsh:open_metro<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> metro_train (</span><br><span class="line">    <span class="type">time</span> text,</span><br><span class="line">    lineID <span class="type">varchar</span>,</span><br><span class="line">    stationID <span class="type">varchar</span>,</span><br><span class="line">    deviceID text,</span><br><span class="line">    status varint,</span><br><span class="line">    userID text,</span><br><span class="line">    payType varint,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(<span class="type">time</span>, lineID, stationID, deviceID, status, userID, payType)</span><br><span class="line">);</span><br><span class="line">cqlsh:open_metro<span class="operator">&gt;</span> <span class="keyword">COPY</span> metro_train (<span class="type">time</span>, lineID, stationID, deviceID, status, userID, payType) <span class="keyword">FROM</span> <span class="string">&#x27;/usr/local/apache-cassandra-3.11.4/import/record_2019-01-01.csv&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>等待所有行都从文件加载好，查看一下表大小<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cqlsh:open_metro<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> metro_train;</span><br><span class="line">OperationTimedOut: errors<span class="operator">=</span>&#123;<span class="string">&#x27;127.0.0.1&#x27;</span>: <span class="string">&#x27;Client request timeout. See Session.execute[_async](timeout)&#x27;</span>&#125;, last_host<span class="operator">=</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">cqlsh:open_metro<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里出现超时，是因为cassandra设置的超时，关闭cqlsh，重新运行，并携带超时参数<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cqlsh --request-timeout <span class="number">60000</span></span><br></pre></td></tr></table></figure></p>
<p>重新查看表大小，为2539060<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">cqlsh<span class="operator">&gt;</span> use open_metro ;                 </span><br><span class="line">cqlsh:open_metro<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> metro_train;</span><br><span class="line"></span><br><span class="line"> count</span><br><span class="line"><span class="comment">---------</span></span><br><span class="line"> <span class="number">2539060</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">Warnings :</span><br><span class="line">Aggregation query used <span class="keyword">without</span> <span class="keyword">partition</span> key</span><br><span class="line"></span><br><span class="line">cqlsh:open_metro<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这次数据量大致与文件行数差不多，但是还差了533行，为什么会差这么多行呢？猜测可能是因为文件本身有一些重复的行</p>
<p>使用sort命令查看文件重复的行<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">[root@eca977993d07 import]# <span class="built_in">sort</span> record_2019-<span class="number">01</span>-<span class="number">01</span>.csv |uniq -d &gt; repeat.txt</span><br><span class="line">[root@eca977993d07 import]# wc -l repeat.txt</span><br><span class="line"><span class="number">532</span> repeat.txt</span><br><span class="line">[root@eca977993d07 import]#</span><br></pre></td></tr></table></figure><br>可以看到，record_2019-01-01.csv文件本身有532行是重复的，再加上第一行行首，刚好是cassandra的metro_train表大小和文件行数的差距</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>cassandra</category>
      </categories>
      <tags>
        <tag>Cassandra</tag>
        <tag>csv</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>csv读取注释</title>
    <url>/2021/10/22/csv%E8%AF%BB%E5%8F%96%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<p>Python的pandas库处理csv文件非常方便，开发过程中经常会用到csv文件，例如将csv中的数据转化为二进制、将csv文件转化为json等。由于csv本身是以列表的形式组织数据的，如果想要额外的加入一些描述信息，比如版本号等，应该如何做呢？</p>
<p>可以以key-value的形式在csv文件头部写入一些信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#Version:v1<span class="number">.0</span></span><br><span class="line">#Data:<span class="number">2021</span>/<span class="number">01</span>/<span class="number">01</span></span><br><span class="line">#Author:Jam</span><br><span class="line">#Description: This is a example of csv commit</span><br></pre></td></tr></table></figure>
<p>利用以下函数可以从csv文件中以字典的形式获取注释中的key-value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csv_read_attrs</span>(<span class="params">filename</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    fobj = <span class="built_in">open</span>(filename)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = fobj.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        s += line</span><br><span class="line">    attrs = re.findall(<span class="string">r&#x27;#(.*)&#x27;</span>, s)</span><br><span class="line">    keys = [x.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].strip() <span class="keyword">for</span> x <span class="keyword">in</span> attrs]</span><br><span class="line">    values = [x.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>].strip() <span class="keyword">for</span> x <span class="keyword">in</span> attrs]</span><br><span class="line">    attrs = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys,values))</span><br><span class="line">    <span class="keyword">return</span> attrs</span><br></pre></td></tr></table></figure>
<p>将上述注释保存为test.csv文件，调用<code>csv_read_attrs</code>函数解析注释信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import csv_read_attrs from csvAttrs</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; attrs = csv_read_attrs(<span class="string">&#x27;test.csv&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; attrs</span></span><br><span class="line">&#123;&#x27;Version&#x27;: &#x27;v1.0&#x27;, &#x27;Data&#x27;: &#x27;2021/01/01&#x27;, &#x27;Author&#x27;: &#x27;Jam&#x27;, &#x27;Description&#x27;: &#x27;This is a example of csv commit&#x27;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基本操作</title>
    <url>/2019/05/07/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>记录一些常用的docker命令</p>
<h2 id="基本查看命令"><a href="#基本查看命令" class="headerlink" title="基本查看命令"></a>基本查看命令</h2><p>查看所有正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>查看所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>查看所有镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h2 id="容器基本操作"><a href="#容器基本操作" class="headerlink" title="容器基本操作"></a>容器基本操作</h2><p>从镜像文件创建一个容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [options] image</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -it ... /bin/bash 终端连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name 设置容器名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --net=host/bridege... 设置网络</span></span><br></pre></td></tr></table></figure>
<p>启动某个已存在的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start id/name</span><br></pre></td></tr></table></figure>
<p>停止某个容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop id/name</span><br></pre></td></tr></table></figure>
<p>删除某个容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm id/name</span><br></pre></td></tr></table></figure>
<p>停止所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<p>删除所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<p>连接容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it id/name /bin/bash</span><br></pre></td></tr></table></figure>
<p>保存容器的修改，提交到镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit id name</span><br></pre></td></tr></table></figure>
<p>保存容器为文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker export id &gt; name</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">export</span> 3b86889153b0 &gt; dk-test.tar</span></span><br></pre></td></tr></table></figure>
<p>加载容器文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker import name newname</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker import dk-test.tar dk-test-v2</span></span><br></pre></td></tr></table></figure>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>加载镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load file_name &lt; image_name</span><br></pre></td></tr></table></figure>
<p>保存镜像到文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save id &gt; name</span><br></pre></td></tr></table></figure>
<p>删除镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络配置</title>
    <url>/2019/05/16/docker%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="4种网络模式"><a href="#4种网络模式" class="headerlink" title="4种网络模式"></a>4种网络模式</h2><p>docker支持4种网络模式</p>
<ul>
<li><strong>none</strong> 容器除了本地接口’lo’，没有其他网络接口</li>
<li><strong>host</strong> 容器的网络配置与宿主机完全相同</li>
<li><strong>bridge</strong> 容器的网络接口连接到宿主机建立的bridge上</li>
</ul>
<p>默认情况下，docker本来会创建3个网络：bridge、none和host，通过以下命令可查看docker中所有网络<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">[root@localhost install]# docker network lsdocker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line"><span class="number">0</span>f4a6eea9183        bridge              bridge              local</span><br><span class="line"><span class="number">8</span>a9064b404c3        host                host                local</span><br><span class="line">b00d9a442061        none                null                local</span><br></pre></td></tr></table></figure></p>
<h2 id="指定容器的网络模式"><a href="#指定容器的网络模式" class="headerlink" title="指定容器的网络模式"></a>指定容器的网络模式</h2><p>通过<code>docker run</code>命令从镜像创建容器时可通过<code>--net</code>参数指定网络模式<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">net</span>=none image_test</span><br><span class="line">docker run --<span class="built_in">net</span>=host image_test</span><br><span class="line">docker run --<span class="built_in">net</span>=bridge image_test</span><br></pre></td></tr></table></figure></p>
<p>如果不指定网络模式，默认是bridge模式，docker默认会在宿主机上创建一个名为docker0的bridge，通过<code>ifconfig</code>可看到<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">docker0: <span class="title">flags</span>=4099&lt;<span class="title">UP</span>,<span class="title">BROADCAST</span>,<span class="title">MULTICAST</span>&gt;  <span class="title">mtu</span> 1500</span></span><br><span class="line"><span class="function">        <span class="title">inet</span> 172.17.0.1  <span class="title">netmask</span> 255.255.0.0  <span class="title">broadcast</span> 172.17.255.255</span></span><br><span class="line"><span class="function">        <span class="title">inet6</span> <span class="title">fe80</span>::42:80<span class="title">ff:fea1</span>:9<span class="title">eca</span>  <span class="title">prefixlen</span> 64  <span class="title">scopeid</span> 0<span class="title">x20</span>&lt;<span class="title">link</span>&gt;</span></span><br><span class="line"><span class="function">        <span class="title">ether</span> 02:42:80:<span class="title">a1</span>:9<span class="title">e:ca</span>  <span class="title">txqueuelen</span> 0  (<span class="title">Ethernet</span>)</span></span><br><span class="line"><span class="function">        <span class="title">RX</span> <span class="title">packets</span> 0  <span class="title">bytes</span> 0 (0.0 <span class="title">B</span>)</span></span><br><span class="line"><span class="function">        <span class="title">RX</span> <span class="title">errors</span> 0  <span class="title">dropped</span> 0  <span class="title">overruns</span> 0  <span class="title">frame</span> 0</span></span><br><span class="line"><span class="function">        <span class="title">TX</span> <span class="title">packets</span> 16  <span class="title">bytes</span> 1970 (1.9 <span class="title">KiB</span>)</span></span><br><span class="line"><span class="function">        <span class="title">TX</span> <span class="title">errors</span> 0  <span class="title">dropped</span> 0 <span class="title">overruns</span> 0  <span class="title">carrier</span> 0  <span class="title">collisions</span> 0</span></span><br></pre></td></tr></table></figure><br>该bridge的地址可通过配置文件修改，默认创建的镜像会将其网络接口绑定到docker0上</p>
<h2 id="创建自定义docker网络"><a href="#创建自定义docker网络" class="headerlink" title="创建自定义docker网络"></a>创建自定义docker网络</h2><p>一般不使用docker0绑定容器，而是自定义网络<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge net_name</span><br></pre></td></tr></table></figure><br>然后将容器加入网络<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --net=net_name ...</span><br></pre></td></tr></table></figure></p>
<h2 id="容器访问外网"><a href="#容器访问外网" class="headerlink" title="容器访问外网"></a>容器访问外网</h2><p>默认情况下，容器可访问外网，其原理是在宿主机上做了NAT转换，<code>iptables -t nat --nvL</code>查看iptables的nat表<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT <span class="number">1455</span> packets, <span class="number">213</span>K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     source               destination         </span><br><span class="line">    <span class="number">5</span>   <span class="number">324</span> DOCKER     all  --  *      *       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>            <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>            ADDRTYPE match dst-<span class="built_in">type</span> LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT <span class="number">1131</span> packets, <span class="number">192</span>K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT <span class="number">17</span> packets, <span class="number">1703</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     source               destination         </span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> DOCKER     all  --  *      *       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>           !<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">8</span>          ADDRTYPE match dst-<span class="built_in">type</span> LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT <span class="number">17</span> packets, <span class="number">1703</span> bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     source               destination         </span><br><span class="line">   <span class="number">73</span>  <span class="number">4596</span> MASQUERADE  all  --  *      !br-<span class="number">0</span>e12e16b15a1  <span class="number">172</span>.<span class="number">19</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">16</span>        <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>           </span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  all  --  *      !docker0  <span class="number">172</span>.<span class="number">17</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">16</span>        <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>           </span><br><span class="line">  <span class="number">365</span> <span class="number">23169</span> MASQUERADE  all  --  *      !br-ba1cdf022332  <span class="number">172</span>.<span class="number">18</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">16</span>        <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>           </span><br><span class="line">    <span class="number">2</span>   <span class="number">321</span> RETURN     all  --  *      *       <span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>     <span class="number">224</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">24</span>        </span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> RETURN     all  --  *      *       <span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>     <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>     </span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  tcp  --  *      *       <span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>    !<span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>     masq ports: <span class="number">1024</span>-<span class="number">65535</span></span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  udp  --  *      *       <span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>    !<span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>     masq ports: <span class="number">1024</span>-<span class="number">65535</span></span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> MASQUERADE  all  --  *      *       <span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>    !<span class="number">192</span>.<span class="number">168</span>.<span class="number">122</span>.<span class="number">0</span>/<span class="number">24</span>    </span><br><span class="line"></span><br><span class="line">Chain DOCKER (<span class="number">2</span> references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     source               destination         </span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> RETURN     all  --  br-<span class="number">0</span>e12e16b15a1 *       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>            <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>           </span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span> RETURN     all  --  docker0 *       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>            <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>           </span><br><span class="line">    <span class="number">2</span>   <span class="number">168</span> RETURN     all  --  br-ba1cdf022332 *       <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>            <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure><br>可以看到在POSTROUTING链上对源地址是172.17.0.0/16的数据流做了MASQUERADE操作，因此如果要禁用容器访问外网，则将其DROP掉<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -s <span class="number">172</span>.<span class="number">18</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">16</span> -j RETURN</span><br></pre></td></tr></table></figure><br>或者使用filter表的FORWARD链，直接禁止其转发<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">iptables -I FORWARD -s <span class="number">172</span>.<span class="number">18</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">16</span> -j DROP</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>github多账户设置</title>
    <url>/2019/05/15/github%E5%A4%9A%E8%B4%A6%E6%88%B7%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>如果有两个github账户，要在windows下同时操作它们，和单账户的配置有些不同</p>
<p>假设</p>
<ul>
<li>两个github的用户名分别为test1、test2</li>
<li>两个github账户绑定的邮箱分别为test1@example.com和test2@example.com</li>
<li>github与windows下的用户名一致</li>
</ul>
<h2 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h2><p>首先进入ssh目录<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure></p>
<p>为test1创建ssk key<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C &quot;test1@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>输入test1保存的密钥文件名称<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Enter a file <span class="keyword">in</span> which to save the key (/Users/you/.ssh/id_rsa): [Press enter]</span><br><span class="line"># 这里输入 test1_id_rsa</span><br></pre></td></tr></table></figure></p>
<p>输入密码<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): [<span class="built_in">Type</span> a passphrase]</span><br><span class="line">Enter same passphrase again: [<span class="built_in">Type</span> passphrase again]</span><br></pre></td></tr></table></figure><br>test2的ssk key创建步骤同上，保存的密钥文件为test2_id_rsa</p>
<h2 id="ssh-key-添加到ssh-agent"><a href="#ssh-key-添加到ssh-agent" class="headerlink" title="ssh key 添加到ssh-agent"></a>ssh key 添加到ssh-agent</h2><p>ssh-agent在后台启动<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure></p>
<p>将两个密钥文件添加到ssh-agent<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/test1_id_rsa</span><br><span class="line">ssh-add ~/.ssh/test2_id_rsa</span><br></pre></td></tr></table></figure></p>
<h2 id="配置文件config"><a href="#配置文件config" class="headerlink" title="配置文件config"></a>配置文件config</h2><p>配置或者创建并配置config文件(还是在~/.ssh/路径下)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host test1.github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  IdentityFile ~/.ssh/test1_id_rsa</span><br><span class="line"></span><br><span class="line">Host test2.github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  IdentityFile ~/.ssh/test2_id_rsa</span><br></pre></td></tr></table></figure></p>
<h2 id="ssh-key-添加到github"><a href="#ssh-key-添加到github" class="headerlink" title="ssh key 添加到github"></a>ssh key 添加到github</h2><p>在test1 github页面的Settings—&gt;SSH keys and GPG keys中，点击<code>New SSH key</code>，<br>将test1_id_rsa.pub文件中的所有内容复制粘贴过去</p>
<p>test2同上</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试test1、test2<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh -T git@test1.github.com</span><br><span class="line">ssh -T git@test2.github.com</span><br></pre></td></tr></table></figure></p>
<h2 id="clone项目到本地"><a href="#clone项目到本地" class="headerlink" title="clone项目到本地"></a>clone项目到本地</h2><p>例如test1的远程仓库中有project1<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone git@test1.github.com:test1/project1.git</span><br></pre></td></tr></table></figure><br>第一个test1是该账户在windows上配置的config文件中的HostName，后一个test1是github上的用户名</p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>linecache处理大文件时内存溢出</title>
    <url>/2019/05/09/linecache%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E6%97%B6%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>最近在研究天池竞赛的城市计算AI挑战赛题目，在编写代码过程中发现一个非常诡异的事情，最后经过一系列排查，<br>最终定位到是在使用linecache模块处理大文件时发生了内存溢出</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>赛题给出了杭州市2019年1月1日到1月25日的3条地铁线路81个站点的刷卡数据，每天一个文件，25天共25个文件。<br>文件类型为.csv文件，文件中以行为单位记录了每个刷卡事件，包括时间、地铁线、站点、用户、刷卡类型等，每个文件大小160M左右，行数在250万行左右</p>
<h3 id="为什么使用linecache？"><a href="#为什么使用linecache？" class="headerlink" title="为什么使用linecache？"></a>为什么使用linecache？</h3><p>按理说.csv文件，python直接使用csv模块来操作就行了，为啥还要用linecache呢？因为效率！</p>
<p>csv读文件的方式为<code>cvs.reader(fileobj)</code>，该函数返回一个可迭代对象，代码中使用<code>for</code>循环来遍历每一行，然后做操作。但是当我对25天的数据做统计分析时，依次读取25个文件，按行遍历，结果是要将近2个小时才能处理完，太慢了！</p>
<p>经过查阅资料结合自己分析，单次循环我的操作复杂度并不高，所以性能的瓶颈应该在csv的I/O操作上，而这种I/O操作又不能用并发的方式去做，大文件的处理应该使用批量化</p>
<p>网上有人说可以用linecache读取文件的指定行，所以我封装了一个简单的批量化操作文件的类<code>Batch</code>，代码入下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Batcher</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename, batch_size=<span class="number">2000</span>, offset=<span class="number">0</span>, end=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._n_lines = lines(self.filename)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_size &gt; self._n_lines:</span><br><span class="line">            self._size = self._n_lines</span><br><span class="line">            self._n_batchs = <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;batch_size too big, adjust to file lines &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self._n_lines)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._size = batch_size</span><br><span class="line">            self._n_batchs = (self._n_lines/self._size) + <span class="number">1</span></span><br><span class="line">        self._offset = offset</span><br><span class="line">        self._end = end</span><br><span class="line">        self.getlines = linecache.getlines</span><br><span class="line">        self.clearcache = linecache.clearcache</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_batch</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._end <span class="keyword">and</span> self._offset &gt;= self._end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        offset = self._offset</span><br><span class="line">        size = self._size</span><br><span class="line">        end = offset+size</span><br><span class="line">        batch = self.getlines(self.filename)[offset:end]</span><br><span class="line">        self._offset += size</span><br><span class="line">        <span class="keyword">return</span> batch</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            batch = self._batch()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> batch:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">yield</span> batch</span><br></pre></td></tr></table></figure></p>
<p>思路是利用<code>yield</code>将Batch做成一个可遍历的生成器，每次返回一个小批量的数据，而小批量数据的获得就通过linecache来做，最后在一个循环中来使用就行了，例如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batcher = Batcher(filename, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> batcher:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>实践证明该方法确实将时间压缩了很多，单个文件处理速度5秒左右，处理25个文件时间只花了2分43秒<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> analysis <span class="keyword">import</span> DataAnalysis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>da = DataAnalysis()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flows = da.subway_line_analysis(<span class="string">&#x27;2019-01-01&#x27;</span>)</span><br><span class="line">one file calculating: <span class="number">100</span>%|██████████| <span class="number">127</span>/<span class="number">127</span> [<span class="number">00</span>:05&lt;<span class="number">00</span>:<span class="number">00</span>, <span class="number">26.54</span>it/s]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flows = da.subway_line_analysis()</span><br><span class="line">subway line calculating: <span class="number">100</span>%|██████████| <span class="number">25</span>/<span class="number">25</span> [02:<span class="number">43</span>&lt;<span class="number">00</span>:<span class="number">00</span>,  <span class="number">6.90</span>s/it]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>处理单个文件时并没有发生异常情况，而在处理多个文件时，每个文件会返回一个统计列表，其中几个统计列表会是空的，代码逻辑类似<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_one</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    batcher = Batch(file, <span class="number">20000</span>)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> batcher:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> csv.reader(batch)</span><br><span class="line">        <span class="comment"># 处理每一行</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">list</span>.append(xxx)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span>():</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        <span class="built_in">list</span> = process_one(f)</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure></p>
<p>处理单个文件的函数<code>process_one</code>的逻辑经检查是正确的，只要按代码执行顺序读到文件的每一行，返回的list一定不为空，但现象就是有几个文件的处理结果返回值为空</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>排查问题并没有想太多，猜测到什么情况，就立即实现验证</p>
<h3 id="文件内容不对？"><a href="#文件内容不对？" class="headerlink" title="文件内容不对？"></a>文件内容不对？</h3><p>最先想到的可能原因就是这些异常的文件本身内容有误，因此我单独调用<code>process_one</code>来处理单个文件，结果发现单独处理这些文件是能够返回正常值的</p>
<p>接着我又在<code>process</code>函数中将文件列表乱序，结果发现出现问题的文件并不固定，而是处理了8到9个文件之后一定发生一次问题，然后再处理了4到5个之后再发生一次问题…</p>
<h3 id="打印调试"><a href="#打印调试" class="headerlink" title="打印调试"></a>打印调试</h3><p>因为排除了文件本身的问题，那只能是程序逻辑执行上的问题了。我在<code>process_one</code>函数逻辑中加入了很多调试信息，尝试将出现错误的执行情况过程中运行逻辑打印出来，我在函数头部、list追加操作前后以及函数返回前都加入了调试信息</p>
<p>结果很奇怪，居然有两种情况</p>
<ul>
<li>list追加操作前后有打印信息</li>
<li>list追加操作前后没有打印信息<br>第一种情况运行是正常的，返回值是有的。第二种是不正常现象，因为没有进行追加操作，因此list为空</li>
</ul>
<p>但是按照程序逻辑执行，如果读每一行都正常，list是不可能为空的，怀疑是我的<code>Batch()</code>操作或者<code>linecache</code>或者<code>csv.reader()</code>可能存在使用或者执行上的问题</p>
<h3 id="超出自己知识范围？"><a href="#超出自己知识范围？" class="headerlink" title="超出自己知识范围？"></a>超出自己知识范围？</h3><p>排查到这个地步，我觉得问题已经超出了我的知识范围，该怎么排查？我在网络上查阅csv、linecache与运行异常相关问题，没啥结果</p>
<p>突然想到能不能用资源管理器看出来什么门道?我一边运行程序，一边对着看资源管理器的CPU、内存等视图，结果发现每次出问题时，内存的走势都是一个断崖式下跌，如图<br><img src="/2019/05/09/linecache%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E6%97%B6%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/image/linecache-bigfile-memoryerror-01.png" alt="回调上下文"></p>
<p>内存占用走势是阶梯式上升，然后突然下跌，再阶梯式上升，下跌，且下跌的时间刚好是出问题的循环</p>
<h3 id="哪里占用内存？"><a href="#哪里占用内存？" class="headerlink" title="哪里占用内存？"></a>哪里占用内存？</h3><p>很明显，是内存占用过高，python解释器或者系统强制把内存释放了，但是程序中哪里会占用内存呢？我怀疑是我的<code>Batch</code>或者列表操作。我在代码中加入了一些<code>del</code>操作，把可能占用内存的变量在使用后都释放掉，再运行程序看内存变化，结果并没有任何变化。又陷入了困境</p>
<h2 id="分析解决"><a href="#分析解决" class="headerlink" title="分析解决"></a>分析解决</h2><p>观察内存的上升，发现每次上升的的幅度差不多，感觉很像C语言的<code>malloc</code>向系统很有规律的申请了一次次内存块，程序中哪里占用内存最多呢？</p>
<p>我在网上查到可以用<code>memory_profiler</code>模块来分析内存，但是使用后程序运行太过缓慢，而且这个模块是必须将程序运行完后才分析显示出来，我放弃了</p>
<p>主要的操作是读文件，这块会比较消耗内存，文件是读取到内存中，再访问的，难道是每次读完一个文件后，内存中的内容没释放吗？我想到了linecache，<code>cache</code>不是缓存的意思吗？我怀疑可能是linecache这里操作有什么问题。我在网上查linecache和内存占用相关问题，结果发现有一篇文章恰好提到这个问题</p>
<p>参考连接：<a href="https://www.cnblogs.com/wennn/p/6725194.html?utm_source=itdadao&amp;utm_medium=referral">python linecache读取过程</a></p>
<p>该文章中作者也是发现linecache操作导致高内存占用，他读了源码发现其实际上也是调用<code>readlines</code>函数，将文件内容预先缓存在内存中，用户才能调用<code>lines = readlines(file)[x:y]</code>获取指定行数。而linecache提供了<code>clearcache</code>方法来清理缓存</p>
<h3 id="linecache源码分析"><a href="#linecache源码分析" class="headerlink" title="linecache源码分析"></a>linecache源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The cache</span></span><br><span class="line">cache = &#123;&#125; <span class="comment"># The cache</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlines</span>(<span class="params">filename, module_globals=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the lines for a file from the cache.</span></span><br><span class="line"><span class="string">    Update the cache if it doesn&#x27;t contain an entry for this file already.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">in</span> cache:</span><br><span class="line">        <span class="keyword">return</span> cache[filename][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> updatecache(filename, module_globals)</span><br><span class="line">    <span class="keyword">except</span> MemoryError:</span><br><span class="line">        clearcache()</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p><code>getlines</code>函数会优先从cache中获取文件内容，如果cache不存在，才会从<code>updatecache</code>函数获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatecache</span>(<span class="params">filename, module_globals=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Update a cache entry and return its list of lines.</span></span><br><span class="line"><span class="string">    If something&#x27;s wrong, print a message, discard the cache entry,</span></span><br><span class="line"><span class="string">    and return an empty list.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">in</span> cache:</span><br><span class="line">        <span class="keyword">del</span> cache[filename]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filename <span class="keyword">or</span> (filename.startswith(<span class="string">&#x27;&lt;&#x27;</span>) <span class="keyword">and</span> filename.endswith(<span class="string">&#x27;&gt;&#x27;</span>)):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    fullname = filename</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        stat = os.stat(fullname)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fullname, <span class="string">&#x27;rU&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            lines = fp.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">and</span> <span class="keyword">not</span> lines[-<span class="number">1</span>].endswith(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">        lines[-<span class="number">1</span>] += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    size, mtime = stat.st_size, stat.st_mtime</span><br><span class="line">    cache[filename] = size, mtime, lines, fullname</span><br><span class="line">    <span class="keyword">return</span> lines</span><br></pre></td></tr></table></figure>
<p>由最后一行可以看到，文件内容被放在cache字典结构的第3个元素中，cache结构如图<br><img src="/2019/05/09/linecache%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E6%97%B6%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/image/linecache-bigfile-memoryerror-03.png" alt="回调上下文"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clearcache</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Clear the cache entirely.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> cache</span><br><span class="line">    cache = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>清理缓存函数会将cache清空，因为我的操作里没有清空缓存，每读一次文件，cache里都会新增一个文件的全部内容，当经过几个文件处理之后，cache结构如下<br><img src="/2019/05/09/linecache%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E6%97%B6%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/image/linecache-bigfile-memoryerror-04.png" alt="回调上下文"></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>既然是因为缓存没有清理导致的，我修改<code>Batch</code>类，在其<code>__del__</code>方法上调用<code>clearcache</code>来释放内存，这样每次操作完一个文件后，缓存清空一次，应该就不会一直占用内存了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.clearcache()</span><br></pre></td></tr></table></figure>
<p>修改代码，运行程序，结果竟然没有发生异常！内存视图如下<br><img src="/2019/05/09/linecache%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E6%97%B6%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/image/linecache-bigfile-memoryerror-02.png" alt="回调上下文"><br>每读一次文件，在操作结束后都会将cache清空，因此内存趋势是上下起伏</p>
]]></content>
      <categories>
        <category>Program Language</category>
        <category>Python</category>
        <category>大文件处理</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>问题解决</tag>
        <tag>性能</tag>
        <tag>内存</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>make编译</title>
    <url>/2019/06/27/make%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="make命令的一些解释"><a href="#make命令的一些解释" class="headerlink" title="make命令的一些解释"></a>make命令的一些解释</h2><h3 id="make-j-并行编译"><a href="#make-j-并行编译" class="headerlink" title="make -j 并行编译"></a>make -j 并行编译</h3><p>在多核CPU上利用”-j”参数并行编译，以加快编译速度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4    /* 4个线程同时执行 */</span><br></pre></td></tr></table></figure>
<h3 id="Werror"><a href="#Werror" class="headerlink" title="-Werror"></a>-Werror</h3><p>编译过程中出现告警视为错误，立刻停止编译</p>
<h2 id="输出调试"><a href="#输出调试" class="headerlink" title="输出调试"></a>输出调试</h2><h3 id="warning"><a href="#warning" class="headerlink" title="$(warning)"></a>$(warning)</h3><p>利用$(warning)内置函数可以调试Makefile中的变量</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = main.o test.o debug.o</span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> <span class="variable">$(OBJS)</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="echo"><a href="#echo" class="headerlink" title="@echo"></a>@echo</h3><p>如果在Makefile中打印一些提示过程字符串，需要使用echo，但是如果直接用echo，执行过程中会把这一行命令也打印出来</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o:%.c:</span></span><br><span class="line">    echo <span class="string">&quot;compile start&quot;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际会打印</span></span><br><span class="line"><span class="comment"># echo &quot;compile start&quot;</span></span><br><span class="line"><span class="comment"># compile start</span></span><br></pre></td></tr></table></figure>
<p>命令前加”@”可以只输出命令执行结果，不输出命令本身</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o:%.c:</span></span><br><span class="line">    @echo <span class="string">&quot;compile start&quot;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际会打印</span></span><br><span class="line"><span class="comment"># compile start</span></span><br></pre></td></tr></table></figure>
<h2 id="输出编译辅助信息"><a href="#输出编译辅助信息" class="headerlink" title="输出编译辅助信息"></a>输出编译辅助信息</h2><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>gcc编译工具”arm-linux-eabi-size”可以输出统计所有目标文件的占用大小</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(OBJSIZE)</span> <span class="variable">$(OBJS)</span> &gt;&gt; test.size</span><br><span class="line"></span><br><span class="line">cat libtensorflow-microlite.size </span><br><span class="line">   text       data        bss        dec        hex    filename</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>panda基本操作</title>
    <url>/2019/05/27/panda%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="DataFrame基本操作"><a href="#DataFrame基本操作" class="headerlink" title="DataFrame基本操作"></a>DataFrame基本操作</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除行或列使用的函数都是<code>drop</code></p>
<h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop(<span class="string">&#x27;col_name&#x27;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>col_name 是列名标识</li>
<li><code>axis</code>用来标识删除的是行还是列</li>
</ul>
<h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop([row_nr1, row_nr2, ...])</span><br></pre></td></tr></table></figure>
<p>要删除的行号以<code>list</code>形式传入</p>
<h2 id="时间序列数据处理"><a href="#时间序列数据处理" class="headerlink" title="时间序列数据处理"></a>时间序列数据处理</h2><h3 id="将字典列表转化为DataFrame"><a href="#将字典列表转化为DataFrame" class="headerlink" title="将字典列表转化为DataFrame"></a>将字典列表转化为DataFrame</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">x = [&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;2000-01-01&#x27;</span>&#125;, </span><br><span class="line">     &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;2000-01-02&#x27;</span>&#125;, </span><br><span class="line">     &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;2000-01-03&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;2000-01-04&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;2000-01-05&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;2000-01-06&#x27;</span>&#125;,]</span><br><span class="line">df = pd.DataFrame(x, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>查看数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; df</span><br><span class="line">   a  b           c</span><br><span class="line">0  1  2  2000-01-01</span><br><span class="line">1  2  3  2000-01-02</span><br><span class="line">2  3  4  2000-01-03</span><br><span class="line">3  4  5  2000-01-04</span><br><span class="line">4  5  6  2000-01-05</span><br><span class="line">5  6  7  2000-01-06</span><br></pre></td></tr></table></figure></p>
<h3 id="修改索引为日期"><a href="#修改索引为日期" class="headerlink" title="修改索引为日期"></a>修改索引为日期</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; df.set_index(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            a  b</span><br><span class="line">c</span><br><span class="line">2000-01-01  1  2</span><br><span class="line">2000-01-02  2  3</span><br><span class="line">2000-01-03  3  4</span><br><span class="line">2000-01-04  4  5</span><br><span class="line">2000-01-05  5  6</span><br><span class="line">2000-01-06  6  7</span><br></pre></td></tr></table></figure></p>
<h3 id="DataFrame转化为csv文件"><a href="#DataFrame转化为csv文件" class="headerlink" title="DataFrame转化为csv文件"></a>DataFrame转化为csv文件</h3>]]></content>
      <categories>
        <category>Program Language</category>
        <category>Python</category>
        <category>Pandas</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pm-freezing-task</title>
    <url>/2019/12/11/pm-freezing-task/</url>
    <content><![CDATA[<p>Linux PM suspend会冻结所有用户空间进程和大部分内核线程，本文分析梳理冻结过程是如何实现的</p>
<p>参考文档</p>
<ul>
<li>kernel document：Document/power/freezing-of-tasks.txt</li>
<li><a href="http://www.wowotech.net/pm_subsystem/237.html">蜗窝科技-Linux进程冻结技术</a></li>
</ul>
<h2 id="为什么要冻结进程"><a href="#为什么要冻结进程" class="headerlink" title="为什么要冻结进程"></a>为什么要冻结进程</h2><p>主要是以下几点原因</p>
<ul>
<li>protect fs<br>主要原因是防止文件系统在hibernation过程中损坏。目前，kernel还没有检查文件系统的简单方法，因此，如果对磁盘上的文件系统数据或元数据进行了任何修改，kernel就无法将它们恢复到修改之前的状态。同时，每个hibernation镜像都包含一些与文件系统相关的信息，这些信息必须与从镜像恢复系统内存状态后磁盘上数据和元数据的状态一致(否则文件系统将受到严重损坏，通常使它们几乎无法修复)。因此，kernel会冻结那些可能导致磁盘上文件系统的数据和元数据在创建hibernation镜像之后和系统最终关闭之前被修改的任务。其中大多数是用户空间进程，但是如果任何内核线程可能导致这样的事情发生，它们必须是可释放的</li>
<li>memory<br>为了创建hibernation镜像，kernel需要在设备停用之前free大量内存(接近50%的有效RAM空间)，因为kernel需要用这些内存做swapping out。在镜像的内存被释放之后，kernel不希望任务分配额外的内存，因此通过提前冻结它们来防止。</li>
<li>protect devices<br>防止用户空间进程和一些内核线程干扰设备的suspend和resume。例如，当kernel suspend设备时，在第二个CPU上运行的用户空间进程可能会很麻烦，如果没有任务冻结，kernel需要一些保护措施，以防止在这种情况下可能发生的竞争情况</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>进程冻结的代码实现主要位于以下文件中</p>
<ul>
<li>kernel/kernel/power/suspend.c</li>
<li>kernel/kernel/power/process.c</li>
<li>kernel/kernel/power/freezer.c</li>
</ul>
<p>进程冻结的入口函数为<code>suspend_freeze_processes()</code>，调用链为<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">enter_state --&gt;</span><br><span class="line">  suspend_prepare --&gt;</span><br><span class="line">    suspend_freeze_processes</span><br></pre></td></tr></table></figure></p>
<p>函数<code>suspend_freeze_processes()</code>代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">suspend_freeze_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = freeze_processes();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freeze_processes() automatically thaws every task if freezing</span></span><br><span class="line"><span class="comment">	 * fails. So we need not do anything extra upon error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = freeze_kernel_threads();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freeze_kernel_threads() thaws only kernel threads upon freezing</span></span><br><span class="line"><span class="comment">	 * failure. So we have to thaw the userspace tasks ourselves.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		thaw_processes();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先会调用<code>freeze_processes()</code>来冻结进程，注释说的很清楚，如果失败会在函数内自动解冻进程；然后会调用<code>freeze_kernel_threads()</code>函数来冻结内核线程，如果失败会在函数内部自动解冻内核线程，因此如果失败还需要再调用<code>thaw_processes()</code>解冻进程</p>
<h3 id="freeze-processes"><a href="#freeze-processes" class="headerlink" title="freeze_processes"></a>freeze_processes</h3><p><code>freeze_processes()</code>函数代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeze_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = __usermodehelper_disable(UMH_FREEZING);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure this task doesn&#x27;t get frozen */</span></span><br><span class="line">	current-&gt;flags |= PF_SUSPEND_TASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pm_freezing)</span><br><span class="line">		atomic_inc(&amp;system_freezing_cnt);</span><br><span class="line"></span><br><span class="line">	pm_wakeup_clear();</span><br><span class="line">	pr_info(<span class="string">&quot;Freezing user space processes ... &quot;</span>);</span><br><span class="line">	pm_freezing = <span class="literal">true</span>;</span><br><span class="line">	error = try_to_freeze_tasks(<span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		__usermodehelper_set_disable_depth(UMH_DISABLED);</span><br><span class="line">		pr_cont(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pr_cont(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	BUG_ON(in_atomic());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now that the whole userspace is frozen we need to disbale</span></span><br><span class="line"><span class="comment">	 * the OOM killer to disallow any further interference with</span></span><br><span class="line"><span class="comment">	 * killable tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!error &amp;&amp; !oom_killer_disable())</span><br><span class="line">		error = -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		thaw_processes();</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先禁用了usermodehelper，将当前task标志位<code>PF_SUSPEND_TASK</code>置位，将当前task设置为执行suspend的task，以确保该task不会被冻结。因此冻结进程的实际代码位于函数<code>try_to_freeze_tasks()</code>中</p>
<p><code>try_to_freeze_tasks()</code>函数代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_freeze_tasks</span><span class="params">(<span class="keyword">bool</span> user_only)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> end_time;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> todo;</span><br><span class="line">	<span class="keyword">bool</span> wq_busy = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">	u64 elapsed_msecs64;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> elapsed_msecs;</span><br><span class="line">	<span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> sleep_usecs = USEC_PER_MSEC;</span><br><span class="line"></span><br><span class="line">	do_gettimeofday(&amp;start);</span><br><span class="line"></span><br><span class="line">	end_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!user_only)</span><br><span class="line">		freeze_workqueues_begin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		todo = <span class="number">0</span>;</span><br><span class="line">		read_lock(&amp;tasklist_lock);</span><br><span class="line">		for_each_process_thread(g, p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p == current || !freeze_task(p))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!freezer_should_skip(p))</span><br><span class="line">				todo++;</span><br><span class="line">		&#125;</span><br><span class="line">		read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!user_only) &#123;</span><br><span class="line">			wq_busy = freeze_workqueues_busy();</span><br><span class="line">			todo += wq_busy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!todo || time_after(jiffies, end_time))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pm_wakeup_pending()) &#123;</span><br><span class="line">			wakeup = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We need to retry, but first give the freezing tasks some</span></span><br><span class="line"><span class="comment">		 * time to enter the refrigerator.  Start with an initial</span></span><br><span class="line"><span class="comment">		 * 1 ms sleep followed by exponential backoff until 8 ms.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		usleep_range(sleep_usecs / <span class="number">2</span>, sleep_usecs);</span><br><span class="line">		<span class="keyword">if</span> (sleep_usecs &lt; <span class="number">8</span> * USEC_PER_MSEC)</span><br><span class="line">			sleep_usecs *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	do_gettimeofday(&amp;end);</span><br><span class="line">	elapsed_msecs64 = timeval_to_ns(&amp;end) - timeval_to_ns(&amp;start);</span><br><span class="line">	do_div(elapsed_msecs64, NSEC_PER_MSEC);</span><br><span class="line">	elapsed_msecs = elapsed_msecs64;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (todo) &#123;</span><br><span class="line">		pr_cont(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		pr_err(<span class="string">&quot;Freezing of tasks %s after %d.%03d seconds &quot;</span></span><br><span class="line">		       <span class="string">&quot;(%d tasks refusing to freeze, wq_busy=%d):\n&quot;</span>,</span><br><span class="line">		       wakeup ? <span class="string">&quot;aborted&quot;</span> : <span class="string">&quot;failed&quot;</span>,</span><br><span class="line">		       elapsed_msecs / <span class="number">1000</span>, elapsed_msecs % <span class="number">1000</span>,</span><br><span class="line">		       todo - wq_busy, wq_busy);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!wakeup) &#123;</span><br><span class="line">			read_lock(&amp;tasklist_lock);</span><br><span class="line">			for_each_process_thread(g, p) &#123;</span><br><span class="line">				<span class="keyword">if</span> (p != current &amp;&amp; !freezer_should_skip(p)</span><br><span class="line">				    &amp;&amp; freezing(p) &amp;&amp; !frozen(p))</span><br><span class="line">					sched_show_task(p);</span><br><span class="line">			&#125;</span><br><span class="line">			read_unlock(&amp;tasklist_lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pr_cont(<span class="string">&quot;(elapsed %d.%03d seconds) &quot;</span>, elapsed_msecs / <span class="number">1000</span>,</span><br><span class="line">			elapsed_msecs % <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> todo ? -EBUSY : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先设置了一个<code>end_time</code>，该操作的作用是确保冻结进程的执行在规定时间内完成，这个时间由全局变量<code>freeze_timeout_msecs</code>控制，它有个初始值，并且可由/sys/power/pm_freeze_timeout节点进行设置</p>
<p>冻结的对象是内核中可以被调度执行的实体，包括用户进程、内核线程和work_queue，<code>freeze_workqueues_begin()</code>函数的作用就是冻结了work_queue。然后在一个循环体内遍历<code>tasklist_lock</code>线程链表，对每个task执行<code>freeze_task()</code>来冻结，循环会通过<code>todo</code>记录某些仍然需要再操作的task，在循环退出后再做一些操作</p>
<h4 id="冻结标志"><a href="#冻结标志" class="headerlink" title="冻结标志"></a>冻结标志</h4><p>这里需要对task的冻结标志位进行介绍，一共有3个和冻结相关标志位</p>
<ul>
<li>PF_NOFREEZE：表明该task不能被冻结</li>
<li>PF_FROZEN：表明该task已经被冻结</li>
<li>PF_FREEZER_SKIP：这个标志是辅助用的</li>
</ul>
<p>未被标记为<code>PF_NOFREEZE</code>的task(所有用户空间的进程和部分内核线程)将被视为‘freezable’可冻结的</p>
<p>这里有几个函数和冻结标志紧密相关</p>
<ul>
<li>freezing：判断task是否正在冻结中</li>
<li>frozen：判断task是否已经被冻结</li>
<li>freezer_should_skip：判断task是否需要跳过冻结</li>
<li>freeze_task：冻结task</li>
</ul>
<p>循环体中主要执行的函数是<code>freeze_task()</code>，代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * freeze_task - send a freeze request to given task</span></span><br><span class="line"><span class="comment"> * @p: task to send the request to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @p is freezing, the freeze request is sent either by sending a fake</span></span><br><span class="line"><span class="comment"> * signal (if it&#x27;s not a kernel thread) or waking it up (if it&#x27;s a kernel</span></span><br><span class="line"><span class="comment"> * thread).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * %false, if @p is not freezing or already frozen; %true, otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">freeze_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This check can race with freezer_do_not_count, but worst case that</span></span><br><span class="line"><span class="comment">	 * will result in an extra wakeup being sent to the task.  It does not</span></span><br><span class="line"><span class="comment">	 * race with freezer_count(), the barriers in freezer_count() and</span></span><br><span class="line"><span class="comment">	 * freezer_should_skip() ensure that either freezer_count() sees</span></span><br><span class="line"><span class="comment">	 * freezing == true in try_to_freeze() and freezes, or</span></span><br><span class="line"><span class="comment">	 * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task</span></span><br><span class="line"><span class="comment">	 * normally.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (freezer_should_skip(p))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;freezer_lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (!freezing(p) || frozen(p)) &#123;</span><br><span class="line">		spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">		fake_signal_wake_up(p);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		wake_up_state(p, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是进行了几个判断，如果task跳过冻结、正在冻结中、或者是已经冻结，则返回false，循环体的<code>todo</code>不会增加。那么接下来需要处理的就是需要被冻结的task。如果是用户空间进程，则通过<code>fake_signal_wake_up()</code>函数发送一个假信号用来唤醒进程，如果是kernel线程，则调用<code>wake_up_state()</code>来中断唤醒线程。所有可冻结的task必须通过调用<code>try_to_freeze()</code>来响应该唤醒</p>
<p>对于用户空间进程而言，在其信号处理句柄中会自动调用<code>try_to_freeze()</code>，但是可冻结的内核线程必须在适当的位置显式的调用<code>wait_event_freezable()</code>或者<code>wait_event_freezable_timeout()</code>来间接的调用<code>try_to_freeze()</code>，并作一些安全检查</p>
<h4 id="try-to-freeze"><a href="#try-to-freeze" class="headerlink" title="try_to_freeze"></a>try_to_freeze</h4><p>该函数定义在include/linux/freeze.h中，代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION</span></span><br><span class="line"><span class="comment"> * If try_to_freeze causes a lockdep warning it means the caller may deadlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze_unsafe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	might_sleep();</span><br><span class="line">	<span class="keyword">if</span> (likely(!freezing(current)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> __refrigerator(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">try_to_freeze</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(current-&gt;flags &amp; PF_NOFREEZE))</span><br><span class="line">		debug_check_no_locks_held();</span><br><span class="line">	<span class="keyword">return</span> try_to_freeze_unsafe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会调用<code>__refrigerator()</code>函数，代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Refrigerator is place where frozen processes are stored :-). */</span></span><br><span class="line"><span class="keyword">bool</span> __refrigerator(<span class="keyword">bool</span> check_kthr_stop)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Hmm, should we be allowed to suspend when there are realtime</span></span><br><span class="line"><span class="comment">	   processes around? */</span></span><br><span class="line">	<span class="keyword">bool</span> was_frozen = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">long</span> save = current-&gt;state;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s entered refrigerator\n&quot;</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		spin_lock_irq(&amp;freezer_lock);</span><br><span class="line">		current-&gt;flags |= PF_FROZEN;</span><br><span class="line">		<span class="keyword">if</span> (!freezing(current) ||</span><br><span class="line">		    (check_kthr_stop &amp;&amp; kthread_should_stop()))</span><br><span class="line">			current-&gt;flags &amp;= ~PF_FROZEN;</span><br><span class="line">		spin_unlock_irq(&amp;freezer_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(current-&gt;flags &amp; PF_FROZEN))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		was_frozen = <span class="literal">true</span>;</span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;%s left refrigerator\n&quot;</span>, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore saved task state before returning.  The mb&#x27;d version</span></span><br><span class="line"><span class="comment">	 * needs to be used; otherwise, it might silently break</span></span><br><span class="line"><span class="comment">	 * synchronization which depends on ordered task state change.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_current_state(save);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> was_frozen;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__refrigerator);</span><br></pre></td></tr></table></figure></p>
<p>设置task不可被中断，然后将task标志<code>PF_FROZEN</code>置位，表明task已经被冻结，本质上是在一个死循环中，只有当标志位<code>PF_FROZEN</code>被清除后才会退出</p>
<h3 id="freeze-kernel-threads"><a href="#freeze-kernel-threads" class="headerlink" title="freeze_kernel_threads"></a>freeze_kernel_threads</h3><p>函数<code>freeze_kernel_threads()</code>内部实际上还是通过调用<code>try_to_freeze_tasks()</code>来处理<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * freeze_kernel_threads - Make freezable kernel threads go to the refrigerator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, returns 0.  On failure, -errno and only the kernel threads are</span></span><br><span class="line"><span class="comment"> * thawed, so as to give a chance to the caller to do additional cleanups</span></span><br><span class="line"><span class="comment"> * (if any) before thawing the userspace tasks. So, it is the responsibility</span></span><br><span class="line"><span class="comment"> * of the caller to thaw the userspace tasks, when the time is right.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeze_kernel_threads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;Freezing remaining freezable tasks ... &quot;</span>);</span><br><span class="line"></span><br><span class="line">	pm_nosig_freezing = <span class="literal">true</span>;</span><br><span class="line">	error = try_to_freeze_tasks(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!error)</span><br><span class="line">		pr_cont(<span class="string">&quot;done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pr_cont(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	BUG_ON(in_atomic());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		thaw_kernel_threads();</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="thaw-processes"><a href="#thaw-processes" class="headerlink" title="thaw_processes"></a>thaw_processes</h3><p><code>thaw_processes()</code>代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thaw_processes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> current;</span><br><span class="line"></span><br><span class="line">	trace_suspend_resume(TPS(<span class="string">&quot;thaw_processes&quot;</span>), <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (pm_freezing)</span><br><span class="line">		atomic_dec(&amp;system_freezing_cnt);</span><br><span class="line">	pm_freezing = <span class="literal">false</span>;</span><br><span class="line">	pm_nosig_freezing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	oom_killer_enable();</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;Restarting tasks ... &quot;</span>);</span><br><span class="line"></span><br><span class="line">	__usermodehelper_set_disable_depth(UMH_FREEZING);</span><br><span class="line">	thaw_workqueues();</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;tasklist_lock);</span><br><span class="line">	for_each_process_thread(g, p) &#123;</span><br><span class="line">		<span class="comment">/* No other threads should have PF_SUSPEND_TASK set */</span></span><br><span class="line">		WARN_ON((p != curr) &amp;&amp; (p-&gt;flags &amp; PF_SUSPEND_TASK));</span><br><span class="line">		__thaw_task(p);</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">	WARN_ON(!(curr-&gt;flags &amp; PF_SUSPEND_TASK));</span><br><span class="line">	curr-&gt;flags &amp;= ~PF_SUSPEND_TASK;</span><br><span class="line"></span><br><span class="line">	usermodehelper_enable();</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">	pr_cont(<span class="string">&quot;done.\n&quot;</span>);</span><br><span class="line">	trace_suspend_resume(TPS(<span class="string">&quot;thaw_processes&quot;</span>), <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先启动了<code>OOM killer</code>线程，然后禁用usermodehelper，<code>thaw_workqueues()</code>函数解冻了work_queue。遍历<code>tasklist_lock</code>，对每个task调用<code>__thaw_task()</code>函数</p>
<p><code>__thaw_task()</code>函数代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __thaw_task(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;freezer_lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (frozen(p))</span><br><span class="line">		wake_up_process(p);</span><br><span class="line">	spin_unlock_irqrestore(&amp;freezer_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wake_up_process()</code>的处理涉及到Linux进程管理相关内容，暂不做分析</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于休眠需要保护文件系统和设备等资源以防止用户空间和部分内核空间线程的操作，因此在休眠的第一步kernel冻结了所有用户空间进程和部分内核线程</p>
<p>冻结task的实质是通过<code>PF_FROZEN</code>标志位和信号来控制task进入/退出一个死循环，达到户空间进程和部分内核线程不进行任何实际操作的目的</p>
]]></content>
      <categories>
        <category>Linux Kernel</category>
        <category>电源管理</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
        <tag>PM</tag>
      </tags>
  </entry>
  <entry>
    <title>python-kafka抓包分析</title>
    <url>/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>看源码看了一段时间了，发现很多协议上有些概念和流程理解的不到位，因此搭建环境来抓包分析一下整个消息交互的过程是怎么样的</p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>kafka的broker(只有一个)服务运行于虚拟机上的docker容器(dk-kafka-test-v2)中，虚拟机和容器都是centos7系统，宿主和容器之间网络模式为Bridge模式。环境示意图如下<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-01.png" alt="回调上下文"><br>容器连接到宿主的docker0桥上，宿主地址172.18.0.1，容器地址172.18.0.2，在容器中使用tcpdump抓包</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="环境安装问题"><a href="#环境安装问题" class="headerlink" title="环境安装问题"></a>环境安装问题</h4><p>需要安装以下内容</p>
<ul>
<li>jdk</li>
<li>zookeeper</li>
<li>kafka</li>
</ul>
<h4 id="docker的hostname问题"><a href="#docker的hostname问题" class="headerlink" title="docker的hostname问题"></a>docker的hostname问题</h4><p>在docker中运行kafka服务后，宿主运行load_example.py，会报<code>DNS lookup failed</code>错误，因为docker的hostname默认是一串数字，调用<code>socket.getaddrinfo()</code>函数解析不了该hostname，需手动修改/etc/hosts<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.2      172.17.0.2</span><br><span class="line">172.18.0.2      172.18.0.2</span><br></pre></td></tr></table></figure></p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="broker启动"><a href="#broker启动" class="headerlink" title="broker启动"></a>broker启动</h3><p>容器中已经编写好shell脚本启动zookeeper和broker<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kafka_path=<span class="string">&#x27;kafka_broker&#x27;</span></span><br><span class="line">zookeeper_path=<span class="string">&#x27;zookeeper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line">./<span class="variable">$zookeeper_path</span>/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line">./<span class="variable">$kafka_path</span>/bin/kafka-server-start.sh <span class="variable">$kafka_path</span>/config/server.properties</span><br></pre></td></tr></table></figure><br>执行脚本，broker启动运行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@3b86889153b0 local]# ./kafka_broker_start.sh   </span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... already running as process 84.</span><br><span class="line">[2019-05-07 12:33:13,714] INFO Registered kafka:type=kafka.Log4jController MBean (kafka.utils.Log4jControllerRegistration$)</span><br><span class="line">[2019-05-07 12:33:14,630] INFO starting (kafka.server.KafkaServer)</span><br><span class="line">[2019-05-07 12:33:14,632] INFO Connecting to zookeeper on localhost:2181 (kafka.server.KafkaServer)</span><br><span class="line">[2019-05-07 12:33:14,676] INFO [ZooKeeperClient] Initializing a new session to localhost:2181. (kafka.zookeeper.ZooKeeperClient)</span><br><span class="line">[2019-05-07 12:33:14,683] INFO Client environment:zookeeper.version=3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 00:39 GMT (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2019-05-07 12:33:14,684] INFO Client environment:host.name=3b86889153b0 (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2019-05-07 12:33:14,684] INFO Client environment:java.version=12.0.1 (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2019-05-07 12:33:14,684] INFO Client environment:java.vendor=Oracle Corporation (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">[2019-05-07 12:33:14,684] INFO Client environment:java.home=/usr/local/java (org.apache.zookeeper.ZooKeeper)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="启动抓包"><a href="#启动抓包" class="headerlink" title="启动抓包"></a>启动抓包</h3><p>抓包使用tcpdump工具，执行以下命令，指定截获eth1接口的端口号为9092的tcp包，保存到capture.cap文件<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1 tcp port 9092 -w capture.cap</span><br></pre></td></tr></table></figure></p>
<h3 id="宿主运行load-example-py"><a href="#宿主运行load-example-py" class="headerlink" title="宿主运行load_example.py"></a>宿主运行load_example.py</h3><p>宿主上运行python-kafka的load_example.py测试脚本，该脚本会启动一个生产者和一个消费者，生产者循环生产数据，消费者循环消费数据，需要先修改生产者和消费者配置的broker地址<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    big_msg = <span class="string">b&#x27;1&#x27;</span> * msg_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        producer = KafkaProducer(bootstrap_servers=<span class="string">&#x27;172.18.0.2:9092&#x27;</span>)</span><br><span class="line">        self.sent = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> producer_stop.is_set():</span><br><span class="line">            producer.send(<span class="string">&#x27;my-topic&#x27;</span>, self.big_msg)</span><br><span class="line">            self.sent += <span class="number">1</span></span><br><span class="line">        producer.flush()</span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        consumer = KafkaConsumer(bootstrap_servers=<span class="string">&#x27;172.18.0.2:9092&#x27;</span>,</span><br><span class="line">                                 auto_offset_reset=<span class="string">&#x27;earliest&#x27;</span>)</span><br><span class="line">        consumer.subscribe([<span class="string">&#x27;my-topic&#x27;</span>])</span><br><span class="line">        self.valid = <span class="number">0</span></span><br><span class="line">        self.invalid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> consumer:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(message.value) == msg_size:</span><br><span class="line">                self.valid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.invalid += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>执行脚本后，开始数据传输，打开了日志的DEBUG模式<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost kafka-python]# python benchmarks/load_example.py                        </span><br><span class="line">2019-05-07 22:34:07,437.437.673091888:kafka.producer.kafka:139872394159872:DEBUG:32192:Starting the Kafka producer</span><br><span class="line">2019-05-07 22:34:07,438.438.35401535:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name connections-closed</span><br><span class="line">2019-05-07 22:34:07,438.438.606977463:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name connections-created</span><br><span class="line">2019-05-07 22:34:07,438.438.797950745:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name select-time</span><br><span class="line">2019-05-07 22:34:07,439.439.13602829:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name io-time</span><br><span class="line">2019-05-07 22:34:07,439.439.702033997:kafka.metrics.metrics:139872385505024:DEBUG:32192:Added sensor with name connections-closed</span><br><span class="line">2019-05-07 22:34:07,440.440.099954605:kafka.client:139872394159872:INFO:32192:Bootstrapping cluster metadata from [(&#x27;172.18.0.2&#x27;, 9092, 2)]</span><br><span class="line">2019-05-07 22:34:07,440.440.378904343:kafka.metrics.metrics:139872385505024:DEBUG:32192:Added sensor with name connections-created</span><br><span class="line">2019-05-07 22:34:07,440.440.948963165:kafka.metrics.metrics:139872385505024:DEBUG:32192:Added sensor with name select-time</span><br><span class="line">2019-05-07 22:34:07,440.440.732955933:kafka.client:139872394159872:DEBUG:32192:Attempting to bootstrap via node at 172.18.0.2:9092</span><br><span class="line">2019-05-07 22:34:07,441.441.575050354:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name bytes-sent-received</span><br><span class="line">2019-05-07 22:34:07,441.441.804885864:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name bytes-sent</span><br><span class="line">2019-05-07 22:34:07,442.442.168951035:kafka.metrics.metrics:139872394159872:DEBUG:32192:Added sensor with name bytes-received</span><br><span class="line">2019-05-07 22:34:07,442.442.622900009:kafka.metrics.metrics:139872385505024:DEBUG:32192:Added sensor with name io-time</span><br><span class="line">2019-05-07 22:34:07,443.443.308115005:kafka.client:139872385505024:INFO:32192:Bootstrapping cluster metadata from [(&#x27;172.18.0.2&#x27;, 9092, 2)]</span><br><span class="line">2019-05-07 22:34:07,443.443.564891815:kafka.client:139872385505024:DEBUG:32192:Attempting to bootstrap via node at 172.18.0.2:9092</span><br><span class="line">2019-05-07 22:34:07,444.444.015979767:kafka.metrics.metrics:139872385505024:DEBUG:32192:Added sensor with name bytes-sent-received</span><br><span class="line">2019-05-07 22:34:07,444.444.26202774:kafka.metrics.metrics:139872385505024:DEBUG:32192:Added sensor with name bytes-sent</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h3 id="wireshark打开抓包文件"><a href="#wireshark打开抓包文件" class="headerlink" title="wireshark打开抓包文件"></a>wireshark打开抓包文件</h3><p>宿主上执行以下命令，将容器中的抓包文件拷贝到共享文件夹下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp dk-kafka-v2:/usr/local/capture.cap /home/share/</span><br></pre></td></tr></table></figure><br>wireshark(3.0.0)打开该文件，内容如下<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-02.png" alt="wireshark打开抓包文件"><br>会发现其中有很多SMPP类型的报文，这其实就是kafka协议报文，wireshark是支持kafka协议的(版本过低可能解析不了，因为kafka协议也是最新的)</p>
<p>选中一包SMPP数据，右击选择解码为<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-03.png" alt="wireshark打开抓包文件"></p>
<p>在弹出的对话框中将当前值选择为kafka<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-04.png" alt="wireshark打开抓包文件"></p>
<p>确认后，显示的协议类型就是kafka了<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-05.png" alt="wireshark打开抓包文件"></p>
<h2 id="报文分析"><a href="#报文分析" class="headerlink" title="报文分析"></a>报文分析</h2><ul>
<li>抓包文件 <a href="/download/python-kafka抓包分析/capture.cap">capture.cap</a></li>
<li>load_example.py运行日志 <a href="/download/python-kafka抓包分析/load_example_log.txt">load_example_log.txt</a></li>
</ul>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>可看到前6个报文分别是生产者和消费者与broker的tcp三次握手，生产者源端口号为38212，消费者源端口号为38214</p>
<h3 id="metadata请求"><a href="#metadata请求" class="headerlink" title="metadata请求"></a>metadata请求</h3><p>连接建立之后，生产者和消费者都向broker发起了metadata请求，报文结构如下图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-06.png" alt="wireshark打开抓包文件"><br>该请求中API Key为3，还包含了API Version、Correlation ID等字段</p>
<p>那么什么是metadata呢？由于kafka的broker是分布式集群，metadata记录了一些和集群有关的映射信息</p>
<ul>
<li>broker.id与node的对应关系</li>
<li>topic与partition的对应关系</li>
<li>node与partition的对应关系</li>
</ul>
<p>详细的metadata解释见<a href="https://www.jianshu.com/p/bb7c332eac25">Kafka 源码之生产者 Metadata 更新机制（二）</a></p>
<p>broker接收到该请求后，首先会回一个ack，然后回复一个metadata响应，报文结构如图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-07.png" alt="wireshark打开抓包文件"></p>
<p>返回的结构中，主要包含两大块信息：Broker Metadata和Topic Metadata。Broker Metadata中只有一个Broker，包含该broker的Node ID、Host和Port，因为本环境中只有一个broker，就是在容器中的broker。Topic Metadata共有3个，分别是my-topic、hellotopic和__consumer_offsets，因为load_example.py脚本创建的topic是my-topic，另外两个是做测试时创建的</p>
<p>每隔topic结构中包含该topic的名字和一个partition，什么是partition呢？一个topic可以有多个partition，消息会被发送到不同的partition，每个partition其实就是broker下的一个log文件，存放消息。多个partition会有一个leader，负责备份和写入，Replicas就是备份信息</p>
<h3 id="ApiVersion请求"><a href="#ApiVersion请求" class="headerlink" title="ApiVersion请求"></a>ApiVersion请求</h3><p>猜测可能各个版本的api有些差异，因此要对齐api版本</p>
<p>请求报文结构如图，key为18<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-08.png" alt="wireshark打开抓包文件"></p>
<p>响应报文结构如图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-09.png" alt="wireshark打开抓包文件"><br>broker回返回自己支持的各部分api版本，包括Produce、Fetch、Offsets、Metadata、LeaderAndIsr、StopReplica等等</p>
<h3 id="Offset请求"><a href="#Offset请求" class="headerlink" title="Offset请求"></a>Offset请求</h3><p>消费者会先请求一次Offset，Offset记录了broker当前消费位置信息</p>
<p>请求报文结构如图，key为2<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-10.png" alt="wireshark打开抓包文件"><br>该报文中包含了要请求的topic和partition</p>
<p>响应报文结构如图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-11.png" alt="wireshark打开抓包文件"><br>可以看出my-topic的partition1的offset为12705</p>
<h3 id="Produce请求"><a href="#Produce请求" class="headerlink" title="Produce请求"></a>Produce请求</h3><p>Porduce请求是生产者向broker发送的生产数据请求</p>
<p>请求报文如图，key为0<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-12.png" alt="wireshark打开抓包文件"><br>其中Message Set Size字段告知了数据大小为15556，Message Set-&gt;Message是消息实体，包含了CRC校验头、Magic Byte等内容</p>
<p>响应报文如图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-14.png" alt="wireshark打开抓包文件"><br>返回的报文中包含一个offset</p>
<h3 id="Fetch请求"><a href="#Fetch请求" class="headerlink" title="Fetch请求"></a>Fetch请求</h3><p>Fetch请求是消费者向broker发出的请求，向broker申请消费数据</p>
<p>请求报文结构如图，key为1<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-13.png" alt="wireshark打开抓包文件"><br>其中告知了请求的topic、partition、offset和最大字节数Max bytes</p>
<p>响应报文如图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-15.png" alt="wireshark打开抓包文件"><br>响应报文不是kafka协议报文，而是直接tcp流，将数据发过来</p>
<p>总结消息交过流程如图<br><img src="/2019/05/07/python-kafka%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image/packet-capture-16.png" alt="wireshark打开抓包文件"></p>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>python-kafka</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Docker</tag>
        <tag>Kafka</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>一些链接</title>
    <url>/2019/05/29/%E4%B8%80%E4%BA%9B%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="嵌入式开发"><a href="#嵌入式开发" class="headerlink" title="嵌入式开发"></a>嵌入式开发</h2><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0472m/vfb1478006546674.html#">ARM Developer Document</a></p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul>
<li><p><a href="http://pandas.pydata.org/">Pandas官方文档</a></p>
</li>
<li><p><a href="http://www.pythontutor.com/">pythontutor</a><br>一个将python代码转化为可视化动画的网站</p>
</li>
<li><p><a href="https://pywavelets.readthedocs.io/en/latest/">Pywavelets</a><br>Python小波变换库官方网站，包括安装使用说明，以及API介绍</p>
</li>
</ul>
<h2 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h2><ul>
<li><p><a href="https://blog.floydhub.com/">FloydHub Blog</a><br>一个深度学习、AI、云GPU的博客，里面的文章很前沿</p>
</li>
<li><p><a href="https://machinelearningmastery.com/">Jason Brownlee PhD</a><br>一个机器学习博主，写了很多机器学习、数据分析相关文章</p>
</li>
<li><p><a href="http://cs231n.github.io/">CS231n</a><br>斯坦福大学机器学习公开课笔记</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://medium.com/">Medium</a><br>一个类似简书的阅读写作平台，支持start、follow功能，内容质量较高</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>优先队列(PriorityQueue)</title>
    <url>/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>普通的队列是一种FIFO结构，在优先队列(PriorityQueue)中，数据存在优先级，在进行出队操作时，具有最大(MaxPriorityQueue)或最小(MinPriorityQueue)优先级的元素最先出队。在很多应用场景中，都需要这种对数据进行有序处理或者按照优先级处理的方式</p>
<p>优先队列的应用很广泛，最常见的是进行任务调度，当有多个任务都需要处理的时候，为不同的任务划分优先级，并分别调度；优先队列还可以开发图搜索算法、数据压缩算法等</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>优先队列的实现有很多方式，例如链表和数组。利用二叉堆来实现优先队列是一种较为高效的做法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构</th>
<th>入队</th>
<th>出队最大元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>有序数组</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>无序数组</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>堆</td>
<td>logN</td>
<td>logN</td>
</tr>
</tbody>
</table>
</div>
<p>二叉堆实现的优先队列能够保证在插入和删除两个维度都较快</p>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆是一组能够用堆有序的完全二叉树排列的元素，并在数组中按照层级存储</p>
<p>可以用下图来表示一个二叉堆</p>
<p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image/PriorityQueue-01.png" alt></p>
<p>假设字幕A~Z表示的数值依次增大，则上图表示的是一个最大二叉堆(大根堆)，根节点”T”最大，二叉堆中任意子节点的数值不大于父节点数值</p>
<p>二叉堆有以下特性</p>
<ul>
<li><p>位置为k的节点父节点位置为k/2，两个子节点位置分别为2k和2k+1</p>
</li>
<li><p>大小为N的完全二叉树高度为logN</p>
</li>
</ul>
<p>以上性质决定了二叉堆在进行遍历或者搜索的路径是跳跃层级的，无论是插入还是删除操作，由于树高最大logN，因此操作的复杂度最大也为logN</p>
<h3 id="数组实现二叉堆"><a href="#数组实现二叉堆" class="headerlink" title="数组实现二叉堆"></a>数组实现二叉堆</h3><p>使用数组实现二叉堆是非常高效的，二叉堆中元素的位置和数组索引的关系可以用下图表示</p>
<p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-02.png" alt></p>
<p>使用数组实现二叉堆，仅利用数组索引就可以沿着树上下移动，非常便利。要注意为了编程时父子位置关系的统一性，数组的第一个位置不使用</p>
<p>在对堆进行操作时，会首先进行一些简单的改动，例如插入时先将元素插入到堆底，或者删除时先删除堆顶元素，这样会打破原有堆的有序状态，然后再将堆恢复有序状态(堆的有序化)。本文以最大优先队列为例，对堆的有序化操作进行说明</p>
<p>有序化需要用到两个辅助函数：比较(less)和交换(exch)。less函数是为了实现优先队列的泛化，希望实现的优先队列是一种泛型数据结构，而非某一种特定的数据结构，因此对于某一种具体的数据结构和类型，需要提供对应的比较函数”compare”，例如字符串String、文件File、时间Time等；交换两个元素是优先队列中使用非常频繁的操作，因此提取为单独的函数。以下是less和exch的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">less</span><span class="params">(array, compare, i, j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(array[i], array[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(array, i, j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上浮-swim"><a href="#上浮-swim" class="headerlink" title="上浮(swim)"></a>上浮(swim)</h4><p>当插入一个元素到堆底后，如果该元素比其父节点更大，就需要通过上浮操作来对堆进行有序化。例如在G节点下向堆中插入元素”Y”</p>
<p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-03.png" alt></p>
<p>“Y”元素只需要一遍一遍的与其父节点进行比较，并交换它们的位置，当”Y”元素到达合适的位置时，整个堆就变得有序了</p>
<p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-04.png" alt></p>
<p>整个过程是插入元素不断地向上”浮动“，不在上浮路径上的元素都保持不变。有序化后部分元素的所在层数会发生变化。上浮的伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k: new item&#x27;s index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((k&gt;<span class="number">1</span>) &amp;&amp; less(k/<span class="number">2</span>,k)) &#123;</span><br><span class="line">        exch(k/<span class="number">2</span>, k);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下沉-sink"><a href="#下沉-sink" class="headerlink" title="下沉(sink)"></a>下沉(sink)</h4><p>当某个元素变得比它的两个子节点或是其中之一小，通过下沉操作来恢复有序状态。例如将堆顶元素”T”删除后再将”G”元素放在原先”T”元素的位置</p>
<p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-05.png" alt></p>
<p>“G”元素只需要一遍一遍与其子节点进行比较，并交换位置，当”G”元素到达合适的位置时，整个堆就变得有序了</p>
<p><img src="/2020/08/30/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/image\PriorityQueue-06.png" alt></p>
<p>下沉的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">        j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> ((j&lt;N) &amp;&amp;  less(j, j+<span class="number">1</span>)) </span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        exch(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p>由于数组需要在创建时分配固定大小，因此为了提高利用的灵活性，需要队列能够自动调整数组大小。太过频繁的重新调整会增大开销，较为合理的方式是</p>
<ul>
<li><p>当数组满时，扩容为原数组2倍</p>
</li>
<li><p>当数组元素大小减小到数组容量时，减小容量为原数组一半</p>
</li>
</ul>
<h3 id="C语言实现MinPQ"><a href="#C语言实现MinPQ" class="headerlink" title="C语言实现MinPQ"></a>C语言实现MinPQ</h3><p><code>MinPQ</code>结构定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- MinPQ --&#123;*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">minpq</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> node_nr;        <span class="comment">/* node number */</span></span><br><span class="line">    <span class="keyword">int</span> capacity;       <span class="comment">/* the capacity of queue */</span>     </span><br><span class="line">    <span class="keyword">size_t</span> nodesize;    <span class="comment">/* every node&#x27;s size in the queue */</span>   </span><br><span class="line">    <span class="keyword">int</span> *p;             <span class="comment">/* point to the private priority array */</span></span><br><span class="line">    <span class="keyword">char</span> *q;            <span class="comment">/* point to the node array */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINPQ_F_CDC   0x0001  <span class="comment">/* custom define comparator */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINPQ_F_RES   0x0002  <span class="comment">/* capacity resize */</span></span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;</span><br><span class="line">    <span class="keyword">bool</span> (*comparator)(<span class="keyword">void</span> *, <span class="keyword">void</span> *);    <span class="comment">/* point to custom define comparator */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> info_width;     <span class="comment">/* use fo debug and dump */</span></span><br><span class="line">    <span class="keyword">void</span> (*info_prior_handle)(struct _minpq *, <span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>);    <span class="comment">/* use fo debug and dump */</span></span><br><span class="line">    <span class="keyword">void</span> (*info_value_handle)(struct _minpq *, <span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>);    <span class="comment">/* use fo debug and dump */</span></span><br><span class="line">&#125; MinPQ;</span><br></pre></td></tr></table></figure>
<p>创建<code>MinPQ</code>，创建函数需要传入节点大小和容量，如果容量为0，默认支持自动扩容；如果使用自定义优先级，需要传入比较器<code>comparator</code>。创建函数内部会创建并维护一个内部默认的优先级数组<code>p</code>，该数组是整型类型，如果要用默认的整型优先级，后续插入元素时可传入优先级数值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a Min Priroity Queue(MinPQ)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @nodesize: every node&#x27;s size in the queue</span></span><br><span class="line"><span class="comment"> * @capacity: the capacity of queue</span></span><br><span class="line"><span class="comment"> * @comparator: custom define comparator</span></span><br><span class="line"><span class="comment"> * @flags: queue&#x27;s features</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return: MinPQ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MinPQ *<span class="title">MinPQ_create</span><span class="params">(<span class="keyword">size_t</span> nodesize, <span class="keyword">int</span> capacity, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span>(*comparator)(<span class="keyword">void</span> *, <span class="keyword">void</span> *), <span class="keyword">uint16_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> allocnr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* params check */</span></span><br><span class="line">    <span class="keyword">if</span> (nodesize &lt;= <span class="number">0</span>) &#123;log_err(<span class="string">&quot;nodesize zero&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;log_err(<span class="string">&quot;capacity invaild&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">    MinPQ *q = zalloc(<span class="keyword">sizeof</span>(MinPQ));</span><br><span class="line">    <span class="keyword">if</span> (!q) &#123;log_err(<span class="string">&quot;MinPQ create error&quot;</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;node_nr = <span class="number">0</span>;</span><br><span class="line">    q-&gt;nodesize = nodesize;</span><br><span class="line">    q-&gt;info_width = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    q-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;    <span class="comment">/* if no capacity, we set resize flag auto */</span></span><br><span class="line">        mask_push(q-&gt;flags, MINPQ_F_RES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;comparator = comparator;</span><br><span class="line">        mask_push(q-&gt;flags, MINPQ_F_CDC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mask_push(q-&gt;flags, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!capacity) &#123;</span><br><span class="line">        allocnr = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        allocnr = capacity + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alloc private priority */</span></span><br><span class="line">    q-&gt;p = zalloc(allocnr*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    q-&gt;q = zalloc(allocnr*q-&gt;node_nr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素，会首先检查容量和是否支持扩容；新节点先放在堆底，然后上浮操作进行有序化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * MinPQ insert operation</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @q: the queue you want to do insert</span></span><br><span class="line"><span class="comment"> * @u: the node you want to insert</span></span><br><span class="line"><span class="comment"> * @p: the priority of insert node, if use custom define priority, don&#x27;t need this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">err_type <span class="title">MinPQ_insert</span><span class="params">(struct _minpq *q, <span class="keyword">void</span> *u, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MinPQ_full(q)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask_exst(q-&gt;flags, MINPQ_F_RES)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q-&gt;capacity) q-&gt;capacity = <span class="number">1</span>;</span><br><span class="line">            _resize(q, q-&gt;capacity*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log_err(<span class="string">&quot;MinPQ full&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> et_full;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;p[++q-&gt;node_nr] = p;</span><br><span class="line">    addr = q-&gt;q + q-&gt;nodesize*q-&gt;node_nr;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr, u, q-&gt;nodesize);</span><br><span class="line">    _swim(q, q-&gt;node_nr);</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除元素，先将堆顶元素拷贝出来，然后将堆底元素移动到堆顶，调用下沉<code>sink</code>进行有序化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">MinPQ_delmin</span><span class="params">(struct _minpq *q, <span class="keyword">void</span> *u, <span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr1, *addr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MinPQ_empty(q)) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;MinPQ empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr1 = q-&gt;q + q-&gt;nodesize;</span><br><span class="line">    <span class="built_in">memcpy</span>(u, addr1, q-&gt;nodesize);</span><br><span class="line">    *p = q-&gt;p[<span class="number">1</span>];</span><br><span class="line">    q-&gt;p[<span class="number">1</span>] = q-&gt;p[q-&gt;node_nr];</span><br><span class="line">    addr2 = q-&gt;q + q-&gt;nodesize*q-&gt;node_nr;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr1, addr2, q-&gt;nodesize);</span><br><span class="line">    q-&gt;node_nr--;</span><br><span class="line">    _sink(q, <span class="number">1</span>);</span><br><span class="line">    q-&gt;p[q-&gt;node_nr+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((q-&gt;node_nr&gt;<span class="number">0</span>) &amp;&amp; </span><br><span class="line">        (q-&gt;node_nr==(q-&gt;capacity<span class="number">-1</span>)/<span class="number">4</span>) &amp;&amp;</span><br><span class="line">        mask_exst(q-&gt;flags, MINPQ_F_RES)) &#123;</span><br><span class="line">        _resize(q, q-&gt;capacity/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr2 = q-&gt;q + q-&gt;nodesize*(q-&gt;node_nr+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(addr2, <span class="number">0x0</span>, q-&gt;nodesize);</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取指定索引数据，该函数可以结合<code>for</code>循环遍历队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">MinPQ_get</span><span class="params">(struct minpq *q, <span class="keyword">void</span> *u, <span class="keyword">int</span> *p, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (empty(q)) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;MinPQ empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = q-&gt;q + q-&gt;nodesize*index;</span><br><span class="line">    <span class="built_in">memcpy</span>(u, addr, q-&gt;nodesize);</span><br><span class="line">    *p = q-&gt;p[index];</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上浮操作，用到了递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swim(struct _minpq *q, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((k&gt;<span class="number">1</span>) &amp;&amp; (_greater(q, k/<span class="number">2</span>, k))) &#123;</span><br><span class="line">        _swap(q, k, k/<span class="number">2</span>);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下沉操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _sink(struct _minpq *q, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= q-&gt;node_nr) &#123;</span><br><span class="line">        j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> ((j&lt;q-&gt;node_nr) &amp;&amp; (_greater(q, j, j+<span class="number">1</span>)))</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_greater(q, k, j)) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        _swap(q, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交换函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swap(struct __minpq *q, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tempp;</span><br><span class="line">    <span class="keyword">char</span> *addr1, *addr2;</span><br><span class="line">    <span class="keyword">char</span> *tempu = zalloc(q-&gt;nodesize);</span><br><span class="line"></span><br><span class="line">    tempp = q-&gt;p[i];</span><br><span class="line">    q-&gt;p[i] = q-&gt;p[j];</span><br><span class="line">    q-&gt;p[j] = tempp;</span><br><span class="line"></span><br><span class="line">    addr1 = q-&gt;q + q-&gt;nodesize*i;</span><br><span class="line">    addr2 = q-&gt;q + q-&gt;nodesize*j;</span><br><span class="line">    <span class="built_in">memcpy</span>(tempu, addr1, q-&gt;nodesize);</span><br><span class="line">    <span class="built_in">memcpy</span>(addr1, addr2, q-&gt;nodesize);</span><br><span class="line">    <span class="built_in">memcpy</span>(addr2, tempu, q-&gt;nodesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> _greater(struct _minpq *q, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr1, *addr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;comparator) &#123;</span><br><span class="line">        <span class="keyword">return</span> (q-&gt;p[i] &gt; q-&gt;p[j]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr1 = q-&gt;q + q-&gt;nodesize*i;</span><br><span class="line">        addr2 = q-&gt;q + q-&gt;nodesize*j;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;comparator(addr1, addr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err_type _resize(struct _minpq *q, <span class="keyword">int</span> capcaity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capcaity &lt;= q-&gt;node_nr) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;capcaity invaild&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = zalloc(q-&gt;nodesize*(capcaity+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>) &#123;</span><br><span class="line">        log_err(<span class="string">&quot;alloc new error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> et_nomem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">new</span>, q-&gt;q, q-&gt;nodesize*(q-&gt;node_nr+<span class="number">1</span>));</span><br><span class="line">    mem_free(q-&gt;q);</span><br><span class="line">    q-&gt;q = <span class="keyword">new</span>;</span><br><span class="line">    q-&gt;capacity = capcaity;</span><br><span class="line">    <span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些辅助查询函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPQ_size</span><span class="params">(struct _minpq *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;node_nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MinPQ_full</span><span class="params">(struct _minpq *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;capacity == q-&gt;node_nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MinPQ_empty</span><span class="params">(struct _minpq *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;node_nr == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和栈</title>
    <url>/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/</url>
    <content><![CDATA[<p>函数是许多编程语言的代码基本单元，多层函数的嵌套调用在系统层面是依赖栈机制来实现的，此处的栈指的不是软件编程数据结构中的堆和栈，而是由不同体系架构的处理器提供的程序指针寄存器、栈基址寄存器、堆栈寄存器等结构以及操作系统辅助构成的函数运行环境。理解函数调用栈对理解程序在内存中的运行以及理解操作系统进程管理都是很有帮助的。本文尝试回答以下问题</p>
<ul>
<li>什么是函数栈</li>
<li>函数栈为什么能保存上级函数的信息</li>
<li>Linux中如何管理函数栈</li>
<li>函数栈有多大，会溢出吗，溢出了怎么办。平时调试代码时程序崩溃后打印的堆栈信息是什么意思</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在理解函数调用栈之前，需要提前了解一些背景知识，包括计算机中一条指令是如何运行的、CPU对栈的支持、Linux进程虚拟内存空间、栈帧结构</p>
<h3 id="X86-CPU寄存器"><a href="#X86-CPU寄存器" class="headerlink" title="X86 CPU寄存器"></a>X86 CPU寄存器</h3><p>函数调用栈从根本上来说，是由CPU堆栈相关寄存器实现的。不同体系结构对于程序指令运行的处理有很大不同，本文以X86架构CPU为例，分析其函数调用过程。与堆栈有关的寄存器主要是如下几个</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>EIP(instruction pointer)</td>
<td>指令寄存器，64位为RIP</td>
</tr>
<tr>
<td>ESP(stack pointer)</td>
<td>堆栈寄存器，64位为RSP</td>
</tr>
<tr>
<td>EBP(base pointer)</td>
<td>基址寄存器，64位为RBP</td>
</tr>
</tbody>
</table>
</div>
<p><code>EIP</code>是指令寄存器，它存放的是下一条指令的地址。如果没有函数堆栈结构，计算机的指令执行过程完全依赖于<code>EIP</code>寄存器，CPU每次从<code>EIP</code>寄存器获取一条指令，<code>EIP</code>会自动累加，从而实现了CPU的顺序执行，如图</p>
<p><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-01.png" alt></p>
<p>ESP是堆栈寄存器，它永远指向系统最上面一个栈帧的栈顶，EBP是基址寄存器，永远指向系统最上面一个栈帧的栈底。那什么是栈帧呢？它是什么结构的呢？在内存中位于什么位置呢？后文详细介绍</p>
<h3 id="进程虚拟内存空间和栈"><a href="#进程虚拟内存空间和栈" class="headerlink" title="进程虚拟内存空间和栈"></a>进程虚拟内存空间和栈</h3><p>讨论函数的执行，我们需要了解函数的执行环境是怎样的。这里我们讨论范围仅限于Linux系统下的用户空间进程中的函数执行。在Linux系统中，将整个内存空间按照3:1的比例划分为了用户空间和内核空间两大区域，默认系统配置情况下，0~3G为用户空间，3~4G为内核空间。我们创建的程序代码，都是以进程的方式运行于用户空间的虚拟内存中，当某个进程被调度时，其整个内存分布图如图所示<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-02.png" alt></p>
<p>用户空间从0x00000000到0xc0000000，其中包括很多内容，包括栈(stack)、堆(heap)、静态变量(bss)、数据段(edata)、代码段(etext)等。当一个程序被加载到内存空间执行时，这些内容除了堆是由用户来分配，其他都是由操作系统来分配和管理。本文所关心的栈结构，其大小是固定的，Linux中一般是8M(可配置)，通过命令<code>ulimit -s</code>可查看当前栈空间大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost home]# ulimit -s</span><br><span class="line">8192</span><br></pre></td></tr></table></figure>
<p>当程序运行函数嵌套过多时，当然会超过这个限定大小，这会触发缺页异常，操作系统会计算并增长栈空间</p>
<h2 id="栈和栈帧-Stack-Frame"><a href="#栈和栈帧-Stack-Frame" class="headerlink" title="栈和栈帧(Stack Frame)"></a>栈和栈帧(Stack Frame)</h2><p>栈是从上往下生长，先占用高地址，再占用低地址，主要有3个作用</p>
<ul>
<li>为函数内部声明的非静态局部变量(C语言中称自动变量)提供存储空间</li>
<li>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段</li>
<li>临时存储区，用于暂存长算术表达式部分计算结果或alloc()函数分配的栈内内存</li>
</ul>
<p>程序的运行是依靠<code>EIP</code>指针的累加从而一条指令一条指令执行的，但是当函数调用时，在跳转到子函数时和子函数返回时，显然地址不是连续的，如何做到外层函数的保存和返回呢？在同一个时刻，堆栈中会有多个函数的信息，每个待返回的函数都会占用一块独立的连续区域，这个区域就是栈帧。一个栈帧中主要存放以下关键信息</p>
<ul>
<li>上一栈帧的栈顶地址</li>
<li>局部变量</li>
<li>参数列表</li>
</ul>
<p>整个栈结构如图所示</p>
<p><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-03.png" alt></p>
<p>同一时间会存在多个栈帧，最下面的栈帧代表着当前函数，越上层的栈帧代表越外层的函数</p>
<p><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-04.png" alt></p>
<h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><p>函数调用过程主要有3个阶段</p>
<ul>
<li>调用目标函数之前的准备工作</li>
<li>调用目标函数</li>
<li>目标函数返回到调用目标函数</li>
</ul>
<p>为了方便说明，指定调用目标函数的函数为<code>caller</code>，目标函数为<code>callee</code>。在调用<code>callee</code>之前，<code>caller</code>的栈帧已经存在于内存中，如图所示</p>
<p><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-05.png" alt></p>
<p>此时<code>EBP</code>指向<code>caller</code>栈帧的栈底，<code>ESP</code>指向<code>caller</code>栈帧的栈顶</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在调用<code>callee</code>之前，<code>caller</code>会将<code>EIP</code>的值压栈保存，然后修改<code>EIP</code>寄存器的值指向被调用者<code>callee</code>，如图</p>
<p><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-06.png" alt></p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用<code>callee</code>需要完成两个操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pushl %ebp  </span><br><span class="line">movel %esp, %ebp    </span><br></pre></td></tr></table></figure>
<p>第一条指令是将<code>EBP</code>的值压栈<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-08.png" alt></p>
<p>第二条指令是移动<code>EBP</code>到栈顶<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-07.png" alt></p>
<h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p><code>callee</code>返回前，其栈帧结构如图<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-09.png" alt></p>
<p>栈帧中已经存在一些局部变量和参数</p>
<p><code>callee</code>返回要完成两个操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">movel %ebp, %esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure>
<p>第一条指令将<code>callee</code>的栈帧清空<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-10.png" alt></p>
<p>第二条指令将<code>EBP</code>恢复到之前压栈的地址，也就是<code>caller</code>的栈帧基地址<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-11.png" alt></p>
<p>由于调用<code>callee</code>前将<code>caller</code>下一条指令地址<code>EIP</code>已经压栈保存，此时只需要将<code>EIP</code>再设置为该保存值就可以恢复<code>caller</code>的执行</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下使用C代码实例，运行于centos7 64bit linux-3.10 环境，通过反汇编代码和gdb调试来分析函数调用栈的过程。C代码test.c如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    c = sum(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将test.c编译生成可执行文件，再用objdump命令反汇编</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c test.c -o <span class="built_in">test</span></span><br><span class="line">objdump -s -d <span class="built_in">test</span> &gt; test.stxt</span><br></pre></td></tr></table></figure>
<p>汇编代码内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> <span class="number">897</span>dfc89 <span class="number">75f</span>88b45 f88b55fc  UH...&#125;..u..E..U.</span><br><span class="line"> <span class="number">0010</span> <span class="number">01</span>d05dc3 <span class="number">554889e5</span> <span class="number">4883</span>ec20 <span class="number">897</span>dec48  ..].UH..H.. .&#125;.H</span><br><span class="line"> <span class="number">0020</span> <span class="number">8975e0</span>c7 <span class="number">45f</span>c0200 <span class="number">0000</span>c745 f8030000  .u..E......E....</span><br><span class="line"> <span class="number">0030</span> <span class="number">008b</span>55f8 <span class="number">8b</span>45fc89 d689c7e8 <span class="number">00000000</span>  ..U..E..........</span><br><span class="line"> <span class="number">0040</span> <span class="number">8945f</span>4b8 <span class="number">00000000</span> c9c3               .E........      </span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202847 <span class="number">4e552920</span> <span class="number">342e382</span>e  .GCC: (GNU) <span class="number">4.8</span>.</span><br><span class="line"> <span class="number">0010</span> <span class="number">35203230</span> <span class="number">31353036</span> <span class="number">32332028</span> <span class="number">52656420</span>  <span class="number">5</span> <span class="number">20150623</span> (Red </span><br><span class="line"> <span class="number">0020</span> <span class="number">48617420</span> <span class="number">342e382</span>e <span class="number">352</span>d3131 <span class="number">2900</span>      Hat <span class="number">4.8</span><span class="number">.5</span><span class="number">-11</span>).  </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">14000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  .........A....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">064f</span>0c07 <span class="number">08000000</span> <span class="number">1</span>c000000 <span class="number">3</span>c000000  .O..........&lt;...</span><br><span class="line"> <span class="number">0040</span> <span class="number">00000000</span> <span class="number">36000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  ...<span class="number">.6</span>....A....C.</span><br><span class="line"> <span class="number">0050</span> <span class="number">06710</span>c07 <span class="number">08000000</span>                    .q......        </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;sum&gt;:</span><br><span class="line">   <span class="number">0</span>:    <span class="number">55</span>                       push   %rbp</span><br><span class="line">   <span class="number">1</span>:    <span class="number">48</span> <span class="number">89</span> e5                 mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:    <span class="number">89</span> <span class="number">7</span>d fc                 mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   <span class="number">7</span>:    <span class="number">89</span> <span class="number">75</span> f8                 mov    %esi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   a:    <span class="number">8b</span> <span class="number">45</span> f8                 mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">   d:    <span class="number">8b</span> <span class="number">55</span> fc                 mov    <span class="number">-0x4</span>(%rbp),%edx</span><br><span class="line">  <span class="number">10</span>:    <span class="number">01</span> d0                    add    %edx,%eax</span><br><span class="line">  <span class="number">12</span>:    <span class="number">5</span>d                       pop    %rbp</span><br><span class="line">  <span class="number">13</span>:    c3                       retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000014</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">14</span>:    <span class="number">55</span>                       push   %rbp</span><br><span class="line">  <span class="number">15</span>:    <span class="number">48</span> <span class="number">89</span> e5                 mov    %rsp,%rbp</span><br><span class="line">  <span class="number">18</span>:    <span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>              sub    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">1</span>c:    <span class="number">89</span> <span class="number">7</span>d ec                 mov    %edi,<span class="number">-0x14</span>(%rbp)</span><br><span class="line">  <span class="number">1f</span>:    <span class="number">48</span> <span class="number">89</span> <span class="number">75</span> e0              mov    %rsi,<span class="number">-0x20</span>(%rbp)</span><br><span class="line">  <span class="number">23</span>:    c7 <span class="number">45</span> fc <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     movl   $<span class="number">0x2</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">2</span>a:    c7 <span class="number">45</span> f8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     movl   $<span class="number">0x3</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">31</span>:    <span class="number">8b</span> <span class="number">55</span> f8                 mov    <span class="number">-0x8</span>(%rbp),%edx</span><br><span class="line">  <span class="number">34</span>:    <span class="number">8b</span> <span class="number">45</span> fc                 mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">37</span>:    <span class="number">89</span> d6                    mov    %edx,%esi</span><br><span class="line">  <span class="number">39</span>:    <span class="number">89</span> c7                    mov    %eax,%edi</span><br><span class="line">  <span class="number">3b</span>:    e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>           callq  <span class="number">40</span> &lt;main+<span class="number">0x2c</span>&gt;</span><br><span class="line">  <span class="number">40</span>:    <span class="number">89</span> <span class="number">45</span> f4                 mov    %eax,<span class="number">-0xc</span>(%rbp)</span><br><span class="line">  <span class="number">43</span>:    b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>           mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">48</span>:    c9                       leaveq </span><br><span class="line">  <span class="number">49</span>:    c3                       retq</span><br></pre></td></tr></table></figure>
<p>第14、15条指令，<code>main</code>函数首先是准备自己的栈空间。<code>call</code>命令本身会保存<code>RIP</code>寄存器的值。在<code>sum</code>函数开头，会将<code>RBP</code>压栈，保存<code>main</code>函数的栈帧基址，然后将<code>RBP</code>移动到栈顶。在<code>sum</code>函数返回时，会将<code>RBP</code>出栈</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>使用gdb调试C代码， 在编译时需要加上<code>-g</code>参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> -g test.c</span><br></pre></td></tr></table></figure>
<p>执行以下命令以gdb调试可执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>gdb调试打印如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-redhat-linux-gnu&quot;</span>.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /home/share/<span class="built_in">test</span>/c/elf_test/test...done.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>gdb下调试函数栈帧，可用以下命令</p>
<ul>
<li>backktrace：显示程序的调用栈信息，缩写’bt’</li>
<li>frame: 查看栈帧信息</li>
<li>info frame：查看栈帧详细信息</li>
</ul>
<p>首先在main函数处设置断点，并查看函数栈信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x400510: file test.c, line 13.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/share/<span class="built_in">test</span>/c/elf_test/<span class="built_in">test</span> </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffe308) at test.c:13</span><br><span class="line">13        a = 2;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  main (argc=1, argv=0x7fffffffe308) at test.c:13</span></span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>可看到当前程序存在一个栈帧，栈帧号为0，是main函数</p>
<p>查看详细栈帧信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0x7fffffffe230:</span><br><span class="line"> rip = 0x400510 <span class="keyword">in</span> main (test.c:13); saved rip 0x7ffff7a3db35</span><br><span class="line"> <span class="built_in">source</span> language c.</span><br><span class="line"> Arglist at 0x7fffffffe220, args: argc=1, argv=0x7fffffffe308</span><br><span class="line"> Locals at 0x7fffffffe220, Previous frame<span class="string">&#x27;s sp is 0x7fffffffe230</span></span><br><span class="line"><span class="string"> Saved registers:</span></span><br><span class="line"><span class="string">  rbp at 0x7fffffffe220, rip at 0x7fffffffe228</span></span><br><span class="line"><span class="string">(gdb) </span></span><br></pre></td></tr></table></figure>
<p>使用<code>info reg</code>查看寄存器信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info reg</span><br><span class="line">rax            0x400501    4195585</span><br><span class="line">rbx            0x0    0</span><br><span class="line">rcx            0x400540    4195648</span><br><span class="line">rdx            0x7fffffffe318    140737488347928</span><br><span class="line">rsi            0x7fffffffe308    140737488347912</span><br><span class="line">rdi            0x1    1</span><br><span class="line">rbp            0x7fffffffe220    0x7fffffffe220</span><br><span class="line">rsp            0x7fffffffe200    0x7fffffffe200</span><br><span class="line">r8             0x7ffff7dd7e80    140737351876224</span><br><span class="line">r9             0x0    0</span><br><span class="line">r10            0x7fffffffe070    140737488347248</span><br><span class="line">r11            0x7ffff7a3da40    140737348098624</span><br><span class="line">r12            0x400400    4195328</span><br><span class="line">r13            0x7fffffffe300    140737488347904</span><br><span class="line">r14            0x0    0</span><br><span class="line">r15            0x0    0</span><br><span class="line">rip            0x400510    0x400510 &lt;main+15&gt;</span><br><span class="line">eflags         0x206    [ PF IF ]</span><br><span class="line">cs             0x33    51</span><br><span class="line">ss             0x2b    43</span><br><span class="line">ds             0x0    0</span><br><span class="line">es             0x0    0</span><br><span class="line">fs             0x0    0</span><br><span class="line">gs             0x0    0</span><br></pre></td></tr></table></figure>
<p>栈基址<code>rbp</code>为<code>0x7fffffffe220</code>，栈顶地址<code>rsp</code>为<code>0x7fffffffe200</code>，如图<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-12.png" alt></p>
<p><code>s</code>单步调试，直到程序进入<code>sum</code>函数，查看栈结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">14        b = 3;</span><br><span class="line">(gdb) s</span><br><span class="line">17        c = sum(a, b);</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  main (argc=1, argv=0x7fffffffe308) at test.c:17</span></span><br><span class="line">(gdb) s</span><br><span class="line">sum (a=2, b=3) at test.c:6</span><br><span class="line">6        <span class="built_in">return</span> (a+b);</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  sum (a=2, b=3) at test.c:6</span></span><br><span class="line"><span class="comment">#1  0x000000000040052d in main (argc=1, argv=0x7fffffffe308) at test.c:17</span></span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>可看到此时有两个栈帧0和1，<code>main</code>函数栈帧号变成了1，<code>sum</code>函数栈帧号是0。用<code>info frame</code>命令分别查看两个栈帧信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info frame 0</span><br><span class="line">Stack frame at 0x7fffffffe200:</span><br><span class="line"> rip = 0x4004f7 <span class="keyword">in</span> sum (test.c:6); saved rip 0x40052d</span><br><span class="line"> called by frame at 0x7fffffffe230</span><br><span class="line"> <span class="built_in">source</span> language c.</span><br><span class="line"> Arglist at 0x7fffffffe1f0, args: a=2, b=3</span><br><span class="line"> Locals at 0x7fffffffe1f0, Previous frame<span class="string">&#x27;s sp is 0x7fffffffe200</span></span><br><span class="line"><span class="string"> Saved registers:</span></span><br><span class="line"><span class="string">  rbp at 0x7fffffffe1f0, rip at 0x7fffffffe1f8</span></span><br><span class="line"><span class="string">(gdb) info frame 1</span></span><br><span class="line"><span class="string">Stack frame at 0x7fffffffe230:</span></span><br><span class="line"><span class="string"> rip = 0x40052d in main (test.c:17); saved rip 0x7ffff7a3db35</span></span><br><span class="line"><span class="string"> caller of frame at 0x7fffffffe200</span></span><br><span class="line"><span class="string"> source language c.</span></span><br><span class="line"><span class="string"> Arglist at 0x7fffffffe220, args: argc=1, argv=0x7fffffffe308</span></span><br><span class="line"><span class="string"> Locals at 0x7fffffffe220, Previous frame&#x27;</span>s sp is 0x7fffffffe230</span><br><span class="line"> Saved registers:</span><br><span class="line">  rbp at 0x7fffffffe220, rip at 0x7fffffffe228</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>查看寄存器值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info reg</span><br><span class="line">rax            0x2    2</span><br><span class="line">rbx            0x0    0</span><br><span class="line">rcx            0x400540    4195648</span><br><span class="line">rdx            0x3    3</span><br><span class="line">rsi            0x3    3</span><br><span class="line">rdi            0x2    2</span><br><span class="line">rbp            0x7fffffffe1f0    0x7fffffffe1f0</span><br><span class="line">rsp            0x7fffffffe1f0    0x7fffffffe1f0</span><br><span class="line">r8             0x7ffff7dd7e80    140737351876224</span><br><span class="line">r9             0x0    0</span><br><span class="line">r10            0x7fffffffe070    140737488347248</span><br><span class="line">r11            0x7ffff7a3da40    140737348098624</span><br><span class="line">r12            0x400400    4195328</span><br><span class="line">r13            0x7fffffffe300    140737488347904</span><br><span class="line">r14            0x0    0</span><br><span class="line">r15            0x0    0</span><br><span class="line">rip            0x4004f7    0x4004f7 &lt;sum+10&gt;</span><br><span class="line">eflags         0x206    [ PF IF ]</span><br><span class="line">cs             0x33    51</span><br><span class="line">ss             0x2b    43</span><br><span class="line">ds             0x0    0</span><br><span class="line">es             0x0    0</span><br><span class="line">fs             0x0    0</span><br><span class="line">gs             0x0    0</span><br></pre></td></tr></table></figure>
<p>可看到函数<code>sum</code>的栈顶栈底都是<code>0x7fffffffe1f0</code>，因为该函数函数体只有一个返回语句，此时函数栈结构为<br><img src="/2019/10/15/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88/image/STACK-13.png" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/xzzzh/p/6596982.html">CSDN-Xzzzh-Linux虚拟地址空间布局以及进程栈和线程栈总结</a></li>
<li><a href="https://blog.csdn.net/baidu_24256693/article/details/47297209">CSDN-gdb查看函数调用栈</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux Kernel</category>
        <category>进程管理</category>
      </categories>
  </entry>
  <entry>
    <title>利用socketpair唤醒selector</title>
    <url>/2019/05/05/%E5%88%A9%E7%94%A8socketpair%E5%94%A4%E9%86%92selector/</url>
    <content><![CDATA[<p>在分析<code>kafka-python</code>源码时发现生产者经常调用其子对象<code>Client</code>的一个<code>wakeup()</code>方法，它利用了socketpair管道发送一个数据来快速唤醒selector，快速中断selector的轮询。上下文关系如图所示<br><img src="/2019/05/05/%E5%88%A9%E7%94%A8socketpair%E5%94%A4%E9%86%92selector/image/wakeup-selector-01.png" alt="回调上下文"><br>程序运行中有两个线程，主线程’main loop’和客户端线程’client thread’。主线程定时利用client发送数据到server，而client线程本身要调用<code>selector()</code>函数以超时等待的方式轮询server的数据。当主线程要发送数据时，先调用一个<code>wakeup()</code>函数唤醒client，然后发送</p>
<p>wakeup函数代码如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wakeup</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self._wake_lock:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._wake_w.sendall(<span class="string">b&#x27;x&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.timeout:</span><br><span class="line">            log.warning(<span class="string">&#x27;Timeout to send to wakeup socket!&#x27;</span>)</span><br><span class="line">            <span class="keyword">raise</span> Errors.KafkaTimeoutError()</span><br><span class="line">        <span class="keyword">except</span> socket.error:</span><br><span class="line">            log.warning(<span class="string">&#x27;Unable to send to wakeup socket!&#x27;</span>)</span><br></pre></td></tr></table></figure><br>其中<code>_wake_lock</code>是通过<code>threading.Lock()</code>创建的线程锁，<code>_wake_w</code>是由<code>socket.socketpair()</code>函数创建的socket管道写端</p>
<p>我猜测这样的用法是因为直接调用<code>send()</code>函数发送数据最终会调用<code>client.send()</code>，这里会请求lock，但是如果selector的轮训线程在等待超时之前已经申请了lock，导致send阻塞，无法发送数据，直到selector超时结束并释放了lock之后，send才能发送。wakeup的作用是让selector收到数据，并立刻释放lock，使得send可以立即申请到lock并发送数据</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>编写的测试脚本如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> selectors  <span class="comment"># Python2.7不支持selectors模块，找的源码</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> vendor <span class="keyword">import</span> selectors34 <span class="keyword">as</span> selectors</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poller</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Poller, self).__init__()</span><br><span class="line">        self._selector = selectors.DefaultSelector()    </span><br><span class="line">        self._wake_r, self._wake_w = socket.socketpair()    <span class="comment"># 利用socketpair创建唤醒消息通道</span></span><br><span class="line">        self._wake_r.setblocking(<span class="literal">False</span>)</span><br><span class="line">        self._wake_w.settimeout(<span class="number">3</span>)</span><br><span class="line">        self._wake_lock = threading.Lock()</span><br><span class="line">        self._lock = threading.RLock()</span><br><span class="line">        self._selector.register(self._wake_r, selectors.EVENT_READ)</span><br><span class="line">        self.stop_event = threading.Event()     <span class="comment"># 线程结束控制信号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span>     <span class="comment"># 控制线程结束方法</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">            self.stop_event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_clear_wake_fd</span>(<span class="params">self</span>):</span>   <span class="comment"># 清理唤醒通道的数据</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._wake_r.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">except</span> socket.error:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._wake_r.close()</span><br><span class="line">        self._wake_w.close()</span><br><span class="line">        self._selector.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wakeup</span>(<span class="params">self</span>):</span>   <span class="comment"># 唤醒方法</span></span><br><span class="line">        <span class="keyword">with</span> self._wake_lock:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._wake_w.sendall(<span class="string">b&#x27;x&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;Timeout to send to wakeup socket!&#x27;</span></span><br><span class="line">            <span class="keyword">except</span> socket.error:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;Unable to send to wakeup socket!&#x27;</span>    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.stop_event.is_set():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.poll()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;Exception &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(e)</span><br><span class="line">                self.stop()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.close()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">poll</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self._lock:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;selecting...&#x27;</span></span><br><span class="line">            start_select = time.time()</span><br><span class="line">            ready = self._selector.select(<span class="number">10</span>)</span><br><span class="line">            end_select = time.time()</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;select time &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(end_select-start_select)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key, events <span class="keyword">in</span> ready:</span><br><span class="line">                <span class="keyword">if</span> key.fileobj <span class="keyword">is</span> self._wake_r:</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">&#x27;is wakeup event&#x27;</span></span><br><span class="line">                    self._clear_wake_fd()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> (events &amp; selectors.EVENT_READ):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    data = key.fileobj.recv(<span class="number">1024</span>)</span><br><span class="line">                    <span class="built_in">print</span> data</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span> e    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Poller()</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">60</span>)      <span class="comment"># 注释这里以启用唤醒测试</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注释这里以关闭唤醒测试</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    count = 0           </span></span><br><span class="line"><span class="string">    while count &lt; 5:</span></span><br><span class="line"><span class="string">        time.sleep(3)</span></span><br><span class="line"><span class="string">        p.wakeup()</span></span><br><span class="line"><span class="string">        count += 1</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    p.stop()</span><br></pre></td></tr></table></figure></p>
<p>主循环定时每3秒调用<code>wakeup</code>方法唤醒线程selector，线程中<code>select()</code>函数结束后打印等待时间</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h3 id="不启用唤醒"><a href="#不启用唤醒" class="headerlink" title="不启用唤醒"></a>不启用唤醒</h3><p>主函数代码为<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Poller()</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">60</span>)      <span class="comment"># 注释这里以启用唤醒测试</span></span><br><span class="line">    p.stop()</span><br></pre></td></tr></table></figure><br>运行程序，结果为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; python selector_sockpair_wakeup.py</span></span><br><span class="line">selecting...</span><br><span class="line">select time 10.0130000114</span><br><span class="line">selecting...</span><br><span class="line">select time 10.0150001049</span><br><span class="line">selecting...</span><br><span class="line">select time 10.004999876</span><br><span class="line">selecting...</span><br><span class="line">select time 10.0050001144</span><br><span class="line">selecting...</span><br><span class="line">select time 10.004999876</span><br><span class="line">selecting...</span><br><span class="line">select time 10.0090000629</span><br><span class="line">selecting...</span><br><span class="line">select time 10.0120000839</span><br></pre></td></tr></table></figure><br>程序正常运行，每10秒select发生超时</p>
<h3 id="启用唤醒"><a href="#启用唤醒" class="headerlink" title="启用唤醒"></a>启用唤醒</h3><p>主函数代码为<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Poller()</span><br><span class="line">    p.start()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        p.wakeup()</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    p.stop()</span><br></pre></td></tr></table></figure><br>运行程序，结果为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; python selector_sockpair_wakeup.py</span></span><br><span class="line">selecting...</span><br><span class="line">select time 3.01499986649</span><br><span class="line">is wakeup event</span><br><span class="line">selecting...</span><br><span class="line">select time 3.0150001049</span><br><span class="line">is wakeup event</span><br><span class="line">selecting...</span><br><span class="line">select time 3.0150001049</span><br><span class="line">is wakeup event</span><br><span class="line">selecting...</span><br><span class="line">select time 3.00499987602</span><br><span class="line">is wakeup event</span><br><span class="line">selecting...</span><br><span class="line">select time 3.00200009346</span><br><span class="line">is wakeup event</span><br><span class="line">selecting...</span><br><span class="line">select time 10.003000021</span><br></pre></td></tr></table></figure><br>由于主循环中调用了<code>wakeup()</code>方法，select收到数据，因此select时间是3秒</p>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>python-kafka</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>加密测试</title>
    <url>/2019/04/28/%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c7e8d0c60f20b130e101189399befb349b34bb5ee2041028f0cb5f88701daf9e">bd25ed9264b080267271e137e33d0ce1adc3c6b2bac6ceb0572e33f68e974c79b0aa0682091eba81b976ca12b7a076efc64e56eedabee835053832bf347902f721bcf693bf737e29fe37146cfe4161331f137a6dbf390c85c5b3311ddf1a773f7cbdb33ae007d2687fee0bb16bddfe45e430ac79d8273423df4695c52e5998a70397ef512a8c4967d42f490ab99b88f1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>好点子.md</title>
    <url>/2019/06/25/%E5%A5%BD%E7%82%B9%E5%AD%90/</url>
    <content><![CDATA[<h1 id="好点子"><a href="#好点子" class="headerlink" title="好点子"></a>好点子</h1><p>记录一些自己想到的、或者与别人聊天发现的好玩的创意点，将来可以做着玩玩</p>
<h2 id="移动的Wi-Fi放大器"><a href="#移动的Wi-Fi放大器" class="headerlink" title="移动的Wi-Fi放大器"></a>移动的Wi-Fi放大器</h2><p>利用一些可移动的智能硬件，例如小车、扫地机器人，将Wi-Fi放大器放入其中，对其移动逻辑进行自定义编程，实现人在哪里，移动Wi-Fi放大器就在哪里<br>该放大器作为家庭主Wi-Fi的中继</p>
<h2 id="定制化的家庭网关"><a href="#定制化的家庭网关" class="headerlink" title="定制化的家庭网关"></a>定制化的家庭网关</h2><p>将路由器刷机，或者用开发板定制自己的网关逻辑，可实现以下功能</p>
<ul>
<li>广告过滤：内嵌广告过滤算法，识别出广告数据包，并从视频流中剔除</li>
<li>远程监控：内置一个可供外网访问的服务，与手机APP交互，实现远程视频监控</li>
<li>自动下载：自动爬取电影或者电视剧资源列表，下载到移动硬盘，可提前创建预约任务</li>
</ul>
<h2 id="3D模型扫描生成工具"><a href="#3D模型扫描生成工具" class="headerlink" title="3D模型扫描生成工具"></a>3D模型扫描生成工具</h2><p>最近新房装修，研究了几款平面设计的软件，这些软件大都免费安装，但是在设计布局的时候，需要很多的家具模板都需要付费，或者根本没有<br>可在手机APP上开发一款使用摄像头扫描真实物体生成3D模型的软件</p>
<h2 id="基于机器学习的喷子识别"><a href="#基于机器学习的喷子识别" class="headerlink" title="基于机器学习的喷子识别"></a>基于机器学习的喷子识别</h2><p>现在网络上到处都充斥着一群喷子，可以把混迹6年的知乎大佬喷自闭，能否开发一个基于机器学习的喷子识别程序，对某平台所有用户的言论进行分析识别，当其大部分言论中都充斥着对别人的否定、侮辱、谩骂词汇，或者语义时，认为该用户是一个喷子</p>
<h2 id="基于机器学习的垃圾分类"><a href="#基于机器学习的垃圾分类" class="headerlink" title="基于机器学习的垃圾分类"></a>基于机器学习的垃圾分类</h2><p>采集多个已分类好的垃圾照片，利用神经网络进行学习，可在移动端制作垃圾分类助手APP实现随拍识别垃圾是哪一类</p>
<h2 id="基于神经网络的摄影后期"><a href="#基于神经网络的摄影后期" class="headerlink" title="基于神经网络的摄影后期"></a>基于神经网络的摄影后期</h2><p>学习某类摄影作品的风格，并批量应用于自己拍摄的图像 </p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>玩</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>引用、拷贝和垃圾回收</title>
    <url>/2019/04/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>在分析<code>kafka-python</code>源码时发现有个回调函数的处理怎么看也看不懂，生产者创建了一个client对象实例，client有一个方法<code>_conn_state_change()</code>。当建立连接时，使用conn实例来描述和管理一个连接，conn需要用到client的<code>_conn_state_change()</code>方法，因此在创建conn实例时要传入该方法，大致的上下文逻辑如图<br><img src="/2019/04/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image/reference-copy-destroy-01.png" alt="回调上下文"><br>代码如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cb = WeakMethod(self._conn_state_change)</span><br><span class="line">conn = BrokerConnection(host, broker.port, afi,</span><br><span class="line">                        state_change_callback=cb,</span><br><span class="line">                        node_id=node_id,</span><br><span class="line">                        **self.config)</span><br><span class="line">self._conns[node_id] = conn</span><br></pre></td></tr></table></figure><br>为什么不能直接将该函数作为参数传入，而要通过另外一个类<code>WeakMethod</code>来封装一下，将返回的对象传入呢？</p>
<p><code>Weakmethod</code>类的定义如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakMethod</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Callable that weakly references a method and the object it is bound to. It</span></span><br><span class="line"><span class="string">    is based on https://stackoverflow.com/a/24287465.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        object_dot_method: A bound instance method (i.e. &#x27;object.method&#x27;).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, object_dot_method</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.target = weakref.ref(object_dot_method.__self__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            self.target = weakref.ref(object_dot_method.im_self)</span><br><span class="line">        self._target_id = <span class="built_in">id</span>(self.target())</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.method = weakref.ref(object_dot_method.__func__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            self.method = weakref.ref(object_dot_method.im_func)</span><br><span class="line">        self._method_id = <span class="built_in">id</span>(self.method())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Calls the method on target with args and kwargs.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.method()(self.target(), *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.target) ^ <span class="built_in">hash</span>(self.method)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, WeakMethod):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self._target_id == other._target_id <span class="keyword">and</span> self._method_id == other._method_id</span><br></pre></td></tr></table></figure></p>
<p>发现<code>WeakMethod</code>的定义中使用了<code>weakref</code>，通过查阅资料，才了解到这是python的弱引用。又经过一番查资料和写测试代码，才对python中的引用、拷贝和垃圾回收有了一定的理解</p>
<h2 id="引用式变量"><a href="#引用式变量" class="headerlink" title="引用式变量"></a>引用式变量</h2><p>首先必须明确的一点是，类似Python或者Java语言中，变量只是一个标注，而不是对象本身。以一个例子来证明<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><br>对列表a的改动，结果b也发生了同样的改动，原因是a、b都只是同一个列表的引用，对引用的操作实质上是对对象本身的操作，如下图<br><img src="/2019/04/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image/reference-copy-destroy-02.png" alt="回调上下文"></p>
<h2 id="默认做浅拷贝"><a href="#默认做浅拷贝" class="headerlink" title="默认做浅拷贝"></a>默认做浅拷贝</h2><p>这里有一个将代码运行转换成交互式动画的网站<a href="http://www.pythontutor.com">Python Tutor</a>可以方便查看代码运行过程中到底发生了什么</p>
<p>Python默认的拷贝方式是浅拷贝，即只复制最外层容器，以下例子用来说明<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = <span class="built_in">list</span>(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>].remove(<span class="number">55</span>)    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;l1:&#x27;</span>, l1)</span><br><span class="line">(<span class="string">&#x27;l1:&#x27;</span>, [<span class="number">3</span>, [<span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>), <span class="number">100</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;l2:&#x27;</span>, l2)</span><br><span class="line">(<span class="string">&#x27;l2:&#x27;</span>, [<span class="number">3</span>, [<span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)])</span><br></pre></td></tr></table></figure><br>l2是l1的浅拷贝，当直接对l1进行改变时(插入100)，l2不会发生变化。但是对l1的第2个成员<code>[55, 44]</code>删除元素是，其变化会影响到l2，原理如图<br><img src="/2019/04/29/%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image/reference-copy-destroy-03.png" alt="回调上下文"></p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>如果要做深拷贝，使用copy模块的<code>deepcopy()</code>方法</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果对引用操作不当，会导致对象无法被回收，内存泄漏，例子如下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Object &#123;&#125; created&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Object &#123;&#125; destroy&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ref_test</span>():</span></span><br><span class="line">    a = ReferenceTest(<span class="string">&#x27;obj_a&#x27;</span>)</span><br><span class="line">    b = ReferenceTest(<span class="string">&#x27;obj_b&#x27;</span>)</span><br><span class="line">    a.b = b</span><br><span class="line">    b.a = a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ref_test()</span><br></pre></td></tr></table></figure><br>运行以上代码，结果是这样的<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>python referenct_test.py</span><br><span class="line">Object obj_a created</span><br><span class="line">Object obj_b created</span><br></pre></td></tr></table></figure><br>正常来说，创建<code>ReferenceTest</code>类的两个实例a、b，当程序运行结束时，它们的引用计数变为0，会被Python的垃圾回收器自动销毁，而在销毁时会调用类的<code>__del__</code>方法，打印函数中定义的内容，而结果却没有打印。</p>
<p>因为这两个实例互相引用，其引用次数不可能为0，导致无法被回收。要解决该问题，就需要使用弱引用</p>
<h3 id="weakref"><a href="#weakref" class="headerlink" title="weakref"></a>weakref</h3><p>Python提供weakref模块来处理弱引用，修改以上代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Object &#123;&#125; created&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Object &#123;&#125; destroy&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ref_test</span>():</span></span><br><span class="line">    a = ReferenceTest(<span class="string">&#x27;obj_a&#x27;</span>)</span><br><span class="line">    b = ReferenceTest(<span class="string">&#x27;obj_b&#x27;</span>)</span><br><span class="line">    a.b = weakref.proxy(b)</span><br><span class="line">    b.a = weakref.proxy(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ref_test()</span><br></pre></td></tr></table></figure><br>运行以上代码，结果是这样的<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>python referenct_test.py</span><br><span class="line">Object obj_a created</span><br><span class="line">Object obj_b created</span><br><span class="line">Object obj_a destroy</span><br><span class="line">Object obj_b destroy</span><br></pre></td></tr></table></figure><br>由于垃圾回收器在只有弱引用时也会将对象清理，因此obj_a和obj_b都被清理了</p>
<h2 id="WeakMethod"><a href="#WeakMethod" class="headerlink" title="WeakMethod"></a>WeakMethod</h2><p>回过头来看<code>WeakMethod</code>的用法，如果直接将函数<code>_conn_state_change()</code>传入conn中，而conn的返回实例又会被<code>client._conns</code>引用，形成了引用循环，因此需要创建弱引用对象，将弱引用对象传入到conn中</p>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>python-kafka</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>我的blog发布啦</title>
    <url>/2019/04/28/%E6%88%91%E7%9A%84blog%E5%8F%91%E5%B8%83%E5%95%A6/</url>
    <content><![CDATA[<p>感谢创造了github、leancloud、hexo等等优秀的开发者们，让穷困潦倒&amp;技艺拙略的我也能非常方便的搭建起一个blog，<br>拥有一个看起来不是那么low的场所，去记录一些公开化的、属于我的东西，最重要的是：它是完完全全免费的！！！</p>
<h2 id="I-为什么要有一个自己的blog？"><a href="#I-为什么要有一个自己的blog？" class="headerlink" title="I. 为什么要有一个自己的blog？"></a>I. 为什么要有一个自己的blog？</h2><p>目前我主要使用github和gitlab来做记录。github不用说，这是属于developer的世界，我的github侧重于开源project，另外也会用WiKi归类整理一些自有技术文档；gitlab和github非常相似，我觉得它的issue、milestone、labels等功能在使用和界面交互上更加舒适，我喜欢用它来记录一些生活中计划性的事情和一些专项记录，例如装修计划、病例</p>
<p>它们的确很好用，有着良好的设计性和交互性，支持markdown使得文档的排版看起来非常舒服，特别是使用gitlab来做计划管理，用它的milestone来管理deadline和进度，用issue来记录问题点、交换意见和讨论。但是它们都太专业化，侧重点非常明确，且不够个性化，拿它们来做项目管理和技术文档整理再好不过，却不再适合别的什么了</p>
<p>在查阅一些内容的时候，常常会搜索到某位hacker的blog，他们的blog有着简洁优雅的排版，里面的内容除了技术文档，更涵盖了个人生活的方方面面，旅行、摄影、美食烹饪、随笔、散文。我也希望能够有一个展现完整个人的场所，记录自己的生活、动态和思想</p>
<h2 id="II-记录些什么？"><a href="#II-记录些什么？" class="headerlink" title="II. 记录些什么？"></a>II. 记录些什么？</h2><p>目前我能够想到的，想要去记录的内容，主要是这样几点</p>
<ul>
<li>开发</li>
<li>阅读</li>
<li>思考</li>
<li>兴趣</li>
</ul>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>记录一些成体系的知识结构，主要是嵌入式和机器学习两个方向</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>此处的阅读是广义的阅读，包含了读书、追剧、电影等内容，写一些阶段性的感受、影评或是书评</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>记录好的想法、idea，对一些感兴趣领誉的思索，如历史、经济、社会、文化、科技等等</p>
<h3 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h3><p>这里是作品发布、学习干货的聚集地，放置所有我视之为兴趣的东西，可以是Dota回忆录、摄影作品展、插画展、游记、家装设计、乐器学习等</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>梯度下降和反向传播</title>
    <url>/2019/09/30/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<p>梯度下降(GD, Gradient Descent)和反向传播(BP, Back Propagation)是理解神经网络学习原理的核心，本文试图从数学原理、实例来分析梯度下降和反向传播在神经网络中是如何工作的</p>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>为了理解梯度下降算法和反向传播算法的工作原理，需要理解以下数学知识</p>
<ul>
<li>方向导数和梯度</li>
<li>链式法则</li>
</ul>
<h3 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h3><p>梯度在数学中的概念，源于方向导数。在一元函数中，我们用导数来描述和分析函数的变化趋势，二元函数或多元函数我们用偏导数来分析函数变化情况。但是一旦变成多元，偏导数只能反应在坐标轴方向的变化情况，如果想要知道函数在任意方向上的变化情况，偏导数是无法做到的。因此引入了方向导数的概念</p>
<p>$l$ 是 $xOy$ 平面上以 $P<em>{0}(x</em>{0},y<em>{0})$ 为起点的一条射线，$e</em>{l}=(\cos{\alpha},\cos{\beta})$ 是与 $l$ 同方向的单位向量，$P$ 为射线上另一点。如果函数 $z = f(x,y)$ 的增量 $f(x<em>{0}+t\cos{\alpha}, y</em>{0}+t\cos{\beta})$ 与 $P$ 到 $P<em>{0}$ 的距离 $\left|PP</em>{0}\right| = t$ 比值 </p>
<script type="math/tex; mode=display">
\frac{f(x_{0}+t\cos{\alpha}, y_{0}+t\cos{\beta}) - f(x_{0}, y_{0})}{t}</script><p>当 $P$ 趋于 $P<em>{0}$ 时的极限存在，则称此极限为函数在点 $P</em>{0}$ 沿着射线 $l$ 的方向导数。简单来说，方向导数就是函数在某一点上(当然这一点必须是在函数上的)，沿着某一个方向的变化率，但是方向导数并不是在任何方向上都存在，有定理：</p>
<ul>
<li>如果函数在某一点可微，函数在该点的任何方向的方向导数存在 </li>
</ul>
<h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>函数在很多方向上都有方向导数，那么在哪个方向上变化率最大呢？</p>
<p>如果函数在点 $P<em>{0}$ 可微，$e</em>{l} = (cos\alpha, cos\beta)$ 是与方向 $l$ 同方向的单位向量，则方向导数可以写成如下形式</p>
<script type="math/tex; mode=display">
\frac{\partial f}{\partial l} = \nabla f\left ( x_{0}, y_{0} \right ) \cdot e_{l} = \left | \nabla f\left ( x_{0}, y_{0} \right ) \right |cos\theta</script><p>其中 $\nabla f\left ( x<em>{0},y</em>{0} \right )$ 就是梯度，$\theta$ 是梯度与单位向量的夹角。反过来，可以将方向导数看做梯度在任意方向上的投影，当这个夹角 $\theta$ 为0时，表示方向导数与梯度同方向，函数增长速度最快，当夹角 $\theta$ 为180度时，方向导数与梯度方向相反，函数减小最快 </p>
<p>梯度的表达式为</p>
<script type="math/tex; mode=display">
\nabla{f} = [\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}]</script><p>本质上是函数的各个偏导数合成的向量</p>
<h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>微积分中的链式法则用于计算复合函数的导数。设$x$为实数，$f$和$g$是从实数映射到实数的函数，假设$y=g(x)$且$z=f(g(x))=f(y)$，那么链式法则为</p>
<script type="math/tex; mode=display">
\frac{\partial z}{\partial x} = \frac{\partial z}{\partial y}\frac{\partial y}{\partial x}</script><p>扩展到向量，假设$\boldsymbol{x} \in \mathbb{R}^{m}$，$\boldsymbol{y} \in \mathbb{R}^{n}$，$g$是从$\mathbb{R}^{m}$到$\mathbb{R}^{n}$的映射，$f$是从$\mathbb{R}^{n}$到$\mathbb{R}$的映射，如果$\boldsymbol{y}=g(\boldsymbol{x})$且$z=f(\boldsymbol{y})$。那么</p>
<script type="math/tex; mode=display">
\frac{\partial z}{\partial x_{i}} = \sum_{j}\frac{\partial z}{\partial y_{i}}\frac{\partial y_{i}}{\partial x_{i}}</script><p>使用向量写法，可等价为</p>
<script type="math/tex; mode=display">
\nabla_{x}{z} = \left(\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}\right)^{T}\nabla_{y}{z}</script><p>其中$\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}$是$g$的$n \times m$的Jacobian矩阵</p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降属于神经网络中优化器的一种，另外还有AdaGrad、RMSProp、Adam等。由于梯度永远指向函数增长最快的方向，那么函数下降最快的方向就是负梯度$-\nabla{f}$。梯度下降算法的思想是构造一个迭代过程，每次都使得损失函数$L$在负梯度的方向步进一点，经过若干次迭代后，函数值最终会逼近极值，这时网络学习收敛</p>
<p>设$\Delta{f}$为每次迭代时函数的变化量，可设置为</p>
<script type="math/tex; mode=display">
\Delta{f} = -\eta{\nabla{f}}</script><p>其中$\eta$是一个很小的正数，称为<em>学习速率</em></p>
<p>在每次迭代时$\omega$按照如下规则更新</p>
<script type="math/tex; mode=display">
\omega -> \acute{\omega} = \omega - \eta{\nabla{f}}</script><p>$b$的更新规则同上。整个迭代过程可以想象为在山谷中下落的小球，小球从山顶会沿着最短路径慢慢滚到谷底，如下图所示<br><img src="/2019/09/30/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/image/sgd-01.webp" alt></p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播这个术语经常被误认为只是用于神经网络的整个学习算法中，实际上反向传播算法只是用于计算梯度的方法，它可以用来计算任何函数的导数。由于按照梯度的定义直接求解是非常复杂的，反向传播能够使用非常简单的计算步骤来求解梯度</p>
<h3 id="链式法则求复合函数的导数"><a href="#链式法则求复合函数的导数" class="headerlink" title="链式法则求复合函数的导数"></a>链式法则求复合函数的导数</h3><p>反向传播的核心在于运用链式法则，以下使用函数$f(x,y,z) = (x+y)*z$来说明整个过程。可将公式拆分为两部分$q=x+y$和$f=qz$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># input value</span></span><br><span class="line">x = -<span class="number">2</span></span><br><span class="line">y = <span class="number">5</span></span><br><span class="line">z = -<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># forward propagation</span></span><br><span class="line">q = x + y           <span class="comment"># q become 3</span></span><br><span class="line">f = q*z             <span class="comment"># f become -12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># back propagation</span></span><br><span class="line">dfdz = q            <span class="comment"># q=3, dfdz = 3</span></span><br><span class="line">dfdq = z            <span class="comment"># z=-4, dfdq = -4</span></span><br><span class="line">dfdx = <span class="number">1.0</span> * dfdq   <span class="comment"># dqdx=1, dfdq=-4, dfdx=-4</span></span><br><span class="line">dfdy = <span class="number">1.0</span> * dfdq   <span class="comment"># dqdy=1, dfdq=-4, dfdy=-4</span></span><br></pre></td></tr></table></figure>
<p>对于输入<code>x=-2, y=5, z=-4</code>先进行前向传播，依次向后计算，最后得出函数值为-12，前向传播的方向为从输入到输出(绿色)。反向传播(红色)是从输出开始，根据链式法则递归的向前计算梯度，梯度在链路中回流。最终计算得到梯度<code>[dfdx, dfdy, dfdz]</code>为<code>[-4,-4,3]</code>，如图所示<br><img src="/2019/09/30/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/image/BP-01.jpg" alt></p>
<h3 id="反向传播的直观理解——门单元间梯度的传递"><a href="#反向传播的直观理解——门单元间梯度的传递" class="headerlink" title="反向传播的直观理解——门单元间梯度的传递"></a>反向传播的直观理解——门单元间梯度的传递</h3><p>任何可微的函数都可以看做若干个门单元的组合形式，例如加法门、乘法门、除法门、取最大值门等</p>
<script type="math/tex; mode=display">
\begin{align*}
f(x) &= \frac{1}{x} \to \frac{df}{dx} = -\frac{1}{x^{2}} \\
f(x) &= a + x \to \frac{df}{dx} = 1 \\
f(x) &= e^{x} \to \frac{df}{dx} = e^{x} \\
f(x) &= ax \to \frac{df}{dx} = a \\
\end{align*}</script><p>在整个计算图过程中，每个单元门都会得到一些输入，并计算两个东西：</p>
<ul>
<li>这个门的输出</li>
<li>其输出值关于输入值的局部梯度$\nabla{a}$</li>
</ul>
<p>在反向传播过程中，门单元会获得整个网络输出值在自己的输出值上的梯度$\nabla{b}$，由链式法则可知，将$\nabla{b}$乘以$\nabla{a}$可得到整个网络的输出对于该门的每个输入的梯度</p>
<p>在梯度的回流中，不同的门单元有不同的作用。下图展示了一个反向传播的例子，加法操作将梯度相等地分发给它的输入。取最大操作将梯度路由给更大的输入。乘法门拿取输入激活数据，对它们进行交换，然后乘以梯度<br><img src="/2019/09/30/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/image/BP-02.jpg" alt></p>
<h3 id="神经网络中的反向传播"><a href="#神经网络中的反向传播" class="headerlink" title="神经网络中的反向传播"></a>神经网络中的反向传播</h3><p>在神经网络中，反向传播是对权重和偏置变化影响代价函数$C$过程的理解，最终目的是为了计算偏导数$\frac{\partial C}{\partial \boldsymbol{\omega}}$和$\frac{\partial C}{\partial \boldsymbol{b}}$。定义网络中第$l$层第$j$个神经元上的误差$\delta_{j}^{l}$为</p>
<script type="math/tex; mode=display">
\delta_{j}^{l} = \frac{\partial C}{\partial z_{j}^{l}}</script><p>其中$z_{j}^{l}$是第$l$层第$j$个神经元的输出。向量化第$l$层的误差向量为$\boldsymbol{\delta}^{l}$。反向传播提供一种计算每层误差的方法，并将这些误差关联到$\frac{\partial C}{\partial \boldsymbol{\omega}}$和$\frac{\partial C}{\partial \boldsymbol{b}}$上</p>
<h4 id="反向传播的四个基本方程"><a href="#反向传播的四个基本方程" class="headerlink" title="反向传播的四个基本方程"></a>反向传播的四个基本方程</h4><p>定义$\boldsymbol{\delta}^{L}$表示输出层误差，对于每个元素，其误差为</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta_{j}^{L} &= \frac{\partial C}{\partial z_{j}^{L}} \\
               &= \frac{\partial C}{\partial a_{j}^{L}}\sigma'(z_{j}^{L})
\end{align*}</script><p>其向量形式为公式(BP1)</p>
<script type="math/tex; mode=display">
\boldsymbol{\delta}^{L} = \nabla_{a}{C}\ \odot sigma'(\boldsymbol{z}^{L}) \tag{BP1}</script><p>使用下一层误差$\boldsymbol{\delta}^{l+1}$表示当前层误差$\boldsymbol{\delta}^{l}$</p>
<script type="math/tex; mode=display">
\boldsymbol{\delta}^{l} = \left((\boldsymbol{\omega}^{l+1})^{T}\boldsymbol{\delta}^{l+1} \right) \odot \sigma'(\boldsymbol{z}^{l}) \tag{BP2}</script><p>其中$\odot$表示Hadamard乘积。通过公式BP1和(BP2)可以计算任意层的误差$\boldsymbol{\delta}^{l}$，首先使用公式BP1计算输出层误差$\boldsymbol{\delta}^{L}$，然后应用BP2计算$\boldsymbol{\delta}^{L-1}$，然后依次计算完整个网络</p>
<p>代价函数关于网络中任意偏置的改变率为</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial b_{j}^{l}} = \delta_{j}^{l}</script><p>这表示误差就是偏置的偏导数，向量形式为</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial \boldsymbol{b}^{l}} = \boldsymbol{\delta}^{l} \tag{BP3}</script><p>代价函数关于权重的改变率为</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial \omega_{jk}^{l}} = a_{k}^{l-1}\delta_{j}^{l}</script><p>向量形式为</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial \boldsymbol{\omega}^{l}} = \boldsymbol{a}^{l-1}\boldsymbol{\delta}^{l} \tag{BP4}</script><p>显示的描述反向传播的步骤</p>
<ol>
<li><strong>输入</strong>$\boldsymbol{x}$：为输入层设置对应的激活值$\boldsymbol{a}^{1}$</li>
<li><strong>前向传播</strong>：对每个层，计算相应的$\boldsymbol{z}^{l}=\boldsymbol{\omega}\boldsymbol{a}^{l-1}$和$\boldsymbol{a^{l}}=\sigma(\boldsymbol{z}^{l})$</li>
<li><strong>输出层误差</strong>$\boldsymbol{\delta}^{L}$：通过BP1计算</li>
<li><strong>反向传播误差</strong>：通过BP2计算</li>
<li><strong>更新</strong>$\boldsymbol{\omega}和\boldsymbol{b}$：通过BP3和BP4计算</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下图网络结构举例来说明反向传播算法是如何工作的<br><img src="/2019/09/30/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/image/BP-03.jpg" alt></p>
<h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>网络中由输入层、1层隐藏层和输出层共3层构成，按照以下参数初始化网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化输入输出</span></span><br><span class="line">i = [<span class="number">0.1</span>, <span class="number">0.2</span>]</span><br><span class="line">o = [<span class="number">0.01</span>, <span class="number">0.99</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化权重和偏置</span></span><br><span class="line">w = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">b = [<span class="number">0.55</span>, <span class="number">0.56</span>, <span class="number">0.66</span>, <span class="number">0.67</span>]</span><br></pre></td></tr></table></figure>
<h3 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算隐藏层神经元 h1 的输入加权和</span></span><br><span class="line">h1_in = w[<span class="number">0</span>]*i[<span class="number">0</span>] + w[<span class="number">1</span>]*i[<span class="number">1</span>] + b[<span class="number">0</span>] <span class="comment"># h1_in = 0.1*0.1+0.2*0.2+0.55 = 0.6000000000000001</span></span><br><span class="line"><span class="comment"># 计算隐藏层神经元 h1 的输出</span></span><br><span class="line">h1_out = sigmoid(h1_in) <span class="comment"># h1_out = 0.6456563062257954</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算隐藏层神经元 h2 的输入加权和</span></span><br><span class="line">h2_in = w[<span class="number">2</span>]*i[<span class="number">0</span>] + w[<span class="number">3</span>]*i[<span class="number">1</span>] + b[<span class="number">1</span>] <span class="comment"># h2_in = 0.3*0.1+0.4*0.2+0.56 = 0.67</span></span><br><span class="line"><span class="comment"># 计算隐藏层神经元 h1 的输出</span></span><br><span class="line">h2_out = sigmoid(h2_in) <span class="comment"># h2_out = 0.6615031592029524</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算输出层神经元 o1 的输入加权和</span></span><br><span class="line">o1_in = w[<span class="number">4</span>]*h1_out + w[<span class="number">5</span>]*h2_out + b[<span class="number">2</span>] <span class="comment"># o1_in = 0.5*0.6456563062257954 + 0.6*0.6615031592029524 + 0.66 = 1.379730048634669</span></span><br><span class="line"><span class="comment"># 计算输出层神经元 o1 的输出</span></span><br><span class="line">o1_out = sigmoid(o1_in) <span class="comment"># o1_out = 0.7989476413779711</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算输出层神经元 o2 的输入加权和</span></span><br><span class="line">o2_in = w[<span class="number">6</span>]*h1_out + w[<span class="number">7</span>]*h2_out + b[<span class="number">3</span>] <span class="comment"># o2_in = 0.7*0.6456563062257954 + 0.8*0.6615031592029524 + 0.67 = 1.6511619417204186</span></span><br><span class="line"><span class="comment"># 计算输出层神经元 o2 的输出</span></span><br><span class="line">o2_out = sigmoid(o2_in) <span class="comment"># o2_out = 0.8390480283342561</span></span><br></pre></td></tr></table></figure>
<p>正向传播结束后的输出结果为<code>[0.7989476413779711, 0.8390480283342561]</code>，但是希望的输出是<code>[0.01, 0.99]</code>，因此利用反向传播更新权重和偏置，然后重新计算输出</p>
<h3 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h3><p>代价函数使用</p>
<script type="math/tex; mode=display">
C = \frac{1}{2}\sum_{j}\left(y_{j} - a_{j}^{l} \right)</script><p>其导数为</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial a_{j}^{l}} = a_{j} - y_{j}</script><p>根据BP1，输出层神经元的误差$\delta_{j}^{3}$计算方法为</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta_{j}^{3} &= \nabla_{a}{C}*\sigma'(z_{j}^{3}) \\
               &= (a_{j}^{3} - y_{j})*(a_{j}^{3}*(1-a_{j}^{3}))
\end{align*}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算输出层神经元 o1 的误差</span></span><br><span class="line">o1_err = (o1_out - o[<span class="number">0</span>])*(o1_out*(<span class="number">1</span>-o1_out)) <span class="comment"># o1_err = 0.12672890240521031</span></span><br><span class="line"><span class="comment"># 计算输出层神经元 o2 的误差</span></span><br><span class="line">o2_err = (o2_out - o[<span class="number">1</span>])*(o2_out*(<span class="number">1</span>-o2_out)) <span class="comment"># o2_err = -0.020385525551585255</span></span><br></pre></td></tr></table></figure>
<p>根据BP2，隐藏层神经元的误差$\delta_{j}^{2}$计算方法为</p>
<script type="math/tex; mode=display">
\delta_{j}^{2} = ((\boldsymbol{\omega}^{3})^{T}\boldsymbol{\delta}^{3}) \odot \sigma'(z_{j}^{2})</script><p>在计算时只需要计算与该神经元相关的连接，例如计算隐藏层神经元<code>h1</code>时，只需要计算权重<code>w5</code>和<code>w7</code>，设$\omega_{jk}^{l}$表示从$(l-1)$层第$k$个神经元到第$l$层第$j$个神经元的权重</p>
<script type="math/tex; mode=display">
\delta_{1}^{2} = (\omega_{11}^{3}*\delta_{1}^{3} + \omega_{12}^{3}*\delta_{1}^{3})*(a_{1}^{2}*(1-a_{1}^{2}))</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算隐藏层神经元 h1 的误差</span></span><br><span class="line">h1_err = (w[<span class="number">4</span>]*o1_err + w[<span class="number">6</span>]*o2_err)*(h1_out*(<span class="number">1</span>-h1_out)) <span class="comment"># h1_err = 0.011232066954600498</span></span><br><span class="line"><span class="comment"># 计算隐藏层神经元 h2 的误差</span></span><br><span class="line">h2_err = (w[<span class="number">5</span>]*o1_err + w[<span class="number">7</span>]*o2_err)*(h2_out*(<span class="number">1</span>-h2_out)) <span class="comment"># h2_err = 0.013374304651329562</span></span><br></pre></td></tr></table></figure>
<p>根据BP4可计算某个权重的偏导数，例如<code>w5</code>，其偏导数为</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial \omega_{11}^{3}} = a_{1}^{2}*\delta_{1}^{3}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算权重 w5 的偏导数</span></span><br><span class="line">d_w5 = o1_err*h1_out <span class="comment"># d_w5 = 0.08182331501899741</span></span><br><span class="line"><span class="comment"># 计算权重 w1 的偏导数</span></span><br><span class="line">d_w1 = h1_err*i[<span class="number">0</span>] <span class="comment"># d_w1 = 0.0011232066954600499</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/38525412">知乎-梯度的方向为什么是函数值增加最快的方向？</a></li>
<li><a href="https://www.zhihu.com/question/36301367/answer/156102040">知乎-如何直观形象的理解方向导数与梯度以及它们之间的关系？</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/5970503.html">博客园-刘建平Pinard-梯度下降（Gradient Descent）小结</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38006693">知乎-AI从入门到放弃：BP神经网络算法推导及代码实现笔记</a></li>
<li><a href="http://cs231n.github.io/optimization-2/#backprop">CS231n-Backpropagation, Intuitions</a></li>
<li><a href="http://cs231n.github.io/optimization-1/">CS231n-Optimization: Stochastic Gradient Descent</a></li>
<li><a href="http://www.deeplearningbook.org/">MIT Press book:Deep Learning</a></li>
<li><a href="http://neuralnetworksanddeeplearning.com/">Michael Nielsen:Neural Networks and Deep Learning</a></li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
        <category>理论</category>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>每月见闻201906</title>
    <url>/2019/06/20/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201906/</url>
    <content><![CDATA[<h1 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h1><ul>
<li><a href="https://libra.org/zh-CN/vision/">Facebook libra</a><br>Facebook推出了libra，一个全球化稳定加密货币。它基于区块链技术，以真实的资产兑换为担保，希望建立一个全球数字化的金融系统。以下几个问题值得思考<ul>
<li>区块链技术并不是一个新鲜的东西，这一概念从诞生到现在，为什么一直没有实际的发展，难以落地的原因是什么？</li>
<li>libra和比特币有什么不同？</li>
<li>libra如果做大，对全球的交易行为、金融生态有什么影响，对我们有什么影响？</li>
<li>Facebook为什么可以做出libra，而不是别的公司？</li>
</ul>
</li>
<li><a href="http://shumeipai.nxez.com/2019/06/24/raspberry-pi-4-on-sale-now.html">树莓派第四代</a><br>树莓派发布了第4代开发板，性能强劲，价格35$起，ARM Cortex-A72的CPU、4G DDR4 SDRAM、802.11 A/C Wi-Fi、蓝牙5.0、USB 3.0、4K 60帧硬解码</li>
</ul>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><ul>
<li><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">Benchmarks Game</a><br>常用编程语言（27种）的两两性能对比，发现哪种语言最快</li>
</ul>
<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><ul>
<li><p><a href="https://www.bilibili.com/video/av55498503">vim使用、配置及插件介绍</a></p>

<iframe width="800" height="600" src="//player.bilibili.com/player.html?aid=55498503&cid=97032762&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


<iframe width="800" height="600" src="//player.bilibili.com/player.html?aid=55664166&cid=97315421&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>视频中对vim的常用用法做了比较详细的介绍，满满的都是干货。例如一些常用的设置、键位映射、块操作、动作录制、颜色方案、分屏操作、文件目录、Markdown支持等</p>
</li>
<li><p><a href="https://www.bilibili.com/video/av55905448?from=search&amp;seid=2099448832952715703">Deep Work</a><br>卡尔·纽波特写的《Deep Work》这本书中介绍了什么是深度工作，什么是浅度工作，以及如何进入和训练深度工作。他认为深度工作是一个高效的、高质量的、创造性的、能够提升学术和专业能力的过程。但是由于现代公司的组织结构，人们很难进入深度工作状态，也更倾向于看起来非常忙碌的浅度工作状态(一心多用、重复性的，不能创造什么价值，可替代性高)。深度工作中，人需要保持高度专注，更加关注自己的能力发挥、有意识地提高自己的效率、思考如何做到高质量，高质量工作的公式为：<br>\begin{equation}<br>High-Quality Work = Time * Intensity<br>\end{equation}<br>高质量的工作等于时间乘以专注程度</p>
</li>
</ul>
<h1 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h1><ul>
<li><p><a href="https://machinelearningmastery.com/blog/">Machine Learning Mastery</a><br>Jason Brownlee, PhD.(杰森·布朗利博士)创建的一个社区，帮助开发者学习机器学习相关内容，里面有很多方面的内容。杰森·布朗利本人在机器学习领誉造诣很深</p>
</li>
<li><p><a href="https://www.bilibili.com/video/av15040118?from=search&amp;seid=3864525550271204006">Mariana学霸</a><br>Mariana(玛丽安娜)是一位葡萄牙的学霸妹子，经常在youtube(Mariana’s Study Corner)上发一些和学习习惯、技巧相关的视频，除了看学霸是怎么学习的，顺便练练听力也不错</p>
</li>
</ul>
]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻201907</title>
    <url>/2019/07/04/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201907/</url>
    <content><![CDATA[<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ul>
<li><p><a href="https://baike.baidu.com/item/POE/65616?fr=aladdin">PoE</a><br>PoE(Power over Ethernet，有源以太网)，利用以太网传输数据的同时，为设备供电。IEEE 802.3af标准规定了该技术的各项指标</p>
</li>
<li><p><a href="https://hyb1996.github.io/AutoJs-Docs/#/">autojs</a><br>一个利用Android系统无障碍开发服务的框架，可以在不root的情况下实现录制屏幕、触发按键、启动APP、捕获UI、弹出对话框、监听事件、多线程、定时器等功能</p>
</li>
<li><p><a href="https://github.com/fatedier/frp">frp</a><br>一个快速的反向代理，可以让你本地的服务穿过NAT或者防火墙，暴露到外网。支持TCP、UDP，为HTTP、HTTPS提供了额外的支持</p>
</li>
<li><p><a href="https://trackingjs.com/">tracking.js</a><br>一个在浏览器环境实现计算机视觉算法的js库，可实现颜色跟踪、人脸检测等</p>
</li>
<li><p><a href="https://javascript.info/clickjacking">iframe劫持</a><br>分析网页iframe劫持原理，并介绍如何避免</p>
</li>
<li><p><a href="https://www.tomshardware.com/reviews/raspberry-pi-4-b,6193.html">树莓派4 benchmark</a><br>tom’s HEADWARE 发布了一篇详细分析树莓派4板子性能的文章，包括了CPU运算能力、内存读写能力、文件压缩能力、GPU能力、存储读写能力、网络吞吐量、功耗和温度等，一方面可以了解到树莓派的性能到底处于什么水平，另一方面也可以学习一下性能测试有哪些关注点、测试方法有哪些</p>
</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p><a href="https://tableconvert.com/">tableconvert</a><br>一个在线将表格转换为Markdown、JSON、Latex等格式的页面</p>
</li>
<li><p><a href="https://github.com/apankrat/nullboard">Nullboard</a><br>一个开源的本地看板工具</p>
</li>
</ul>
<h2 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h2><ul>
<li><p><a href="https://baijiahao.baidu.com/s?id=1640010983448530393&amp;wfr=spider&amp;for=pc">阿里巴巴旗下[平头哥]发布首枚芯片:玄铁910</a><br>平头哥是阿里巴巴旗下独立的芯片公司，于2018年9月成立，整合了中天微系统有限公司和达摩院。玄铁910采用高性能RISC-V(开源)架构，采用 12nm制程，主频2.5GHz，7.1Coremark/MHZ。该颗芯片适用于用在5G、网络通讯、人工智能、自动将驾驶领域，可嵌入CPU、SOC芯片中。</p>
</li>
<li><p><a href="https://www.zhihu.com/question/336447092">华为年薪百万的应届博士到底有多厉害</a><br>关注一下最新的前沿研究方向</p>
<ul>
<li>钟钊(博士)年薪制方案：182-201万人民币/年<br>学校：中国科学院大学2014级硕士生、2016级博士生<br>研究方向：模式识别与智能系统</li>
<li>秦通(博士)年薪制方案，182-201万人民币/年<br>学校：香港科技大学机器人研究所四年级博士生<br>研究方向：机器视觉SLAM，视觉惯导融合，多传感器定位</li>
<li>李屹(博士)年薪制方案，140.5-156.5万人民币/年<br>学校：北大数学学院，硕博连读生<br>代表文章：《R-FCN:基于区域的全卷积网络进行的目标检测》《Coordination and Composition: From Reo to Mediator》</li>
<li>管高扬(博士)年薪制方案：140.5-156.5万人民币/年<br>学校：浙江大学研发中心<br>研究方向：物联网和边缘计算</li>
<li>贾许亚(博士)年薪制方案：89.6-100.8万入民币/年<br>学校：清华大学科学与技术<br>代表文章：《Intelligent path control for energy-saving in hybrid SDN networks》</li>
<li>王承珂(博士)年薪制方案：89.6-100.8万人民币/年<br>学校：北京大学信息与技术学院，本科直博<br>研究方向：功耗控制</li>
<li>林晗(博士)年薪制方案，89.6-100.8万人民币/年<br>学校：中国科技大学计算机科学与技术学院<br>研究方向：大数据</li>
<li>何睿(博士)年薪制方案：89.6-100.8万人民币/年<br>学校：中国科学院，数学与系统科学研究院<br>研究方向：计算数学</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://www.zhihu.com/question/336650298">科学家成功在DNA上运行SQL</a> 原论文 <a href="/download/每月见闻201907/data-publi-5783.pdf">PDF</a><br>使用DNA存储数据乍一听很奇怪，实际上大有意义。现在研究人员已取得了重大突破，他们因而能够将DNA存储整合到PostgreSQL这种流行的开源数据库中<ul>
<li>为什么要使用DNA作为存储介质？<br>信息、数据的产生速度越来越快，而传统存储系统的存储能力和更新速率已经远远落后了，需要一种存储能力更强大、成本更低的介质</li>
<li>DNA作为存储介质的特性<br>DNA是一种极其密集的三维存储介质，具有在1克中存储455艾字节的理论能力，是现代硬盘存储密度的300亿倍。保存时间长，在常温,无水,无氧的条件下, 可以保存几个世纪；而磁盘和磁带的寿命只有5年和30年。复制起来容易, 快速和便宜</li>
<li>面临的问题<br>成本问题，主要是完整基因组测序工作成本很高。读写速度比不上传统硬盘，只有4M每秒。准确率问题，科学家声称的DNA存储技术的数据准确率大约在99%，但是这样会对生物体基因带来不可估量的问题</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻201908</title>
    <url>/2019/08/07/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201908/</url>
    <content><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul>
<li><p><a href="https://github.com/mayeaux/videodownloader">videodownloader</a><br>一个使用Electron制作的Youtube-dl的图形界面，可以下载包括Youtube、优酷、网易云音乐等在内的110个网站的视频</p>
</li>
<li><p><a href="https://github.com/jesseduffield/lazydocker">lazydocker</a><br>命令行管理Docker服务的一个图形界面工具</p>
</li>
</ul>
<h1 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h1><ul>
<li><p><a href="https://www.cam.ac.uk/research/news/robot-uses-machine-learning-to-harvest-lettuce">生菜收割机器人</a><br>英国剑桥大学开发了一个收割生菜的机器人。它用摄像头识别出每棵生菜，然后使用机器学习算法判断是否生长成熟，有没有感染疾病，如果一切正常，就进行收割</p>
</li>
<li><p><a href="https://www.zhihu.com/question/339567108/answer/781523669">华为发布HarmonyOS 鸿蒙操作系统</a><br>2019年8月9日，华为在其开发者大会上正式向全球发布了其自研的HarmonyOS。该系统是基于微内核的面向全场景的分布式操作系统，具有分布架构、内核安全、生态共享、天生流畅四大优势。鸿蒙OS不同于宏内核的Linux，属于微内核，并且属于seL4阶段，能够进行形式化验证(数学方法验证Bug Free)，仅仅将时钟管理、内存、中断、网络等内容放在微核中，其他系统级服务都在应用层以服务的形式提供，因此微内核代码量很小(9000行)</p>
</li>
</ul>
<h1 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h1><ul>
<li><a href="https://github.com/codeplea/genann">genann</a><br>Genann是一个轻量级、测试稳定的C语言神经网络库，其使用前向反馈神经网络，简单、快速、可靠、稳定<br><img src="/2019/08/07/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201908/image/201908-01.png" alt></li>
</ul>
<h1 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h1><ul>
<li><a href="http://michaelnielsen.org/">Michael Nielsen</a><br>Michael Nielsen 是⼀位量⼦物理学家、科学作家、计算机编程研究⼈员，Neural Networks and Deep Learning(神经⽹络与深度学习)这本书的作者</li>
</ul>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><ul>
<li><p><a href="https://devconnected.com/syslog-the-complete-system-administrator-guide/">linux syslog 日志指南</a><br>介绍Linux日志系统及协议的文档</p>
</li>
<li><p><a href="https://github.com/metafizzy/zdog">Zdog</a><br>一个JavaScript的3D设计和动画制作库</p>
</li>
<li><p><a href="https://the-super-tiny-compiler.glitch.me/">the-super-tiny-compiler</a><br>一个介绍编译原理的教学示例项目</p>
</li>
</ul>
]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻201909</title>
    <url>/2019/09/10/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201909/</url>
    <content><![CDATA[<h2 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h2><ul>
<li><a href="http://blog.pifan.org/index.php/knowledge-base/pi64-info/">树莓派64位系统</a><br>树莓派爱好者基地发布的基于Debian64位的树莓派操作系统，对内核进行了魔改、大量深度的优化和BUG修复，加入了很多新的功能和特性，特别是加入了KVM虚拟化的支持以及重点加强了对Docker的各项特性支持和优化。关键特性如下<ul>
<li>WEB SSH</li>
<li>QEMU-KVM 虚拟机</li>
<li>KVM 虚拟化的支持选项</li>
<li>Docker</li>
<li>AUFS</li>
<li>Swap</li>
<li>zSWAP</li>
<li>USB启动</li>
<li>UEFI启动</li>
<li>TCP加速</li>
</ul>
</li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><p><a href="http://playground.tensorflow.org/#activation=relu&amp;batchSize=10&amp;dataset=circle&amp;regDataset=reg-plane&amp;learningRate=0.03&amp;regularizationRate=0&amp;noise=0&amp;networkShape=4,2&amp;seed=0.37490&amp;showTestData=false&amp;discretize=false&amp;percTrainData=50&amp;x=true&amp;y=true&amp;xTimesY=false&amp;xSquared=false&amp;ySquared=false&amp;cosX=false&amp;sinX=false&amp;cosY=false&amp;sinY=false&amp;collectStats=false&amp;problem=classification&amp;initZero=false&amp;hideText=false">tensorflow playground</a><br>Tensorflow官方发布了一个可视化神经网络结构的web，可选择一些数据分布，调整学习速率、激活函数、网络结构等，运行并实时查看网络的训练情况<br><img src="/2019/09/10/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201909/image/201909-01.png" alt></p>
</li>
<li><p><a href="https://github.com/klaussinani/taskbook">taskbook</a><br>一个命令行的任务管理工具<br><img src="/2019/09/10/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201909/image/201909-02.png" alt></p>
</li>
<li><p><a href="https://lookao.com/">lookao</a><br>一个干净的搜索引擎，不会追踪和监控用户隐私<br><img src="/2019/09/10/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201909/image/201909-03.png" alt></p>
</li>
<li><p><a href="https://arxiv.org/list/cs.CE/recent">arXiv</a><br>一个免费的论文网站，包括数学、物理、计算机、统计、天文、定量生物、定量金融等领域的研究论文</p>
</li>
<li><p><a href="https://github.com/unbug/codelf">codelf</a><br>一个github开源项目，用于帮助给代码中的变量或者函数起名，web访问地址：<a href="https://github.com/unbug/codelf">https://github.com/unbug/codelf</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻201910</title>
    <url>/2019/10/08/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201910/</url>
    <content><![CDATA[<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/20085048">没有math.h我们能干啥？</a><br>许多场景下的开发环境中并不支持数学运算math库，可以自己实现一些函数来使用，例如快速幂实现pow、自适应辛普森公式实现lnx、牛顿迭代实现sqrt、泰勒级数实现exp、三角函数、反三角函数、双曲函数等</li>
</ul>
<h2 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h2><ul>
<li><a href="https://www.jiqizhixin.com/articles/2018-06-13-5">MIT可穿墙透视评估人体姿态</a><br>MIT项目<code>RF-Pose</code>使用了一个神经网络来分析人们的身体反射的无线电信号，然后可以创建一个随人类动作而同步的动态火柴人行走、停下、坐下和移动肢体的图像</li>
</ul>
<p><img src="/2019/10/08/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201910/image/news-01.png" alt></p>
<p>该研究论文为<a href="/download/每月见闻201910/2406.pdf">Through-Wall Human Pose Estimation Using Radio Signals</a>，此研究发布了一个视频：</p>


<style>
@media all and (orientation : landscape) {
    .video {width:800px; height:600px;}
}

@media all and (orientation : portrait){
    .video {width:90%; height:250px;}
}
</style>




<iframe class="video" src="//player.bilibili.com/player.html?aid=68868549&cid=119354681&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻201911</title>
    <url>/2019/11/15/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201911/</url>
    <content><![CDATA[<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="Home-Assistant"><a href="#Home-Assistant" class="headerlink" title="Home Assistant"></a>Home Assistant</h2><p>Home Assistant是一款基于Python的智能家居开源系统，支持众多品牌的智能家居设备，可以轻松实现设备的语音控制、自动化等，支持米家生态链、苹果HomeKit，还支持树莓派</p>
<ul>
<li><a href="https://home-assistant.cc/hassio/">Home Assistant中文文档</a></li>
<li><a href="https://github.com/home-assistant/home-assistant">Home Assistant github</a></li>
<li><a href="https://www.hachina.io/">Home Assistant中文网</a></li>
</ul>
<h2 id="TED-量子锁定"><a href="#TED-量子锁定" class="headerlink" title="TED-量子锁定"></a><a href="[https://www.bilibili.com/video/av77305418?from=search&amp;seid=9964401553436422127](https://www.bilibili.com/video/av77305418?from=search&amp;seid=9964401553436422127">TED-量子锁定</a></h2><p>由于若干技术的突破，研究发现在某种环境下，某些超导体会发生部分磁通力被束缚在超导体内部，导致周围空间和超导体内部的磁场构成一个锁定的磁力分布，使得超导体在三维空间上姿态锁定，且这种状态下的物体可以承重自身70000倍重力的物体，该研究可应用于发展新型零摩擦的交通工具，这种零摩擦并非是磁悬浮的互斥力，而是磁力锁定</p>
<h1 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h1><h2 id="知乎-华为251"><a href="#知乎-华为251" class="headerlink" title="知乎-华为251"></a><a href="[https://zhuanlan.zhihu.com/p/94561056](https://zhuanlan.zhihu.com/p/94561056">知乎-华为251</a></h2><p>最近接连发生了两起大公司内中龄员工被辞退纠纷事件，一个是网易辞退身患绝症的老员工并叫保安驱赶，一个是华为员工因向上举报部门业务造假被诬告敲诈勒索拘留251天</p>
]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻201912</title>
    <url>/2019/12/20/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB201912/</url>
    <content><![CDATA[<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="CS3210-Linux-insides"><a href="#CS3210-Linux-insides" class="headerlink" title="CS3210-Linux-insides"></a><a href="https://cs3210.cc.gatech.edu/index.html">CS3210-Linux-insides</a></h2><p>美国佐治亚理工学院(Georgia Institute of Technology, GT) CS-3210 课程，其题目是”Design Operating Systems“，设计操作系统。该课程以《Linux Inside》这本书作为教材，这本书gitbook地址为<a href="https://legacy.gitbook.com/book/0xax/linux-insides/details">linux-insides</a>，有人在github上发起了<a href="https://github.com/MintCN/linux-insides-zh/blob/master/README.md">linux-insides-zh</a>翻译项目，这本书的目录如下</p>
<ul>
<li><h1 id="Kernel-Boot-Process"><a href="#Kernel-Boot-Process" class="headerlink" title="Kernel Boot Process"></a>Kernel Boot Process</h1></li>
<li><h1 id="Kernel-initialization-process"><a href="#Kernel-initialization-process" class="headerlink" title="Kernel initialization process"></a>Kernel initialization process</h1></li>
<li><h1 id="Interrupts-and-Interrupt-Handling"><a href="#Interrupts-and-Interrupt-Handling" class="headerlink" title="Interrupts and Interrupt Handling"></a>Interrupts and Interrupt Handling</h1></li>
<li><h1 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h1></li>
<li><h1 id="Timers-and-time-management"><a href="#Timers-and-time-management" class="headerlink" title="Timers and time management"></a>Timers and time management</h1></li>
<li><h1 id="Synchronization-primitives-in-the-Linux-kernel"><a href="#Synchronization-primitives-in-the-Linux-kernel" class="headerlink" title="Synchronization primitives in the Linux kernel"></a>Synchronization primitives in the Linux kernel</h1></li>
<li><h1 id="Linux-kernel-memory-management"><a href="#Linux-kernel-memory-management" class="headerlink" title="Linux kernel memory management"></a>Linux kernel memory management</h1></li>
<li><h1 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h1></li>
<li><h1 id="Linux-kernel-concepts"><a href="#Linux-kernel-concepts" class="headerlink" title="Linux kernel concepts"></a>Linux kernel concepts</h1></li>
<li><h1 id="Data-Structures-in-the-Linux-Kernel"><a href="#Data-Structures-in-the-Linux-Kernel" class="headerlink" title="Data Structures in the Linux Kernel"></a>Data Structures in the Linux Kernel</h1></li>
<li><h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1></li>
<li><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1></li>
</ul>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><h2 id="Booting-ARM-Linux-on-MPCore"><a href="#Booting-ARM-Linux-on-MPCore" class="headerlink" title="Booting ARM Linux on MPCore"></a><a href="https://medium.com/@srinivasrao.in/booting-arm-linux-on-mpcore-95db62dabf50">Booting ARM Linux on MPCore</a></h2><p>Medium上一篇讲解多核ARM Linux启动的好文章，对Boot Monitor、U-boot和kernel启动汇编部分都有较为详细的说明</p>
]]></content>
      <categories>
        <category>每月见闻</category>
      </categories>
  </entry>
  <entry>
    <title>每月见闻202004</title>
    <url>/2020/04/21/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202004/</url>
    <content><![CDATA[<h1 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1U64y1u7oz">TinyML</a><br>该视频介绍了”Machine Learning with TensorFlow Lite on Arduino and Ultra-Low-Power Microcontrollers”这本书，该书研究将机器学习应用于低功耗的嵌入式设备当中的问题，例如将Tensorflow Lite应用于Arduino。有空可以了解一下，看能否用于NB-IoT设备</p>
<p>另外TinyML还有一个<a href="[https://www.tinyml.org/summit/](https://www.tinyml.org/summit/">网站</a>)</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>每月见闻</tag>
      </tags>
  </entry>
  <entry>
    <title>每月见闻202005</title>
    <url>/2020/05/09/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202005/</url>
    <content><![CDATA[<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p><a href="[https://oschvr.com/posts/blocking-ads-with-pihole/](https://oschvr.com/posts/blocking-ads-with-pihole/">Blocking Ads with PiHole</a></p>
<p>一篇详细的操作指导，一步步教你在树莓派上面安装 Pi-Hole，架设一个可以屏蔽广告的 DNS 服务器</p>
</li>
<li><p><a href="https://medium.com/swlh/git-worktrees-the-best-git-feature-youve-never-heard-of-9cd21df67baf">Git Worktree：你从未听说过的最好的 Git 功能</a></p>
<p>这篇文章简单介绍了 git worktree 功能，也就是让一个代码库的两个分支同时都可以访问的功能</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/G-LyRhJwhYk1rvj6vmMFLg">TensorFlow Lite 新功能亮相 TF DevSummit ‘20</a></p>
<p>在即将推出的Tensorflow 2.3版本中，针对Lite做了很多改进，旨在提供更方便、更快的学习框架。启用了最前沿的SOTA模型，使用了新的TensorFlow Lite 转换器，支持更多模型，支持 Keras 模型的训练时量化</p>
</li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><p><a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/rpi_DATA_2711_1p0.pdf">BCM2711 datasheet</a></p>
<p>树梅派4代的CPU datasheet终于公布了完整版本</p>
</li>
<li><p><a href="[https://tf.wiki/zh_hans/mlstudyjam.html](https://tf.wiki/zh_hans/mlstudyjam.html">简单粗暴的Tensorflow2.0</a></p>
<p>一个很棒的中文Tensorflow2.0在线文档</p>
</li>
<li><p><a href="https://lavanya.ai/">lavanya.ai</a></p>
<p>一个kaggle大神blog，介绍她很多比赛都能名列前茅的方法</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>每月见闻</tag>
      </tags>
  </entry>
  <entry>
    <title>每月见闻202006</title>
    <url>/2020/06/16/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202006/</url>
    <content><![CDATA[<h2 id="言论"><a href="#言论" class="headerlink" title="言论"></a>言论</h2><h3 id="算法工程师毒鸡汤"><a href="#算法工程师毒鸡汤" class="headerlink" title="算法工程师毒鸡汤"></a><a href="https://www.bilibili.com/video/BV1654y1B7Zi">算法工程师毒鸡汤</a></h3><p>在B站关注的一位微软人工智能UP主讲述了一期关于算法岗应该注意什么的问题，值得学习</p>


<style>
@media all and (orientation : landscape) {
 .video {width:800px; height:600px;}
}
@media all and (orientation : portrait){
 .video {width:90%; height:250px;}
}
</style>




<iframe class="video" src="//player.bilibili.com/player.html?aid=841073548&bvid=BV1654y1B7Zi&cid=202449874&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>其实在实际工程落地的时候，算法模型本身的很多问题都是微不足道的，旺旺制约落地的关键问题，是业务、数据、迭代等与算法不相关的方面。要搞算法，前提是怎么样让自己成为一名专业的工程师，怎么样能够编写出健壮性稳定性良好的代码，了解足够的后端相关知识，再去关注算法本身</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="Tensorflow案例分享—量化匠人经验，助力文化传承"><a href="#Tensorflow案例分享—量化匠人经验，助力文化传承" class="headerlink" title="Tensorflow案例分享—量化匠人经验，助力文化传承"></a>Tensorflow案例分享—量化匠人经验，助力文化传承</h3><p>日本广岛县熊野町生产的传统工艺品“熊野笔(Kumano Fude)”拥有很长的历史，是日本最著名的毛笔。由于笔头的品质难以用机器衡量，在大多数生产制作流程中，都是人工参与，导致产量很低。</p>
<p><img src="每月见闻202006/images/01.png" alt></p>
<p>某团队利用Tensorflow搭建了一个识别熊野笔良品的量化模型，首先利用一个卷积自编码器在人工筛选的良品上进行学习，在识别时输入任意笔刷图像，将会计算模型输入和输出的差距来判断是否为良品。</p>
<p><img src="每月见闻202006/images/02.png" alt></p>
<p>最终能够输出模型认为次品有问题的地方，用红色标注</p>
<p><img src="每月见闻202006/images/01.gif" alt></p>
<h3 id="滴滴未来出行"><a href="#滴滴未来出行" class="headerlink" title="滴滴未来出行"></a><a href="https://xw.qq.com/cmsid/20200627A0AO1Y00">滴滴未来出行</a></h3><p>滴滴在上海嘉定区开启了未来出行项目，通过部署无人驾驶网约车，用户有几率打到无人驾驶车，随车配备了安全驾驶员</p>
]]></content>
      <tags>
        <tag>每月见闻</tag>
      </tags>
  </entry>
  <entry>
    <title>每月见闻202007</title>
    <url>/2020/07/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202007/</url>
    <content><![CDATA[<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="电子织物微交互"><a href="#电子织物微交互" class="headerlink" title="电子织物微交互"></a>电子织物微交互</h3><p>在”ACM CHI 2020”会议中，Tensorflow团队展示了机器学习如何与交互式织物相结合，从而实现离散和连续手势的并行使用</p>
<p><img src="每月见闻202007/images/01.gif" alt></p>
<p>识别手势主要利用了<strong>螺旋感应矩阵 (HSM)</strong>，这些织物具有电容感应能力，具备传输和接收电极的作用。实验收集了 12 位参与者的数据，共得到 864 个手势样本，包括：轻弹、滑动、单点触摸手势等。训练后实现了约 94% 的手势识别准确率</p>
<p><img src="每月见闻202007/images/02.gif" alt></p>
<p>该技术未来可应用于线控耳机的手势控制方式、连帽衣物控制等</p>
<p><img src="每月见闻202007/images/03.gif" alt></p>
]]></content>
      <tags>
        <tag>每月见闻</tag>
      </tags>
  </entry>
  <entry>
    <title>每月见闻202108</title>
    <url>/2021/08/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202108/</url>
    <content><![CDATA[<h3 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h3><p>微软、OpenAL、Github联合推出了自动代码生成AI：Copilot，该技术使用OpenAI最新的GPT3语言模型，在Github海量(数十亿行代码)的公共仓库数据集上进行了代码学习训练。通过一个Web内测接口，用户可以在页面中输入需求描述，Copilot自动转换为代码，支持很多种编程语言，在Python、Java、JavaScript等语言方面尤其优秀</p>
<p><img src="/2021/08/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202108/images\02.png" alt></p>
<p><img src="/2021/08/13/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202108/images\03.png" alt></p>
<p>该项目发布后，在网络上引起了很多讨论，有人发现Copilot生成的代码和很多开源项目代码几乎是直接复制粘贴，有些甚至连注释都搬运过来。并且，Copilot无法理解复杂上下文环境，只能针对非常明确具体简单的需求给出一些代码块，并且程序员依然不能放心的使用，必须仔细检查代码中是否存在漏洞。最重要的问题是，Github官方在后续的回应中明确了使用了Github所有公开代码来训练Copilot，并且不区分License类别，后续Copilot还有可能商用的说法，引起了很多开发者的抨击，Github官方并不具备这样的权力，这样做本身就是对开源的破坏</p>
<p>参考</p>
<p><a href="https://copilot.github.com/">copilot技术预览网站</a></p>
<p><a href="https://www.openai.com/blog/openai-codex/">OpenAI Codex</a></p>
<p><a href="https://arxiv.org/abs/2107.03374">OpenAi Codex Paper</a></p>
]]></content>
      <tags>
        <tag>每月见闻</tag>
      </tags>
  </entry>
  <entry>
    <title>每月见闻202110</title>
    <url>/2021/10/15/%E6%AF%8F%E6%9C%88%E8%A7%81%E9%97%BB202110/</url>
    <content><![CDATA[<h2 id="ICCV2021"><a href="#ICCV2021" class="headerlink" title="ICCV2021"></a>ICCV2021</h2><p>不久前计算机视觉三大顶会之一的ICCV2021接收结果已经公布，本次ICCV共计6236篇有效提交论文，其中有1617篇被接收，接收率为25.9%</p>
<p>论文共分为检测、分割、估计、跟踪、视觉定位、底层图像处理、图像视频检索、三位视觉等多个方向，<a href="https://github.com/extreme-assistant/ICCV2021-Paper-Code-Interpretation">极市团队-ICCV论文代码整理</a>该Github项目整理了所有的相关论文和代码，主要有以下方向</p>
<ul>
<li><p>2D Object Detection(2D目标检测)</p>
</li>
<li><p>3D Object Detection(3D目标检测)</p>
</li>
<li><p>Saliency Object Detection(显著性目标检测)</p>
</li>
<li><p>Camouflaged Object Detection(伪装目标检测)</p>
</li>
<li><p>Anomally Detection in Image(图像异常检测/表面缺陷检测)</p>
</li>
<li><p>Edge Detection(边缘检测)</p>
</li>
<li><p>Image Segmentation(图像分割)</p>
</li>
<li><p>Instance Segmentation(示例分割)</p>
</li>
<li><p>Semantic Segmentation(语义分割)</p>
</li>
<li><p>Video Object Segmentation(视频目标分割)</p>
</li>
<li><p>Referring Image Segmentation(参考图像分割)</p>
</li>
<li><p>Dense Prediction(密集预测)</p>
</li>
<li><p>Facial Recognition/Detection(人脸识别/检测)</p>
</li>
<li><p>Face Generation/Face Synthesis/Face Reconstruction/Face Editing(人脸生成/合成/重建/编辑)</p>
</li>
<li><p>Face Forgery/Face Anti-Spoofing(人脸伪造/反欺骗)</p>
</li>
<li><p>3D Vision(三维视觉)</p>
</li>
<li><p>Point Cloud(点云)</p>
</li>
<li><p>3D Reconstruction(三维重建)</p>
</li>
<li><p>Neural Network Structure Design &amp; Optimization(神经网络设计与优化)</p>
</li>
<li><p>Transformer</p>
</li>
<li><p>NAS(神经网络架构搜索)</p>
</li>
<li><p>Loss Function(损失函数)</p>
</li>
<li><p>Visualization/Interpretability(可视化/可解释性)</p>
</li>
<li><p>Model Training/Generalization(模型训练/泛化)</p>
</li>
<li><p>Noisy Label(噪声标签)</p>
</li>
<li><p>Long-Tailed Distribution(长尾分布)</p>
</li>
<li><p>Out of Distribution Detection(分布外样本检测)</p>
</li>
<li><p>Knowledge Distillation(知识蒸馏)</p>
</li>
<li><p>Pruning(剪枝)</p>
</li>
<li><p>Quantization(量化)</p>
</li>
<li><p>Image Generation/Image Synthesis(图像生成/合成)</p>
</li>
<li><p>View Synthesis(视图合成)</p>
</li>
<li><p>GAN/Generative/Adversarial(GAN/生成式/对抗式)</p>
</li>
<li><p>Image Processing(图像处理)</p>
</li>
<li><p>Super Resolution(超分辨率)</p>
</li>
<li><p>Image Denoising(图像去噪/去模糊/去雨去雾)</p>
</li>
<li><p>Image Edit/Image Inpainting(图像编辑/修复)</p>
</li>
<li><p>Style Transfer(风格迁移)</p>
</li>
<li><p>Image Quality Assessment(图像质量评估)</p>
</li>
<li><p>Human Pose Estimation(姿态估计)</p>
</li>
<li><p>Depth Estimation(深度估计)</p>
</li>
<li><p>Image&amp;Video Retrieval/Video Understanding(图像&amp;视频检索/理解)</p>
</li>
<li><p>Action/Activity Recognition(行为识别/动作识别)</p>
</li>
<li><p>Re-Identification/Detection(行人重识别/检测)</p>
</li>
<li><p>Image/Video Caption(图像/视频字幕)</p>
</li>
<li><p>Visual Localization(视觉定位)</p>
</li>
<li><p>Image Matching(图像匹配)</p>
</li>
<li><p>3D Vision(三维视觉)</p>
</li>
<li><p>Object Tracking(目标跟踪)</p>
</li>
<li><p>Medical Imaging(医学影像)</p>
</li>
<li><p>Text Detection/Recognition(文本检测/识别)</p>
</li>
<li><p>Remote Sensing Image(遥感图像)</p>
</li>
<li><p>Scene Graph Generation(场景图生成)</p>
</li>
<li><p>Scene Graph Prediction(场景图预测)</p>
</li>
<li><p>Data Augmentation(数据增广)</p>
</li>
<li><p>Anomaly Detection(异常检测)</p>
</li>
<li><p>Representation Learning(表征学习)</p>
</li>
<li><p>Image Clustering(图像聚类)</p>
</li>
<li><p>Few-shot/Zero-shot Learning(小样本学习/零样本学习)</p>
</li>
<li><p>Continual Learning/Life-long Learning(持续学习)</p>
</li>
<li><p>Transfer Learning/Domain Adaptation(迁移学习/自适应)</p>
</li>
<li><p>Metric Learning(度量学习)</p>
</li>
<li><p>Incremental Learning(增量学习)</p>
</li>
<li><p>Contrastive Learning(对比学习)</p>
</li>
<li><p>Visual Reasoning/VQA(推理学习/视觉问答)</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>每月见闻</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>课程内容主要分为两个部分：算法分析和算法设计。算法分析是理论研究，研究计算机程序的性能和资源利用，尤其关注性能，也考量其他方面如通信、存储(内存、磁盘)等</p>
<h2 id="排序算法例子"><a href="#排序算法例子" class="headerlink" title="排序算法例子"></a>排序算法例子</h2><p>输入一组序列 <script type="math/tex">a_{1},a_{2},...,a_{n}</script>，按照从小到大的顺序排列后输出</p>
<p>使用插入排序算法来完成，伪代码如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For j=2 to n</span><br><span class="line">    key = A[j]</span><br><span class="line">    i = j-1</span><br><span class="line">    while i&gt;0 and A[i]&gt;key</span><br><span class="line">        A[i+1] = A[i]</span><br><span class="line">        i -= 1</span><br><span class="line">    A[i+1] = key</span><br></pre></td></tr></table></figure></p>
<p>该算法有两层循环，外层循环j从2到n递增，内层循环i从j-1到0递减。任意一次循环前的情况如图所示<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-01.png" alt="回调上下文"><br>关键点如下</p>
<ul>
<li>将数组j位置的元素提取出来，记作key</li>
<li>0到j-1位置的元素为已排列sorted</li>
<li>循环的目的就是使sorted部分增长1</li>
</ul>
<p>循环步骤如图所示<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-02.png" alt="回调上下文"><br>做法是一步步将前一个元素拷贝到后一个位置，直到找到key值的合适位置，插入进去</p>
<h2 id="排序算法分析"><a href="#排序算法分析" class="headerlink" title="排序算法分析"></a>排序算法分析</h2><h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>算法的运行时间取决于很多因素</p>
<ul>
<li><strong>输入本身</strong> 如果输入本身已经是排好序的或者部分排好序的，剩余的工作就很少；而最坏的情况是逆序，所有的元素都要重新调整</li>
<li><strong>输入规模</strong> 将运行时间看作数据规模的函数</li>
<li><strong>运行时间的上界</strong> 运行时间不会超过的某个值，这代表对用户的一种承诺；如果关注运行时间最快是多少是没有意义的，因为一个很烂的算法在输入本身已经排好序的情况下也可以很快</li>
</ul>
<h3 id="各种类型的分析"><a href="#各种类型的分析" class="headerlink" title="各种类型的分析"></a>各种类型的分析</h3><ul>
<li><strong>最坏情况分析</strong> 通常最关注这个，定义$T(n)$为输入规模为$n$时的最长运行时间，</li>
<li><strong>平均情况分析</strong> 这里$T(n)$是输入规模$n$之下所有可能输入的期望时间，而计算期望，必须假定或者给出输入的统计分布(如均匀分布、正态分布等)</li>
<li><strong>最好情况分析</strong> 这是一种假象，没啥用</li>
</ul>
<p>那么，插入排序的最坏情况消耗多少时间？首先取决于运行该算法的计算机，计算能力是多少。当比较算法时，比较的是相对速度，即在相同的计算机上作比较。当然，也会关心其绝对速度，一个算法，无论在什么样的机器上，其能力都可以用一种形式表示，那就是算法的大局观——渐进分析</p>
<h3 id="算法大局观——渐进分析"><a href="#算法大局观——渐进分析" class="headerlink" title="算法大局观——渐进分析"></a>算法大局观——渐进分析</h3><p>渐进分析的基本观点</p>
<ul>
<li>忽略掉依赖于机器的常量，</li>
<li>不去检查实际的运行时间</li>
<li>关注运行时间的增长</li>
</ul>
<p>定义$\Theta$符号，表示弃去低阶项，忽略常数因子。例如公式为$3n^{3}+90n^{2}-5n+6046$，最高阶是3阶，因此2阶项和1阶项都去掉，常数项也去掉，则该公式为$\Theta(n^{3})$</p>
<p>当$n \to +\infty$，可知总是存在一个$n$，使得$\Theta(n^{2})$的算法优于$\Theta(n^{3})$的算法，无论其他低阶项和常数项是什么；即使在一台慢速机器上运行$\Theta(n^{2})$，而在快速机器上运行$\Theta(n^{3})$，也不影响$\Theta(n^{2})$超过$\Theta(n^{3})$</p>
<p>$\Theta$符号的好处在于可以满足对相对速度和绝对速度的双重比较要求，因为无论在什么计算机平台上都能实现这一点，在不同平台上也许只差一个常数因子，但随着输入规模变大，渐进结果是准确的，如图<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-03.png" alt="回调上下文"><br>总会存在一个$n<em>{0}$，当$n &gt; n</em>{0}$时，$\Theta(n^{2})$比$\Theta(n^{3})$的时间开销更小。但是有些时候，$n_{0}$的值过大，大到计算机无法运行该算法，这也是某些情况下对相对低速的算法也感兴趣的原因，因为低速算法尽管用渐进的视角来看，最终可能比较慢，但是让然可以在合理输入范围内运行更快。因此需要在数学理论和工程直觉之间做权衡</p>
<h3 id="排序算法的最坏情况"><a href="#排序算法的最坏情况" class="headerlink" title="排序算法的最坏情况"></a>排序算法的最坏情况</h3><p>最坏情况是输入是逆向排序，每次循环都要把所有元素移动一次。假设每一条代码指令或原子操作都耗费某固定常数时间，而这个常数是多少无关紧要。外层循环从$j=2$到$n$，对于j的每一次取值，循环体的执行耗时应该是$j$乘以某个常数，则耗时为$\Theta(j)$。因此排序算法的总时间消耗为</p>
<p>\begin{equation}<br>T(n) = \sum_{i=1}^{n} \Theta(j)<br>\end{equation}</p>
<p>如何简化该公式呢？这是一个求和表达式，具体来说是等差数列求和，等差数列求和公式为</p>
<p>\begin{equation}<br>S(n) = na_{1} + \frac{n(n-1)}{2} d<br>\end{equation}</p>
<p>最高阶次为2次，省略掉常数项和低阶项，等于$\Theta(n^{2})$，即<br>\begin{equation}<br>T(n) = \sum_{i=1}^{n} \Theta(j) = \Theta(n^{2})<br>\end{equation}</p>
<p>因此，对于较小的$n$，插入排序的速度还可以，但是$n$足够大时，插入排序效率就比较低了</p>
<h2 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h2><p>对于数组<code>A[1...n]</code>的并归排序，有3个步骤</p>
<ol>
<li>如果<code>n=1</code>，认为已经排好序了</li>
<li>递归地对A[1到n/2向上取整]和A[n/2向下取整到n]这两部分排序</li>
<li>把排好序的两个表并归</li>
</ol>
<p>关键的子程序在于并归，下图中是两个已经排好序的数组，首先判断两张表中最小元素是多少，最小元素一定在两张表之首；然后将最小的元素拿出来<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-04.png" alt="回调上下文"><br>重复以上步骤，每次从两个表头取出最小的元素排在新数组的后面<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-05.png" alt="回调上下文"></p>
<h3 id="分析性能"><a href="#分析性能" class="headerlink" title="分析性能"></a>分析性能</h3><p>并归算法的$T(n)$是多少？该算法的3个步骤中，第1步只需要常数时间；第2步可以描述成<br>\begin{equation}<br>T(n) = T(n/2向下取整) + T(n/2向上取整) = 2T(n/2)<br>\end{equation}</p>
<p>第3步并归两张已排序好的表，耗时为$\Theta(n)$</p>
<p>综上，并归排序的总耗时$T(n)$为</p>
<script type="math/tex; mode=display">
T(n)=\left\{
    \begin{aligned}
        &\Theta(1), &if \quad n=1 \\
        &2T(n/2) + \Theta(n), &if \quad n>1\\
    \end{aligned}
\right.</script><p>该表达式用递归树方法分析<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-06.png" alt="回调上下文"></p>
<p>最终可以分解为一个递归树<br><img src="/2019/05/15/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/image/algorithm-analysis-07.png" alt="回调上下文"><br>树高为$\log<em>{2}n$，叶子节点最大为$n$，将树上所有层级耗时相加，总和为<br>\begin{equation}<br>C</em>{n} \log<em>{2}n + \Theta(n) = \Theta(n\log</em>{2}n)<br>\end{equation}</p>
<p>$\Theta(n\log_{2}n)$比$\Theta(n^{2})$快</p>
]]></content>
      <categories>
        <category>公开课</category>
        <category>MIT 算法导论</category>
      </categories>
      <tags>
        <tag>公开课</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>触发词检测</title>
    <url>/2020/06/28/%E8%A7%A6%E5%8F%91%E8%AF%8D%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>经过一个多月工作之余的研究和编码调试，终于将触发词检测的完整方案实现并验证有效，能够在PC端进行独立的实时触发词检测，开源代码见<a href="https://github.com/awokezhou/TriggerWordDetect">我的开源repo</a>。该project来源于deeplearning.ai的<a href="[https://www.deeplearning.ai/deep-learning-specialization/](https://www.deeplearning.ai/deep-learning-specialization/">Deep Learning Specialization</a>课程中的”Sequence Models”序列模型，课程中完整介绍了如何搭建一个基于神经网络的触发词检测模型</p>
<p>本文首先对deeplearning.ai的触发词检测课程内容进行介绍，然后对我自己的实现方案进行了介绍说明，最后总结了整个研究过程中的知识点和经验</p>
<h2 id="deeplearning-ai触发词检测"><a href="#deeplearning-ai触发词检测" class="headerlink" title="deeplearning.ai触发词检测"></a>deeplearning.ai触发词检测</h2><p>目前很多智能产品上都带有触发词检测功能，例如苹果Siri、百度小度、小米的小爱同学等。触发词检测(Trigger word detect)也叫做关键字检测(keyword detect)或者唤醒词检测(wakeword detect)，能够让设备在听到某个特定单词后自动唤醒。该课程介绍了一个触发词检测的通用模型，能够基于该模型训练自己的触发词，并在不同的设备上部署</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>设定一个10秒的检测窗口detect window，将音频内容划分为以下3种类型</p>
<ul>
<li><p>background：背景音</p>
</li>
<li><p>activate：激活词，也就是要检测的触发词</p>
</li>
<li><p>negative：负面词，不同于激活词的说话声</p>
</li>
</ul>
<p>10秒的检测窗口中，背景音一直存在，激活词和负面词可以在任意位置出现</p>
<p><img src="触发词检测/images/01.png" alt></p>
<p>将10秒的检测窗口划分为若干个检测单元，未出现触发词的检测单元，将其标签设置为0，出现触发词的检测单元，将其标签设置为1</p>
<p><img src="触发词检测/images/02.png" alt></p>
<p>标签1与触发词的出现时间需要有一定的滞后性，因为必须先检测到完整的触发词，才能输出检测到的结果</p>
<h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><p>首先需要为触发词检测算法构建一个数据集。理想情况下，最终的模型应该尽可能的在各种场景下都能够进行检测。因此，你需要在不同的背景声音中创建一段录音，例如图书馆、家中、办公室、户外、咖啡厅等等。另外，为了数据和模型有更好的泛化效果，采集的所有样本中，应该将激活次和负面词的出现频率和位置尽可能分布均匀。另外，如果你想要能够识别不同口音，那么需要采集更多样本，包括不同年龄、性别、体重、籍贯等</p>
<h4 id="程序化生成样本"><a href="#程序化生成样本" class="headerlink" title="程序化生成样本"></a>程序化生成样本</h4><p>数据集的来源可能是你去收集不同人的录音。如果以10秒的窗口为样本，那么你需要拿着一个录音设备采集多组10秒的音频，以1000个样本数量为例，总的样本时间为10000秒大概是2.7个小时，再加上寻找不同的人和沟通的时间，总的时间成本可能很长</p>
<p>可以使用一个程序化生成样本的方法，将收集的数据分为background、activate和negative三类。background表示在各种环境中采集若干个10秒的背景声音，activate表示采集不同人只说激活词的声音，negative表示不同人只说负面词的声音。采集完成后，将activate和negative样本随机的插入background中，这样能够更加快速的生成更多样本</p>
<p><img src="触发词检测/images/03.png" alt></p>
<h4 id="录音转换为频谱"><a href="#录音转换为频谱" class="headerlink" title="录音转换为频谱"></a>录音转换为频谱</h4><p>录音本质上是麦克风记录下气压的微小变化，而这种时域的录音信号，直接用来提取和分析特征，是非常困难的，通过转换到频域，能够更好地提取和利用特征</p>
<p>在Python中，可以用<code>matplotlib.pyplot</code>包的<code>specgram</code>方法实现录音转换为频谱数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">specgram</span>(<span class="params">filename</span>):</span></span><br><span class="line">    rate, data = wavfile.read(filename)</span><br><span class="line">    nfft = <span class="number">200</span></span><br><span class="line">    fs = <span class="number">8000</span></span><br><span class="line">    noverlap = <span class="number">120</span></span><br><span class="line">    nchannels = data.ndim</span><br><span class="line">    <span class="keyword">if</span> nchannels == <span class="number">1</span>:</span><br><span class="line">        pxx, freqs, bins, im = plt.specgram(data, nfft, fs, noverlap)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pxx, freqs, bins, im = plt.specgram(data[:,<span class="number">0</span>], nfft, fs, noverlap=noverlap)</span><br><span class="line">    <span class="keyword">return</span> pxx</span><br></pre></td></tr></table></figure>
<p>以上代码，将一个10秒的录音文件转换为频谱数据pxx。这里需要注意一下录音数据和频谱数据的shape</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rate, data = wavfile.read(<span class="string">&#x27;test.wav&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.shape</span><br><span class="line">(<span class="number">441000</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pxx = specgram(<span class="string">&#x27;test.wav&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pxx.shape</span><br><span class="line">(<span class="number">101</span>,<span class="number">5511</span>)</span><br></pre></td></tr></table></figure>
<p>因为录音使用44100Hz的采样频率，因此1秒产生44100帧音频数据，10秒就是441000帧数据，音频数据是一维的序列。转化为频谱数据后，将10秒划分为了5511个片段，并提取了101个主要频率的窗口</p>
<h4 id="创建一个训练样本"><a href="#创建一个训练样本" class="headerlink" title="创建一个训练样本"></a>创建一个训练样本</h4><p>创建训练样本的前提是，已经按照上文的要求，采集了若干数量的背景声、激活词和负面词的录音文件。生成一个训练样本，需要以下4个步骤</p>
<ul>
<li><p>随机选择一个背景录音</p>
</li>
<li><p>随机选择若干个激活词音频插入到背景的随机位置</p>
</li>
<li><p>随机选择若干个负面词音频插入到背景的随机位置</p>
</li>
<li><p>对生成的样本进行标记</p>
</li>
</ul>
<p>这里需要注意，插入的过程，是音频数据的叠加操作，而不是追加，例如向一个10秒的背景音频中插入1秒的激活词片段，插入后得到的合成音频仍然是10秒，而不是11秒。在进行多次插入时，为了避免重复插入到相同的位置，需要记录已经插入的片段位置</p>
<p>在进行标记时，将10秒的时长划分为1375，触发词后的50个片段被标记为1，这样做的好处是不需要人为的听取每一个合成音频再手动进行标记，标记过程可以自动进行。1375个片段长度是由模型决定的，后文介绍</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>使用的模型如图所示</p>
<p><img src="触发词检测/images/04.png" alt></p>
<p>模型的输入是合成音频转化成的频谱数据，shape为(5511,101)，输出shape为(1375,)。首先是经过一个一维卷积层，进行简单的特征提取，并减小数据大小到(1375,196)，然后数据经过两个GRU层，最后通过Sigmoid函数将输出归一化到0~1</p>
<h4 id="评估和预测"><a href="#评估和预测" class="headerlink" title="评估和预测"></a>评估和预测</h4><p>该模型在dev数据集上获得了0.94的精度。在预测时，先将音频数据输入模型，得到模型输出，然后遍历1375个输出数据，如果有连续50个数据大小超过某个阈值(0.6)，认为检测到触发词</p>
<h2 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h2><h3 id="数据集生成"><a href="#数据集生成" class="headerlink" title="数据集生成"></a>数据集生成</h3><p>实验环境为Linux，Linux系统为音频处理抽象了一个ALSA框架，包括声卡设备驱动、音频核心层和应用层的一些工具。录音使用”arecord”命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arecord -xxxx</span><br></pre></td></tr></table></figure>
<p>另外，还需要两个python音频处理包：pydub和alsaaudio。pydub用于处理音频插入合成，alsaaudio用于实时录音</p>
<h4 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h4><p>抽象了<code>DataLoader</code>类来用于加载和生成数据集，代码位于DataLoader.py。设定两个根目录下和数据集相关路径：</p>
<ul>
<li><p>orig：表示原始录音数据</p>
</li>
<li><p>gen：表示生成的合成音频和数据集</p>
</li>
</ul>
<p>orig路径下包括background、activate、negative三个文件夹，分别存放背景音、触发词和负面词。gen路径下包括train和dev两部分，分别存放训练集数据和验证集数据</p>
<p>DataLoader主要实现load、info和generate三个方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataLoader</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ...</span>):</span></span><br><span class="line">        /*......*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, ...</span>):</span></span><br><span class="line">        /*......*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        /*......*/</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, ...</span>):</span></span><br><span class="line">        /*......*/</span><br></pre></td></tr></table></figure>
<p>load主要完成从指定路径加载原始音频文件到内存，默认是从orig路径下加载，也可以从参数指定路径，路径下需要包含background、activate和negative三个子文件夹。info主要是显示loader相关信息，generate方法生成数据集文件，可通过target参数指定是生成训练集还是验证集</p>
<h5 id="load"><a href="#load" class="headerlink" title="load"></a>load</h5><p>load方法会遍历远视音频路径下的文件，并按照子文件夹background、activate和negative将音频文件加载到loader的<code>ori_activate</code>、<code>ori_negative</code>和<code>ori_background</code>三个列表中，加载音频文件是调用<code>AudioSegment</code>的<code>from_wav()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, path=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">        oripath = <span class="literal">None</span></span><br><span class="line">        valnames = self.__dict__</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            oripath = self.config[<span class="string">&#x27;ori_dir&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            oripath = path</span><br><span class="line">            self.config[<span class="string">&#x27;ori_dir&#x27;</span>] = path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> self.config[<span class="string">&#x27;labels&#x27;</span>]:</span><br><span class="line">            dirname = os.path.join(oripath, label)</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(dirname):</span><br><span class="line">                <span class="keyword">if</span> file[-<span class="number">4</span>:] == <span class="string">&#x27;.wav&#x27;</span>:</span><br><span class="line">                    data = AudioSegment.from_wav(os.path.join(dirname, file))</span><br><span class="line">                    valnames[<span class="string">&#x27;ori_&#x27;</span>+label].append(data)</span><br></pre></td></tr></table></figure>
<h5 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h5><p>考虑到PC机内存问题，要生成大量数据集文件，使用了batch的方式，generate参数支持批量生成，参数batchs用于控制批次，默认为1，batch_size用于控制单次生成的数量大小</p>
<p>在实现内部，使用<code>yield</code>抽象了一个生成器<code>_generator</code>来生成单个合成音频文件，一个批次的数据通过<code>numpy.save</code>导出为.npy文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, <span class="built_in">dir</span>=<span class="literal">None</span>, target=<span class="string">&#x27;train&#x27;</span>, batchs=<span class="number">1</span>, batch_size=<span class="number">100</span></span>):</span></span><br><span class="line"></span><br><span class="line">        target_dir = <span class="literal">None</span></span><br><span class="line">        target_path = <span class="literal">None</span></span><br><span class="line">        self.synthesis_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        np.random.seed(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_loaded():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;not loaded&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">dir</span>:</span><br><span class="line">            target_dir = self.config[<span class="string">&#x27;gen_dir&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target_dir = <span class="built_in">dir</span></span><br><span class="line">            self.config[<span class="string">&#x27;gen_dir&#x27;</span>] = <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            target_path = os.path.join(target_dir,self.config[<span class="string">&#x27;gen_train_dir&#x27;</span>])</span><br><span class="line">        <span class="keyword">elif</span> target == <span class="string">&#x27;dev&#x27;</span>:</span><br><span class="line">            target_path = os.path.join(target_dir,self.config[<span class="string">&#x27;gen_dev_dir&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        self.dataset_path = os.path.join(target_path, self.config[<span class="string">&#x27;gen_dataset_dir&#x27;</span>])</span><br><span class="line">        self.synthesis_path = os.path.join(target_path, self.config[<span class="string">&#x27;gen_synthesis_dir&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;target:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(target))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;target dir:&#123;&#125; path:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(target_dir, target_path))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dataset path:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.dataset_path))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;synthesis path:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.synthesis_path))</span><br><span class="line"></span><br><span class="line">        self.gen_clean(target_path)</span><br><span class="line">        self.gen_mkdir(target_path)</span><br><span class="line"></span><br><span class="line">        self.gen_X = np.zeros((batch_size, <span class="number">5511</span>, <span class="number">101</span>))</span><br><span class="line">        self.gen_Y = np.zeros((batch_size, <span class="number">1375</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batchs):</span><br><span class="line"></span><br><span class="line">                self.synthesis_count = <span class="number">0</span></span><br><span class="line">                random_backgrounds = self.get_random_data(self.ori_background, </span><br><span class="line">                                                          size=batch_size,</span><br><span class="line">                                                          fixed_size=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment">#print(&#x27;random backgrounds number &#123;&#125;&#x27;.format(len(random_backgrounds)))</span></span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> self._generator(random_backgrounds, i):</span><br><span class="line">                    self.gen_X[self.synthesis_count] = x.transpose()</span><br><span class="line">                    self.gen_Y[self.synthesis_count] = y.transpose()</span><br><span class="line">                    self.synthesis_count += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                np.save(<span class="string">&#x27;&#123;&#125;/X-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(self.dataset_path, i), self.gen_X)</span><br><span class="line">                np.save(<span class="string">&#x27;&#123;&#125;/Y-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(self.dataset_path, i), self.gen_Y)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;generated dataset batch&#123;&#125; to &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    i, self.dataset_path))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>单个生成数据的步骤为</p>
<ul>
<li><p>随机抽取一个背景音频</p>
</li>
<li><p>随机抽取几段actives音频，通过<code>AudioSegment</code>的<code>overlay</code>方法将active插入到background中，这里需要记录已插入的片段起始和结束时间，避免重复或覆盖</p>
</li>
<li><p>将插入了activate的位置，在同比例的Y数据中修改标记为1</p>
</li>
<li><p>随机抽取若干negative音频，插入背景中，同样要避免覆盖</p>
</li>
<li><p>将合成后的音频导出为.wav文件</p>
</li>
<li><p>读取.wav合成文件并转换为频谱数据</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> DataLoader improt DataLoader</span><br><span class="line"><span class="comment"># 创建loader实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader = DataLoader()</span><br><span class="line"><span class="comment"># 查看loader，可以看到loader还未加载数据，已经有生成的训练数据集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader.info()</span><br><span class="line">-- DataLoader info --</span><br><span class="line"><span class="keyword">not</span> load</span><br><span class="line">generated to gen</span><br><span class="line">generated train to gen/train</span><br><span class="line">	batchs:<span class="number">1</span> </span><br><span class="line">	batchsize:<span class="number">100</span> </span><br><span class="line">no dev</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载原始音频数据，可看到从orig加载了17个activates、30个negatives和30个背景</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader.load()</span><br><span class="line">data loaded <span class="keyword">from</span> ori, activate:<span class="number">17</span> negativa:<span class="number">30</span> background:<span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按默认参数生成训练集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loader.generate()</span><br><span class="line">...</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">94.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">95.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">96.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">97.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">98.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">synthesis:gen/train/synthesis/synthesis-<span class="number">0</span>-<span class="number">99.</span>wav exportd</span><br><span class="line">(<span class="number">441000</span>, <span class="number">2</span>)</span><br><span class="line">generated dataset batch0 to gen/train/dataset</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>模型就和deeplearning.ai课程介绍的一致，一个一维卷积层+2个GRU层+一个sigmoid激活函数，网络输入为5511乘101，输出为1375乘1，优化器用Adam，学习速率为0.001，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_model</span>(<span class="params">input_shape=(<span class="params"><span class="number">5511</span>,<span class="number">101</span></span>), learn_rate=<span class="number">0.001</span></span>):</span></span><br><span class="line"></span><br><span class="line">    model = tf.keras.models.Sequential()</span><br><span class="line"></span><br><span class="line">    model.add(layers.Input(shape = input_shape))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv1D(<span class="number">196</span>, kernel_size=<span class="number">15</span>, strides=<span class="number">4</span>))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.Activation(<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.GRU(units = <span class="number">128</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line"></span><br><span class="line">    model.add(layers.GRU(units = <span class="number">128</span>, return_sequences = <span class="literal">True</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.8</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.TimeDistributed(layers.Dense(<span class="number">1</span>, activation = <span class="string">&quot;sigmoid&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    opt = tf.keras.optimizers.Adam(lr=learn_rate, beta_1=<span class="number">0.9</span>, beta_2=<span class="number">0.999</span>, decay=<span class="number">0.01</span>)</span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=opt, loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="string">&quot;accuracy&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<p>训练使用了GPU加速，在5000个生成数据上进行了训练，没有使用学习速率衰减</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">modelname, train_index=<span class="number">0</span>, batch_size=<span class="number">10</span>, epochs=<span class="number">30</span>, save=<span class="literal">True</span>, lr_reduce=<span class="literal">False</span>, use_gpu=<span class="literal">True</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> use_gpu:</span><br><span class="line">        gpu_setting()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    callback_list = []</span><br><span class="line">    model = load_model(modelname)</span><br><span class="line">    X = np.load(<span class="string">&#x27;record_data_gen/train/dataset/X-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(train_index))</span><br><span class="line">    Y = np.load(<span class="string">&#x27;record_data_gen/train/dataset/Y-&#123;&#125;.npy&#x27;</span>.<span class="built_in">format</span>(train_index))</span><br><span class="line">    <span class="keyword">if</span> lr_reduce:</span><br><span class="line">        lr = ReduceLROnPlateau(monitor=<span class="string">&#x27;loss&#x27;</span>, patience=<span class="number">20</span>, verbose=<span class="number">1</span>, mode=<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">        callback_list.append(lr)</span><br><span class="line">    history = model.fit(X,Y,batch_size=batch_size,epochs=epochs, callbacks=callback_list)</span><br><span class="line">    model.save(modelname)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;train time:&#123;&#125; second&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(end-start)))</span><br><span class="line">    <span class="keyword">return</span> history</span><br></pre></td></tr></table></figure>
<p>最终的精度达到0.975左右，loss在0.01以下</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>实时预测</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>利用GRU模型处理时间序列</p>
</li>
<li><p>利用一维卷积预处理</p>
</li>
<li><p>利用GPU加速训练</p>
</li>
<li><p>Linux ALSA框架</p>
</li>
<li><p>train经验</p>
<ul>
<li><p>数据问题，数据一定要正确</p>
</li>
<li><p>训练速度问题，先用一个较大的学习速率验证自己数据是否正确，再降低速率进行正式学习</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>deeplearning.ai</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2019/08/28/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列分两种</p>
<ul>
<li>Queue: 先进先出，FIFO</li>
<li>Deque: 头节点尾节点都可随意进出</li>
</ul>
<p>特点及性能</p>
<ul>
<li>size固定</li>
<li>查找<script type="math/tex">O(n)</script></li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue又分为一般队列、可回滚队列和循环队列</p>
<ul>
<li>普通队列，Normal Queue</li>
<li>回滚队列，Rollback Queue</li>
<li>环形队列，Circular Deque</li>
</ul>
<p>普通队列一旦队满不能再入队。回滚队列和环形队列队满后都再次入队，回滚队列是通过移除队首元素实现，环形队列是通过覆盖队首元素并后移队首指针实现</p>
<p><img src="队列/images/queue-01.png" alt="一般队列和回滚队列"></p>
<p>普通队列和回滚队列结构和实现方式相似</p>
<ul>
<li>curr，队尾标记</li>
<li>_queue，队列实体，可用array或list实现</li>
</ul>
<p>环形队列需要队首队尾两个标记</p>
<ul>
<li>front，队首标记</li>
<li>rear，队尾标记</li>
<li>_queue，队列实体，可用array或list实现</li>
</ul>
<h3 id="Normal-Queue-amp-Rollback-Queue-实现-C"><a href="#Normal-Queue-amp-Rollback-Queue-实现-C" class="headerlink" title="Normal Queue &amp; Rollback Queue 实现(C)"></a>Normal Queue &amp; Rollback Queue 实现(C)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">q_unit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125; q_unit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> curr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_F_RB    0x0002</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_SIZE    8</span></span><br><span class="line">    q_unit _queue[QUEUE_SIZE];</span><br><span class="line">&#125; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_foreach(q, u)                            \</span></span><br><span class="line"><span class="meta">        int __k;                                    \</span></span><br><span class="line"><span class="meta">        u = &amp;q-&gt;_queue[q-&gt;curr];                    \</span></span><br><span class="line"><span class="meta">                                                    \</span></span><br><span class="line"><span class="meta">        for (__k = q-&gt;curr;                            \</span></span><br><span class="line"><span class="meta">             (__k&gt;=0);                                \</span></span><br><span class="line"><span class="meta">             __k--,                                    \</span></span><br><span class="line"><span class="meta">             u = &amp;q-&gt;_queue[__k])                    \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_empty</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((q-&gt;curr+<span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_full</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((q-&gt;curr+<span class="number">1</span>) == QUEUE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue_dq</span><span class="params">(<span class="built_in">queue</span> *q, q_unit *u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(q)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(u, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(q_unit));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(u, &amp;q-&gt;_queue[<span class="number">0</span>], <span class="keyword">sizeof</span>(q_unit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;q-&gt;curr; i++) &#123;</span><br><span class="line">        q-&gt;_queue[i] = q-&gt;_queue[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;q-&gt;_queue[q-&gt;curr], <span class="number">0x0</span>, <span class="keyword">sizeof</span>(q_unit));</span><br><span class="line">    q-&gt;curr--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue_eq</span><span class="params">(<span class="built_in">queue</span> *q, q_unit *u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_full(q)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mask_exst(q-&gt;flag, QUEUE_F_RB)) &#123;</span><br><span class="line">            q_unit _front;</span><br><span class="line">            queue_dq(q, &amp;_front);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;curr = (q-&gt;curr+<span class="number">1</span>)%QUEUE_SIZE;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;q-&gt;_queue[q-&gt;curr], u, <span class="keyword">sizeof</span>(q_unit));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue_init</span><span class="params">(<span class="built_in">queue</span> *q, <span class="keyword">uint16_t</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;q-&gt;_queue, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line"></span><br><span class="line">    q-&gt;curr = <span class="number">-1</span>;</span><br><span class="line">    mask_push(q-&gt;flag, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue_dump</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    q_unit *unit;</span><br><span class="line">    size = q-&gt;curr+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *pos;</span><br><span class="line">    <span class="keyword">char</span> dump[<span class="number">256</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;    </span><br><span class="line">    max = <span class="number">256</span>;</span><br><span class="line">    pos = dump;</span><br><span class="line"></span><br><span class="line">    queue_foreach(q, unit) &#123;</span><br><span class="line">        len = <span class="built_in">snprintf</span>(pos, max, <span class="string">&quot;%d &quot;</span>, unit-&gt;type);</span><br><span class="line">        pos += len;</span><br><span class="line">        max -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    log_debug(<span class="string">&quot;queue size:%d, data: [%s]&quot;</span>, size, dump);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q_unit u;</span><br><span class="line">    q_unit a, b, c, d;</span><br><span class="line">    <span class="built_in">queue</span> <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    queue_init(&amp;<span class="built_in">queue</span>, QUEUE_F_RB);</span><br><span class="line"></span><br><span class="line">    a.type = <span class="number">1</span>;</span><br><span class="line">    b.type = <span class="number">2</span>;</span><br><span class="line">    c.type = <span class="number">3</span>;</span><br><span class="line">    d.type = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    log_debug(<span class="string">&quot;eq [3 1 2 2 2 2 2 4 3 2 1] --&gt; &quot;</span>);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;a);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;c);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;d);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;a);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;c);</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    log_debug(<span class="string">&quot;eq [3 1 2 2] --&gt; &quot;</span>);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;b);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;a);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;c);</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    log_debug(<span class="string">&quot;eq [3] --&gt; &quot;</span>);</span><br><span class="line">    queue_eq(&amp;<span class="built_in">queue</span>, &amp;c);</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line">    queue_dq(&amp;<span class="built_in">queue</span>, &amp;u);</span><br><span class="line">    log_debug(<span class="string">&quot;dq --&gt; [%d] &quot;</span>, u.type);</span><br><span class="line"></span><br><span class="line">    queue_dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>AES-CBC</title>
    <url>/2019/05/23/AES-CBC/</url>
    <content><![CDATA[<p>开源项目mbedtls是一个专用于嵌入式arm平台的加解密方案，包含很多算法</p>
<p>github仓库地址<a href="https://github.com/ARMmbed/mbedtls">https://github.com/ARMmbed/mbedtls</a><br>官网地址<a href="https://tls.mbed.org/">https://tls.mbed.org/</a></p>
<h1 id="AES算法原理"><a href="#AES算法原理" class="headerlink" title="AES算法原理"></a>AES算法原理</h1><p>AES(Advanced Encryption Standard，高级加密标准)算法属于对称加密算法，几个关键概念</p>
<ul>
<li>分组密码体制</li>
<li>Padding</li>
<li>密钥</li>
<li>初始向量</li>
<li>加密模式</li>
</ul>
<h2 id="分组密码体制"><a href="#分组密码体制" class="headerlink" title="分组密码体制"></a>分组密码体制</h2><p>首先把明文拆分成一个个小段，对每个小段单独加密，最后再把每个加过密的小段拼起来，就是密文。拆分小段需要遵循字节对齐，每个小段长度必须为128bit(16字节)、196bit(24字节)或者256bit(32字节)</p>
<h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p>把明文末尾不满足字节对齐的最后一小段进行填充，有PKCS5、PKCS7和NOPADDING三种方式。PKCS5指分组缺少几个字节，就在数据末尾填充几个几，例如缺少3个字节，就在末尾填充3个3；PKCS7是指分组数据缺少几个字节，就在数据的末尾填充几个字节的0；NoPadding是指不需要填充，认为数据是填充好的</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>密钥长度与分组长度一致，位数越高，安全性越好，但是效率越低</p>
<h2 id="初始向量"><a href="#初始向量" class="headerlink" title="初始向量"></a>初始向量</h2><p>初始向量可以使得加密更加安全，需要通信双方固定好，初始向量在分组加密过程中重复被利用，初始向量首先和第一个分组进行计算，结果将作为下一个分组的初始向量。其长度规定为16字节</p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>加密模式有5种</p>
<ul>
<li>电码本模式(Electronic Codebook Boo, ECB)</li>
<li>密码分组链接模式(Cipher Block Chaining, CBC)</li>
<li>计算器模式(Counter, CTR)</li>
<li>密码反馈模式(Cipher FeedBack, CFB)</li>
<li>输出反馈模式(Output FeedBack, OFB)</li>
</ul>
<h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p>加密的核心步骤是4个操作：密钥扩展、初始轮、重复轮和最终轮</p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>密钥扩展是指根据初始密钥生成后面10轮密钥的操作；AES通过一个简单地快速混合，生成10轮密钥，加上原本的密钥，一共是11轮密钥，每一轮都是依据前一轮生成的，其4个步骤为：排列、置换、与轮常量异或<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-01.png" alt="回调上下文"><br><img src="/2019/05/23/AES-CBC/image/aes-cbc-02.png" alt="回调上下文"></p>
<h3 id="初始轮"><a href="#初始轮" class="headerlink" title="初始轮"></a>初始轮</h3><p>将第一个分组放在一个4*4的矩阵种，称为状态矩阵<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-03.png" alt><br>将状态矩阵和初始密钥进行亦或操作<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-04.png" alt></p>
<h3 id="重复轮"><a href="#重复轮" class="headerlink" title="重复轮"></a>重复轮</h3><p>把字节混淆、行移位、列混乱、加轮密钥这四个操作重复执行。重复轮重复的轮数取决于密钥的长度，128位16字节的密钥重复轮推荐重复执行9次，192位密钥重复轮推荐重复执行11次，256位密钥重复轮推荐重复执行13次<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-05.png" alt><br>重复轮每轮重复的操作包括：字节混淆、行移位、列混乱、加轮密钥</p>
<h4 id="字节混淆"><a href="#字节混淆" class="headerlink" title="字节混淆"></a>字节混淆</h4><p>把初始轮得到的状态矩阵经过一个置换盒，输出一个新的矩阵，叫它为字节混淆矩阵<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-06.png" alt></p>
<h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>对字节混淆矩阵进行行移位，然后再按照图中的方式重新放一下字节，这样行移位就算完成，得到的新矩阵，称之为行移位矩阵<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-07.png" alt></p>
<h4 id="列混乱"><a href="#列混乱" class="headerlink" title="列混乱"></a>列混乱</h4><p>用模不可约多项式将每列混乱，得到一个新的矩阵，称之为列混乱矩阵<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-08.png" alt></p>
<h4 id="加轮密钥"><a href="#加轮密钥" class="headerlink" title="加轮密钥"></a>加轮密钥</h4><p>在每一轮结束的时候，把列混乱矩阵和下一轮的密钥做一下异或操作，得到一个新的矩阵，称之为加轮秘钥矩阵<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-09.png" alt></p>
<h3 id="最终轮"><a href="#最终轮" class="headerlink" title="最终轮"></a>最终轮</h3><p>最终轮的操作和重复轮类似，只是没有列混乱的操作，<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-10.png" alt></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每执行一次AES加密，其实内部一共进行了11轮加密，包括1个初始轮，9个拥有4个操作的重复轮，1个拥有3个操作的最终轮，才算得到密文<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-11.png" alt><br>解密意味着加密的逆过程，只需要把加密的每个步骤倒着顺序执行就能完成解密了<br><img src="/2019/05/23/AES-CBC/image/aes-cbc-12.png" alt></p>
<p>注意点</p>
<ul>
<li>双方必须使用一样的密钥和初始向量IV</li>
<li>双方必须使用一样的加密模式</li>
<li>双方必须使用一样的Padding模式</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>分别以C语言和Java编写测试代码，测试字符串和字节序列的加密解密</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>mbedtls项目已实现，只需要做一些额外的封装</p>
<p><code>aes_string_padding()</code>函数用于对字符串进行填充，参数<code>s</code>是输入字符串，<code>c</code>是填充内容，<code>align</code>是对齐长度，<code>rlen</code>为返回的填充后长度，函数返回值为一个新的字符串<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">aes_string_padding</span><span class="params">(<span class="keyword">uint8_t</span> *s, <span class="keyword">char</span> c, <span class="keyword">int</span> align, <span class="keyword">int</span> *rlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">uint8_t</span> *p;</span><br><span class="line">	<span class="keyword">uint8_t</span> *new_s;</span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line">	<span class="keyword">size_t</span> align_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((!s) || (align &lt;= <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">if</span> (len==align)</span><br><span class="line">		align_len = align;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		align_len = ((len/align)+<span class="number">1</span>)*align;</span><br><span class="line">	new_s = mem_alloc(align_len);</span><br><span class="line">	p = new_s;</span><br><span class="line">	<span class="built_in">memcpy</span>(p, s, len);</span><br><span class="line">	p += len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;align_len-len; i++) &#123;</span><br><span class="line">		buf_push_byte(c, p);</span><br><span class="line">	&#125;</span><br><span class="line">	*rlen = align_len;</span><br><span class="line">	<span class="keyword">return</span> new_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数<code>aes_byte_padding()</code>用于对字节序列进行填充<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">aes_byte_padding</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_len, <span class="keyword">uint8_t</span> c, <span class="keyword">int</span> align, <span class="keyword">int</span> *rlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">uint8_t</span> *p;</span><br><span class="line">	<span class="keyword">uint8_t</span> *new_buf;</span><br><span class="line">	<span class="keyword">size_t</span> align_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((!buf) || (align &lt;= <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (buf_len==align)</span><br><span class="line">		align_len = align;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		align_len = ((buf_len/align)+<span class="number">1</span>)*align;</span><br><span class="line">	new_buf = mem_alloc(align_len);</span><br><span class="line">	p = new_buf;</span><br><span class="line">	<span class="built_in">memcpy</span>(p, buf, buf_len);</span><br><span class="line">	p += buf_len;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;align_len-buf_len; i++) &#123;</span><br><span class="line">		buf_push_byte(c, p);</span><br><span class="line">	&#125;</span><br><span class="line">	*rlen = align_len;</span><br><span class="line">	<span class="keyword">return</span> new_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数<code>aes_cbc_enc_string()</code>是字符串加密函数，参数：</p>
<ul>
<li>key，密钥</li>
<li>inv，初始向量</li>
<li>key_len，固定密钥长度，用于填充密钥和明文</li>
<li>str，字符串形式的明文</li>
<li>out，返回的密文</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">aes_cbc_enc_string</span><span class="params">(<span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> *inv, <span class="keyword">int</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">								   <span class="keyword">uint8_t</span> *str, <span class="keyword">uint8_t</span> **out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">int</span> safe_key_len;</span><br><span class="line">	<span class="keyword">int</span> safe_inv_len;</span><br><span class="line">	<span class="keyword">int</span> safe_str_len;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_key;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_inv;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_str;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_enc;</span><br><span class="line">	mbedtls_aes_context ctx;   <span class="comment">//加密结构</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!key || !inv || !str || key_len&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="keyword">if</span> (len &gt; key_len)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">	len = <span class="built_in">strlen</span>(inv);</span><br><span class="line">	<span class="keyword">if</span> (len &gt; key_len)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_enc_string in&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密钥可能不满足字节对齐，填充key</span></span><br><span class="line">	safe_key = aes_string_padding(key, <span class="string">&#x27; &#x27;</span>, key_len, &amp;safe_key_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_key)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始向量可能不满足字节对齐，填充key</span></span><br><span class="line">	safe_inv = aes_string_padding(inv, <span class="string">&#x27; &#x27;</span>, key_len, &amp;safe_inv_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_inv)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明文可能不满足字节对齐，填充key</span></span><br><span class="line">	safe_str = aes_string_padding(str, <span class="string">&#x27; &#x27;</span>, key_len, &amp;safe_str_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_str)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_init(&amp;ctx);</span><br><span class="line">	safe_enc = mem_alloc_z(safe_str_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;key:%s, len:%d\n&quot;</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">	buf_dump(key, <span class="built_in">strlen</span>(key));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;safe_key:%s, len:%d\n&quot;</span>, safe_key, <span class="built_in">strlen</span>(safe_key));</span><br><span class="line">	buf_dump(safe_key, safe_key_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;inv:%s, len:%d\n&quot;</span>, inv, <span class="built_in">strlen</span>(inv));</span><br><span class="line">	buf_dump(inv, <span class="built_in">strlen</span>(inv));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;safe_inv:%s, len:%d\n&quot;</span>, safe_inv, <span class="built_in">strlen</span>(safe_inv));</span><br><span class="line">	buf_dump(safe_inv, safe_inv_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;plain:%s, len:%d\n&quot;</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">	buf_dump(str, <span class="built_in">strlen</span>(str));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;safe plain:%s, len:%d\n&quot;</span>, safe_str, <span class="built_in">strlen</span>(safe_str));</span><br><span class="line">	buf_dump(safe_str, safe_str_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_setkey_enc(&amp;ctx, safe_key, <span class="number">128</span>);   <span class="comment">// 设置密钥</span></span><br><span class="line">	mbedtls_aes_crypt_cbc(&amp;ctx, MBEDTLS_AES_ENCRYPT, safe_str_len, <span class="comment">// 加密函数</span></span><br><span class="line">		safe_inv, safe_str, safe_enc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印密文内容</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cipher:%s, len:%d\n&quot;</span>, safe_enc, <span class="built_in">strlen</span>(safe_enc));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%2x, cipher len %d\n&quot;</span>, safe_enc[<span class="number">15</span>], safe_str_len);</span><br><span class="line">	buf_dump(safe_enc, safe_str_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	<span class="keyword">if</span> (safe_str) mem_free(safe_str);</span><br><span class="line"></span><br><span class="line">	*out = safe_enc;</span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_enc_string ok&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> et_ok;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	<span class="keyword">if</span> (safe_str) mem_free(safe_str);</span><br><span class="line">	<span class="keyword">if</span> (safe_enc) mem_free(safe_enc);</span><br><span class="line">	<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>aes_cbc_dec_string()</code>用于字符串解密，参数</p>
<ul>
<li>key，密钥</li>
<li>inv，初始向量</li>
<li>key_len，规定的密钥长度</li>
<li>str，密文</li>
<li>out，解密后的明文<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">aes_cbc_dec_string</span><span class="params">(<span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> *inv, <span class="keyword">int</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">								   <span class="keyword">uint8_t</span> *str, <span class="keyword">uint8_t</span> **out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">int</span> safe_key_len;</span><br><span class="line">	<span class="keyword">int</span> safe_inv_len;</span><br><span class="line">	<span class="keyword">int</span> safe_str_len;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_key;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_inv;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_dec;</span><br><span class="line">	mbedtls_aes_context ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!key || !inv || !str || key_len&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="keyword">if</span> (len &gt; key_len)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">	len = <span class="built_in">strlen</span>(inv);</span><br><span class="line">	<span class="keyword">if</span> (len &gt; key_len)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_dec_string in&quot;</span>);</span><br><span class="line"></span><br><span class="line">	safe_key = aes_string_padding(key, <span class="string">&#x27; &#x27;</span>, key_len, &amp;safe_key_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_key)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	safe_inv = aes_string_padding(inv, <span class="string">&#x27; &#x27;</span>, key_len, &amp;safe_inv_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_inv)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_init(&amp;ctx);</span><br><span class="line">	safe_dec = mem_alloc_z(<span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cipher:%s, len:%d\n&quot;</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">	buf_dump(str, <span class="built_in">strlen</span>(str));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_setkey_enc(&amp;ctx, safe_key, <span class="number">128</span>);</span><br><span class="line">	mbedtls_aes_crypt_cbc(&amp;ctx, MBEDTLS_AES_DECRYPT, <span class="built_in">strlen</span>(str),</span><br><span class="line">		safe_inv, str, safe_dec);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;plain:%s, len:%d\n&quot;</span>, safe_dec, <span class="built_in">strlen</span>(safe_dec));</span><br><span class="line">	buf_dump(safe_dec, <span class="built_in">strlen</span>(safe_dec));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	*out = safe_dec;</span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_dec_string ok&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> et_ok;</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	<span class="keyword">if</span> (safe_dec) mem_free(safe_dec);</span><br><span class="line">	<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数<code>aes_cbc_enc_byte()</code>用于字节序列加密，参数</li>
<li>key，密钥</li>
<li>key_len，密钥长度</li>
<li>inv，初始向量</li>
<li>inv_len，初始向量长度</li>
<li>align，规定字节对齐长度</li>
<li>buf，明文</li>
<li>buf_len，明文长度</li>
<li>out，输出密文</li>
<li>out_len，输出密文长度<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">aes_cbc_enc_byte</span><span class="params">(<span class="keyword">uint8_t</span> *key, <span class="keyword">int</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">							    <span class="keyword">uint8_t</span> *inv, <span class="keyword">int</span> inv_len, <span class="keyword">int</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">							    <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_len, <span class="keyword">uint8_t</span> **out,</span></span></span><br><span class="line"><span class="params"><span class="function">							    <span class="keyword">int</span> *out_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> len;</span><br><span class="line">   	<span class="keyword">int</span> safe_key_len;</span><br><span class="line">   	<span class="keyword">int</span> safe_inv_len;</span><br><span class="line">   	<span class="keyword">int</span> safe_buf_len;</span><br><span class="line">   	<span class="keyword">uint8_t</span> *safe_key;</span><br><span class="line">   	<span class="keyword">uint8_t</span> *safe_inv;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_buf;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_out;</span><br><span class="line">	mbedtls_aes_context ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!key || !inv || !buf || key_len&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key_len &gt; align)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">	<span class="keyword">if</span> (inv_len &gt; align)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_enc_byte in&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_init(&amp;ctx);</span><br><span class="line"></span><br><span class="line">	safe_key = aes_byte_padding(key, key_len, <span class="number">0x0</span>, align, &amp;safe_key_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_key)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	safe_inv = aes_byte_padding(inv, inv_len, <span class="number">0x0</span>, align, &amp;safe_inv_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_inv)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	safe_buf = aes_byte_padding(buf, buf_len, <span class="number">0x0</span>, align, &amp;safe_buf_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_buf)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	safe_out = mem_alloc_z(safe_buf_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;key len %d, byte:\n&quot;</span>, key_len);</span><br><span class="line">	buf_dump(key, key_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;safe key len %d, byte:\n&quot;</span>, safe_key_len);</span><br><span class="line">	buf_dump(safe_key, safe_key_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;inv len %d, byte:\n&quot;</span>, inv_len);</span><br><span class="line">	buf_dump(inv, inv_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;safe inv len %d, byte:\n&quot;</span>, safe_inv_len);</span><br><span class="line">	buf_dump(safe_inv, safe_inv_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;plain len %d, byte:\n&quot;</span>, buf_len);</span><br><span class="line">	buf_dump(buf, buf_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;safe plain len %d, byte:\n&quot;</span>, safe_buf_len);</span><br><span class="line">	buf_dump(safe_buf, safe_buf_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_setkey_enc(&amp;ctx, safe_key, <span class="number">128</span>);</span><br><span class="line">	mbedtls_aes_crypt_cbc(&amp;ctx, MBEDTLS_AES_ENCRYPT, safe_buf_len,</span><br><span class="line">		safe_inv, safe_buf, safe_out);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cipher len %d, byte:\n&quot;</span>, safe_buf_len);</span><br><span class="line">	buf_dump(safe_out, safe_buf_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	<span class="keyword">if</span> (safe_buf) mem_free(safe_buf);</span><br><span class="line">	*out = safe_out;</span><br><span class="line">	*out_len = safe_buf_len;</span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_enc_byte ok&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> et_ok;</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	<span class="keyword">if</span> (safe_buf) mem_free(safe_buf);</span><br><span class="line">	<span class="keyword">return</span> et_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数<code>aes_cbc_dec_byte()</code>用于字节序列解密<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">err_type <span class="title">aes_cbc_dec_byte</span><span class="params">(<span class="keyword">uint8_t</span> *key, <span class="keyword">int</span> key_len,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">uint8_t</span> *inv, <span class="keyword">int</span> inv_len, <span class="keyword">int</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_len, <span class="keyword">uint8_t</span> **out,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">int</span> *out_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> len;</span><br><span class="line">   	<span class="keyword">int</span> safe_key_len;</span><br><span class="line">   	<span class="keyword">int</span> safe_inv_len;</span><br><span class="line">   	<span class="keyword">uint8_t</span> *safe_key;</span><br><span class="line">   	<span class="keyword">uint8_t</span> *safe_inv;</span><br><span class="line">	<span class="keyword">uint8_t</span> *safe_out;</span><br><span class="line">	mbedtls_aes_context ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!key || !inv || !buf || key_len&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key_len &gt; align)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">	<span class="keyword">if</span> (inv_len &gt; align)</span><br><span class="line">		<span class="keyword">return</span> et_aes_enc;</span><br><span class="line"></span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_dec_byte in&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_init(&amp;ctx);</span><br><span class="line"></span><br><span class="line">	safe_key = aes_byte_padding(key, key_len, <span class="number">0x0</span>, align, &amp;safe_key_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_key)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	safe_inv = aes_byte_padding(inv, inv_len, <span class="number">0x0</span>, align, &amp;safe_inv_len);</span><br><span class="line">	<span class="keyword">if</span> (!safe_inv)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	safe_out = mem_alloc_z(buf_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cipher len %d, byte:\n&quot;</span>, buf_len);</span><br><span class="line">	buf_dump(buf, buf_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	mbedtls_aes_setkey_enc(&amp;ctx, safe_key, <span class="number">128</span>);</span><br><span class="line">	mbedtls_aes_crypt_cbc(&amp;ctx, MBEDTLS_AES_DECRYPT, buf_len,</span><br><span class="line">		safe_inv, buf, safe_out);		</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;plain len %d, byte:\n&quot;</span>, buf_len);</span><br><span class="line">	buf_dump(safe_out, buf_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	*out = safe_out;</span><br><span class="line">	*out_len = buf_len;</span><br><span class="line">	log_debug(<span class="string">&quot;aes_cbc_dec_byte ok&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> et_ok;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (safe_key) mem_free(safe_key);</span><br><span class="line">	<span class="keyword">if</span> (safe_inv) mem_free(safe_inv);</span><br><span class="line">	<span class="keyword">if</span> (safe_out) mem_free(safe_out);</span><br><span class="line">	<span class="keyword">return</span> et_aes_enc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以明文”hello world”进行加密解密测试<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> enc_len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *enc, *dec;</span><br><span class="line"></span><br><span class="line">	log_level(LOG_DBG);</span><br><span class="line">	log_mode(LOG_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *str_key = <span class="string">&quot;xadcdgde&quot;</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *str_inv = <span class="string">&quot;1234567890123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    aes_cbc_enc_string(str_key, str_inv, KEY_LEN, str_plain, &amp;enc);</span><br><span class="line">    aes_cbc_dec_string(str_key, str_inv, KEY_LEN, enc, &amp;dec);</span><br><span class="line">    mem_free(enc);</span><br><span class="line">    mem_free(dec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译运行程序，打印如下<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost aes_test]# ./bin/aes_test</span><br><span class="line"> [2019/05/24 00:50:19] [DEBUG] [aes_cbc_enc_string:711 ] aes_cbc_enc_string in</span><br><span class="line"></span><br><span class="line">key:xadcdgde, len:8</span><br><span class="line">78 61 64 63 64 67 64 65</span><br><span class="line"></span><br><span class="line">safe_key:xadcdgde        , len:16                   # 密钥长度被填充到16</span><br><span class="line">78 61 64 63 64 67 64 65 20 20 20 20 20 20 20 20</span><br><span class="line"></span><br><span class="line">inv:1234567890123456, len:16</span><br><span class="line">31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36</span><br><span class="line"></span><br><span class="line">safe_inv:1234567890123456, len:16                   # 初始向量不变</span><br><span class="line">31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36</span><br><span class="line"></span><br><span class="line">plain:hello world, len:11                       </span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line"></span><br><span class="line">safe plain:hello world     , len:16                 # 明文长度被填充到16</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c 64 20 20 20 20 20</span><br><span class="line"></span><br><span class="line">cipher:&#x27;flen:16</span><br><span class="line">0x4a, cipher len 16</span><br><span class="line">de 1d f9 6b 27 82 19 2f 79 88 5f 8b 95 66 be 4a     # 密文字节</span><br><span class="line"></span><br><span class="line"> [2019/05/24 00:50:19] [DEBUG] [aes_cbc_enc_string:763 ] aes_cbc_enc_string ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> [2019/05/24 00:50:19] [DEBUG] [aes_cbc_dec_string:797 ] aes_cbc_dec_string in</span><br><span class="line"></span><br><span class="line">cipher:&#x27;flen:16</span><br><span class="line">de 1d f9 6b 27 82 19 2f 79 88 5f 8b 95 66 be 4a</span><br><span class="line"></span><br><span class="line">plain:hello world     , len:16</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c 64 20 20 20 20 20     # 密文被正确解密</span><br><span class="line"></span><br><span class="line"> [2019/05/24 00:50:19] [DEBUG] [aes_cbc_dec_string:825 ] aes_cbc_dec_string ok</span><br><span class="line">[root@localhost aes_test]#</span><br></pre></td></tr></table></figure>
以明文``进行加密解密测试<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> enc_len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *enc, *dec;</span><br><span class="line"></span><br><span class="line">	log_level(LOG_DBG);</span><br><span class="line">	log_mode(LOG_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> key[KEY_LEN] = &#123;</span><br><span class="line">		<span class="number">0x25</span>,<span class="number">0xdd</span>,<span class="number">0xff</span>,<span class="number">0xee</span>,<span class="number">0x33</span>,<span class="number">0x4c</span>,<span class="number">0xfe</span>,<span class="number">0x30</span>,<span class="number">0x09</span>,<span class="number">0xaa</span>,<span class="number">0x55</span>,<span class="number">0xa5</span>,<span class="number">0x0c</span>,<span class="number">0x97</span>,<span class="number">0x66</span>,<span class="number">0x13</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> inv[KEY_LEN] = &#123;</span><br><span class="line">		<span class="number">0x78</span>,<span class="number">0x97</span>,<span class="number">0xee</span>,<span class="number">0xea</span>,<span class="number">0xa3</span>,<span class="number">0x3c</span>,<span class="number">0xcf</span>,<span class="number">0xf8</span>,<span class="number">0x8f</span>,<span class="number">0xfb</span>,<span class="number">0xb6</span>,<span class="number">0x65</span>,<span class="number">0x5c</span>,<span class="number">0xc3</span>,<span class="number">0xc7</span>,<span class="number">0x76</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> plain[<span class="number">10</span>] = &#123;</span><br><span class="line">		<span class="number">0x03</span>, <span class="number">0x05</span>, <span class="number">0x2d</span>, <span class="number">0x1c</span>, <span class="number">0xaa</span>, <span class="number">0xe3</span>, <span class="number">0xff</span>, <span class="number">0x23</span>, <span class="number">0x17</span>, <span class="number">0x89</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    aes_cbc_enc_byte(key, array_size(key),</span><br><span class="line">				     inv, array_size(inv), KEY_LEN,</span><br><span class="line">				     plain, array_size(plain), &amp;enc, &amp;enc_len);</span><br><span class="line">	aes_cbc_dec_byte(key, array_size(key),</span><br><span class="line">					 inv, array_size(inv), KEY_LEN,</span><br><span class="line">					 enc, enc_len, &amp;dec, &amp;enc_len);</span><br><span class="line">    mem_free(enc);</span><br><span class="line">    mem_free(dec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译运行程序，打印如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[root@localhost aes_test]# ./bin/aes_test</span><br><span class="line"> [<span class="number">2019</span>/<span class="number">05</span>/<span class="number">24</span> <span class="number">00</span>:<span class="number">54</span>:<span class="number">38</span>] [DEBUG] [aes_cbc_enc_byte:<span class="number">857</span> ] aes_cbc_enc_byte in</span><br><span class="line">key len <span class="number">16</span>, byte:</span><br><span class="line"><span class="number">25</span> dd ff ee <span class="number">33</span> <span class="number">4</span>c fe <span class="number">30</span>  <span class="number">9</span> aa <span class="number">55</span> a5  c <span class="number">97</span> <span class="number">66</span> <span class="number">13</span></span><br><span class="line"></span><br><span class="line">safe key len <span class="number">16</span>, byte:</span><br><span class="line"><span class="number">25</span> dd ff ee <span class="number">33</span> <span class="number">4</span>c fe <span class="number">30</span>  <span class="number">9</span> aa <span class="number">55</span> a5  c <span class="number">97</span> <span class="number">66</span> <span class="number">13</span></span><br><span class="line"></span><br><span class="line">inv len <span class="number">16</span>, byte:</span><br><span class="line"><span class="number">78</span> <span class="number">97</span> ee ea a3 <span class="number">3</span>c cf f8 <span class="number">8f</span> fb b6 <span class="number">65</span> <span class="number">5</span>c c3 c7 <span class="number">76</span></span><br><span class="line"></span><br><span class="line">safe inv len <span class="number">16</span>, byte:</span><br><span class="line"><span class="number">78</span> <span class="number">97</span> ee ea a3 <span class="number">3</span>c cf f8 <span class="number">8f</span> fb b6 <span class="number">65</span> <span class="number">5</span>c c3 c7 <span class="number">76</span></span><br><span class="line"></span><br><span class="line">plain len <span class="number">10</span>, byte:                 </span><br><span class="line"> <span class="number">3</span>  <span class="number">5</span> <span class="number">2</span>d <span class="number">1</span>c aa e3 ff <span class="number">23</span> <span class="number">17</span> <span class="number">89</span></span><br><span class="line"></span><br><span class="line">safe plain len <span class="number">16</span>, byte:                            # 明文长度被填充到<span class="number">16</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">5</span> <span class="number">2</span>d <span class="number">1</span>c aa e3 ff <span class="number">23</span> <span class="number">17</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">cipher len <span class="number">16</span>, byte:</span><br><span class="line"> <span class="number">8</span> ce a0 f0 <span class="number">65</span> ec e7 <span class="number">25</span> d8 <span class="number">8b</span> d7 ae  <span class="number">0</span> ac <span class="number">8</span>a <span class="number">73</span></span><br><span class="line"></span><br><span class="line"> [<span class="number">2019</span>/<span class="number">05</span>/<span class="number">24</span> <span class="number">00</span>:<span class="number">54</span>:<span class="number">38</span>] [DEBUG] [aes_cbc_enc_byte:<span class="number">908</span> ] aes_cbc_enc_byte ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> [<span class="number">2019</span>/<span class="number">05</span>/<span class="number">24</span> <span class="number">00</span>:<span class="number">54</span>:<span class="number">38</span>] [DEBUG] [aes_cbc_dec_byte:<span class="number">940</span> ] aes_cbc_dec_byte in</span><br><span class="line">cipher len <span class="number">16</span>, byte:</span><br><span class="line"> <span class="number">8</span> ce a0 f0 <span class="number">65</span> ec e7 <span class="number">25</span> d8 <span class="number">8b</span> d7 ae  <span class="number">0</span> ac <span class="number">8</span>a <span class="number">73</span></span><br><span class="line"></span><br><span class="line">plain len <span class="number">16</span>, byte:                                 # 密文被正确解密</span><br><span class="line"> <span class="number">3</span>  <span class="number">5</span> <span class="number">2</span>d <span class="number">1</span>c aa e3 ff <span class="number">23</span> <span class="number">17</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> [<span class="number">2019</span>/<span class="number">05</span>/<span class="number">24</span> <span class="number">00</span>:<span class="number">54</span>:<span class="number">38</span>] [DEBUG] [aes_cbc_dec_byte:<span class="number">970</span> ] aes_cbc_dec_byte ok</span><br><span class="line">[root@localhost aes_test]#</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awokezhou.aestest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES加密算法util</span></span><br><span class="line"><span class="comment"> * Created by steadyjack on 2018/4/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EncryptAlg =<span class="string">&quot;AES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static final String Cipher_Mode=&quot;AES/ECB/PKCS7Padding&quot;;</span></span><br><span class="line">    <span class="comment">//private static final String Cipher_Mode=&quot;AES/CBC/PKCS5Padding&quot;;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String Cipher_Mode=<span class="string">&quot;AES/CBC/NoPadding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String Encode=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Secret_Key_Size=<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> PaddingChar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String Key_Encode=<span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ivParameter=<span class="string">&quot;1234567890123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytesToHexString</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = src[i] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            String hv = Integer.toHexString(v);</span><br><span class="line">            <span class="keyword">if</span> (hv.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                stringBuilder.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(hv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES/ECB/PKCS7Padding 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> aes加密后 转base64</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">aesPKCS7PaddingEncrypt</span><span class="params">(String content, String key, String ivParameter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());</span></span><br><span class="line"></span><br><span class="line">            Cipher cipher = Cipher.getInstance(Cipher_Mode);</span><br><span class="line">            <span class="keyword">byte</span>[] realKey = getSecretKey(key);</span><br><span class="line">            System.out.printf(<span class="string">&quot;密钥16进制:%s\n&quot;</span>, bytesToHexString(realKey));</span><br><span class="line">            SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(realKey, EncryptAlg);</span><br><span class="line">            IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(ivParameter.getBytes());<span class="comment">//使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);</span><br><span class="line">            <span class="keyword">byte</span>[] data = cipher.doFinal(content.getBytes(Encode));</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;密文:%s, length:%d&quot;</span>,</span><br><span class="line">                    data, data.length));</span><br><span class="line">            System.out.printf(<span class="string">&quot;密文16进制:%s\n&quot;</span>, bytesToHexString(data));</span><br><span class="line">            String result = <span class="keyword">new</span> Base64().encodeToString(data);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;AES加密失败：content=&quot;</span> +content +<span class="string">&quot; key=&quot;</span>+key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES/ECB/PKCS7Padding 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 先转base64 再解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">aesPKCS7PaddingDecrypt</span><span class="params">(String content, String key, String ivParameter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());</span></span><br><span class="line">            <span class="keyword">byte</span>[] decodeBytes = <span class="keyword">new</span> Base64().decodeBase64(content);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(Cipher_Mode);</span><br><span class="line">            <span class="keyword">byte</span>[] realKey = getSecretKey(key);</span><br><span class="line">            SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(realKey, EncryptAlg);</span><br><span class="line">            IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(ivParameter.getBytes());</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);</span><br><span class="line">            <span class="keyword">byte</span>[] realBytes=cipher.doFinal(decodeBytes);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(realBytes, Encode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;AES解密失败：Aescontent = &quot;</span> +e.fillInStackTrace(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对密钥key进行处理：如密钥长度不够位数的则 以指定paddingChar 进行填充；</span></span><br><span class="line"><span class="comment">     *      * 此处用空格字符填充，也可以 0 填充，具体可根据实际项目需求做变更</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getSecretKey(String key) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span> paddingChar=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] realKey = <span class="keyword">new</span> <span class="keyword">byte</span>[Secret_Key_Size];</span><br><span class="line">        <span class="keyword">byte</span>[] byteKey = key.getBytes(Key_Encode);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;realKey.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;byteKey.length)&#123;</span><br><span class="line">                realKey[i] = byteKey[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                realKey[i] = paddingChar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> realKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] keyPadding(String key, <span class="keyword">byte</span> c, <span class="keyword">int</span> size, String encode) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] paddingKey = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">byte</span>[] bytesKey = key.getBytes(encode);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;paddingKey.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;bytesKey.length)&#123;</span><br><span class="line">                paddingKey[i] = bytesKey[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                paddingKey[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> paddingKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">textPadding</span><span class="params">(String text, <span class="keyword">byte</span> c, <span class="keyword">int</span> size, String encode)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = text.length();</span><br><span class="line">        <span class="keyword">byte</span>[] paddingText = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">byte</span>[] bytesText = text.getBytes(encode);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;paddingText.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;bytesText.length)&#123;</span><br><span class="line">                paddingText[i] = bytesText[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                paddingText[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = <span class="keyword">new</span> String(paddingText);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//密钥 加密内容(对象序列化后的内容-json格式字符串)</span></span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;xadcdgde&quot;</span>;</span><br><span class="line">        String encPlainText = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;明文:%s, length:%d&quot;</span>,</span><br><span class="line">                encPlainText, encPlainText.length()));</span><br><span class="line">        encPlainText = textPadding(encPlainText, PaddingChar, Secret_Key_Size, Encode);</span><br><span class="line">        System.out.printf(<span class="string">&quot;明文16进制:%s\n&quot;</span>, bytesToHexString(encPlainText.getBytes()));</span><br><span class="line">        String cipherText = aesPKCS7PaddingEncrypt(encPlainText, key, ivParameter);</span><br><span class="line"></span><br><span class="line">        String decPlainText = aesPKCS7PaddingDecrypt(cipherText, key, ivParameter);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;解密:%s, length:%d&quot;</span>,</span><br><span class="line">                decPlainText, decPlainText.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，打印为<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">明文:hello world, length:<span class="number">11</span></span><br><span class="line">明文<span class="number">16</span>进制:<span class="number">68656</span>c6c6f20776f726c642020202020</span><br><span class="line">密钥<span class="number">16</span>进制:<span class="number">78616463646764652020202020202020</span></span><br><span class="line">密文:[B@<span class="number">2</span>b2948e2, length:<span class="number">16</span></span><br><span class="line">密文<span class="number">16</span>进制:de1df96b2782192f79885f8b9566be4a</span><br><span class="line">解密:hello world     , length:<span class="number">16</span></span><br></pre></td></tr></table></figure><br>java密文与C语言密文16进制内容一致</p>
]]></content>
      <categories>
        <category>协议</category>
        <category>安全</category>
        <category>加密算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>TFLite Micro - Hello World</title>
    <url>/2020/05/09/TFLite-Micro-Hello-World/</url>
    <content><![CDATA[<p>本文基于定制化的TFLite Micro动态链接库，通过”hello world”示例来验证TFLite Micro版本的功能。虽然名字叫是”hello world”，其实并不是在控制台上打印出”hello world”这么简单，而是用Python版本的Tensorflow构建训练一个能够学习并生成正弦波的模型，通过TFLite的转换器转换为.tflite文件，并使用TFLite Micro动态链接库加载并执行推断的过程</p>
<p>开发环境</p>
<ul>
<li><p>Inter i5-7200U</p>
</li>
<li><p>Ubuntu18.04.2 x86_64</p>
</li>
<li><p>conda Python3.7虚拟环境</p>
</li>
<li><p>Tensorflow2.1.0</p>
</li>
</ul>
<p>参考</p>
<ul>
<li><p><a href="http://tensorflow.google.cn/">http://tensorflow.google.cn/</a></p>
</li>
<li><p>tensorflow/tensorflow/lite/micro/examples/hello_world/create_sine_model.ipynb</p>
</li>
</ul>
<h2 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h2><p>首先需要加载一些python库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure>
<p>以下代码生成一组随机数，并计算它们的正弦值，并绘图显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SAMPLES = <span class="number">1000</span></span><br><span class="line">np.random.seed(<span class="number">1337</span>)</span><br><span class="line">x_values = np.random.uniform(low=<span class="number">0</span>, high=<span class="number">2</span>*math.pi, size=SAMPLES)</span><br><span class="line">np.random.shuffle(x_values)</span><br><span class="line">y_values = np.sin(x_values)</span><br><span class="line">plt.plot(x_values, y_values, <span class="string">&#x27;b.&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/01.png" alt></p>
<h2 id="添加噪声"><a href="#添加噪声" class="headerlink" title="添加噪声"></a>添加噪声</h2><p>由于数据是由正弦函数直接生成，数据太过平滑。然而现实中获取的各种信号必然夹杂着噪声数据，而机器学习算法能够从带有噪声的数据中学习到真正的信息</p>
<p>为数据添加一些噪声，并绘制显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_values += <span class="number">0.1</span> * np.random.randn(*y_values.shape)</span><br><span class="line">plt.plot(x_values, y_values, <span class="string">&#x27;b.&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/02.png" alt></p>
<h2 id="拆分数据"><a href="#拆分数据" class="headerlink" title="拆分数据"></a>拆分数据</h2><p>我们已经生成了一个近似真实世界的噪声数据，我们用它来训练模型</p>
<p>为了验证评估模型，以及防止数据的过拟合，我们将数据拆分为训练集、测试集和验证集3部分，比例为3:1:1</p>
<p>以下代码将数据分割，并以不同的颜色显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TRAIN_SPLIT =  <span class="built_in">int</span>(<span class="number">0.6</span> * SAMPLES)</span><br><span class="line">TEST_SPLIT = <span class="built_in">int</span>(<span class="number">0.2</span> * SAMPLES + TRAIN_SPLIT)</span><br><span class="line">x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])</span><br><span class="line">y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])</span><br><span class="line">plt.plot(x_train, y_train, <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&quot;Train&quot;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;r.&#x27;</span>, label=<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">plt.plot(x_validate, y_validate, <span class="string">&#x27;y.&#x27;</span>, label=<span class="string">&quot;Validate&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/03.png" alt></p>
<h2 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h2><p>我们将建立一个模型，它接收一个输入，并用它来预测一个输出，此类问题称为回归问题。为了达到这个目的，我们将创建一个简单的神经网络，它将使用多层的神经元来学习数据背后的模式，以便进行预测</p>
<p>首先，我们定义两个层。第一层接收一个输入，并经过16个神经元。输入到来时，每个神经元将根据自身的权重和偏置状态受到不同程度的激活，神经元的激活程度由数字表示。第一层的激活将作为第二层的输入，第二层的输出作为模型的输出值</p>
<p>我们使用Keras来定义模型，模型使用”relu”作为激活函数，优化器使用”rmsprop”，损失函数使用”mse”，使用MAE来评估</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line">model_1 = tf.keras.Sequential()</span><br><span class="line">model_1.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">1</span>,)))</span><br><span class="line">model_1.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line">model_1.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>, metrics=[<span class="string">&#x27;mae&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>一旦我们定义好了模型，可以使用数据来训练它。训练过程将x输入到网络中，检查网络输出与原始数据的偏离程度，并调整神经元的偏置和权重。训练过程是在整个数据上多次运行，每次完整的运行都称为”epoch”。在每个”epoch”中，数据以多批次的方式在网络中运行，每一批次都有几个数据进入网络并输出，对网络参数的调整是以一个批次为单位的。”epoch”次数和批次大小都可以通过参数调整</p>
<p>以下代码运行1000个”epoch”，每个批次16个数据，还传递一些数据用于验证。整个训练需要一定的时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">history_1 = model_1.fit(x_train, y_train, epochs=<span class="number">1000</span>, batch_size=<span class="number">16</span>,</span><br><span class="line">                    validation_data=(x_validate, y_validate))</span><br></pre></td></tr></table></figure>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>在训练期间，模型的性能在数据迭代中不断的提升，训练会生成一个日志，告诉我们性能在训练过程中是如何变化的。以下代码将以图形形式显示其中一些信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = history_1.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history_1.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/04.png" alt></p>
<p>图形中显示了每个epoch的损失函数情况。有多种方式的损失函数，这里我们使用的是均方误差MSE。损失函数在前25个epoch迅速减少，之后趋于平缓，这意味着模型在不断改进。我们的目标是当模型不再改进，或者当训练损失小于验证损失时，意味着学习已经收敛，需要停止训练。为了更清楚的观察平坦部分，我们跳过前50个epoch的训练情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SKIP = <span class="number">50</span></span><br><span class="line">plt.plot(epochs[SKIP:], loss[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_loss[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/05.png" alt></p>
<p>从上图中可以看出，损失在前600个epoch持续减少，到600之后不再变化，这意味着600之后的训练是没有必要的。同时，我们也可以看到，最低的损失函数值仍然在0.155左右，这意味着我们的网络预测平均偏离了15%。另外，验证损失值跳变很多。为了了解更多模型的性能，我们可以绘制更多数据，这次我们输出MAE平均绝对误差，这是测量网络预测与实际之间差距距离的另一种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.clf()</span><br><span class="line">mae = history_1.history[<span class="string">&#x27;mae&#x27;</span>]</span><br><span class="line">val_mae = history_1.history[<span class="string">&#x27;val_mae&#x27;</span>]</span><br><span class="line">plt.plot(epochs[SKIP:], mae[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training MAE&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_mae[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation MAE&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation mean absolute error&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;MAE&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/06.png" alt></p>
<p>这幅图告诉了我们更多的信息。训练数据的MAE始终低于验证数据的MAE，这意味着网络可能有过拟合，或者学习训练数据太僵硬，以至于无法对新数据做出有效预测。此外，MAE整体都较高，最多为0.305，这表明模型的预测有30%的偏差。为了更清楚的了解到发生了什么，我们可以将网络预测值和实际训练值进行比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions = model_1.predict(x_train)</span><br><span class="line">plt.clf()</span><br><span class="line">plt.title(<span class="string">&#x27;Training data predicted vs actual values&#x27;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">plt.plot(x_train, predictions, <span class="string">&#x27;r.&#x27;</span>, label=<span class="string">&#x27;Predicted&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/07.png" alt></p>
<p>这张图表明网络已经学会以非常有限的方式逼近正弦函数，但是这是一个线性的逼近。这种拟合的刚性表明，该模型没有足够的能力来学习正弦波函数的全部复杂性，因此只能用过于简单的方法来近似它。我们可以修改模型，来改进性能</p>
<h2 id="改变模型"><a href="#改变模型" class="headerlink" title="改变模型"></a>改变模型</h2><p>再增加一层神经元，以下增加一个16个神经元的层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_2 = tf.keras.Sequential()</span><br><span class="line">model_2.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">1</span>,)))</span><br><span class="line">model_2.add(layers.Dense(<span class="number">16</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model_2.add(layers.Dense(<span class="number">1</span>))</span><br><span class="line">model_2.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;mse&#x27;</span>, metrics=[<span class="string">&#x27;mae&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>我们现在将训练新模型。为了节省时间，我们只训练600个epoch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">history_2 = model_2.fit(x_train, y_train, epochs=<span class="number">600</span>, batch_size=<span class="number">16</span>,</span><br><span class="line">                    validation_data=(x_validate, y_validate))</span><br></pre></td></tr></table></figure>
<h2 id="再次评估模型"><a href="#再次评估模型" class="headerlink" title="再次评估模型"></a>再次评估模型</h2><p>可以看到，模型已经有了很大改进，验证损失从0.15降到0.015，验证MAE从0.31降低到0.1</p>
<p>以下代码显示新模型训练的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = history_2.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history_2.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(loss) + <span class="number">1</span>)</span><br><span class="line">plt.plot(epochs, loss, <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs, val_loss, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">SKIP = <span class="number">100</span></span><br><span class="line">plt.clf()</span><br><span class="line">plt.plot(epochs[SKIP:], loss[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_loss[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">mae = history_2.history[<span class="string">&#x27;mae&#x27;</span>]</span><br><span class="line">val_mae = history_2.history[<span class="string">&#x27;val_mae&#x27;</span>]</span><br><span class="line">plt.plot(epochs[SKIP:], mae[SKIP:], <span class="string">&#x27;g.&#x27;</span>, label=<span class="string">&#x27;Training MAE&#x27;</span>)</span><br><span class="line">plt.plot(epochs[SKIP:], val_mae[SKIP:], <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Validation MAE&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and validation mean absolute error&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/08.png" alt></p>
<p><img src="TFLite-Micro-Hello-World/images/09.png" alt></p>
<p><img src="TFLite-Micro-Hello-World/images/10.png" alt></p>
<p>很好的结果，从图中可以看到一些令人兴奋的事情</p>
<ul>
<li><p>我们的网络已经更快地达到了它的最高精度(在200个epoch而不是600个)</p>
</li>
<li><p>总的损失和MAE比之前的网络好得多</p>
</li>
<li><p>验证误差比训练误差更小，这意味着网络并没有过拟合</p>
</li>
</ul>
<p>让我们对照模型的预测值和训练数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = model_2.evaluate(x_test, y_test)</span><br><span class="line">predictions = model_2.predict(x_test)</span><br><span class="line">plt.clf()</span><br><span class="line">plt.title(<span class="string">&#x27;Comparison of predictions and actual values&#x27;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;b.&#x27;</span>, label=<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">plt.plot(x_test, predictions, <span class="string">&#x27;r.&#x27;</span>, label=<span class="string">&#x27;Predicted&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/11.png" alt></p>
<p>由上图看出，预测结果与我们的数据非常吻合。这个模型并不完美，它的预测并没有形成一个平滑的正弦曲线，如果我们想更进一步，我们可以尝试进一步增加模型的容量，也许可以使用一些技术来防止过度拟合。然而，机器学习的一个重要部分是知道什么时候停止，这个模型对于我们示例来说已经足够好了</p>
<h2 id="转换模型到TFLite"><a href="#转换模型到TFLite" class="headerlink" title="转换模型到TFLite"></a>转换模型到TFLite</h2><p>将模型用于TFLite微控制器，需要将其转换为正确的格式，为此我们将使用Tensorflow Lite转换器，转换器可以以一种特殊的、节省空间的格式将模型输出到文件。由于是部署到微控制器上，我们希望它尽可能小，可以通过量化的方法减小尺寸。它降低了模型权重的精度，以节省内存。因为量化模型更小，因此运行起来也更快</p>
<p>转换器可以在转换时选择是否进行量化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">converter = tf.lite.TFLiteConverter.from_keras_model(model_2)</span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;sine_model.tflite&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(tflite_model)</span><br><span class="line">converter = tf.lite.TFLiteConverter.from_keras_model(model_2)</span><br><span class="line">converter.optimizations = [tf.lite.Optimize.OPTIMIZE_FOR_SIZE]</span><br><span class="line">tflite_model = converter.convert()</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;sine_model_quantized.tflite&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(tflite_model)</span><br></pre></td></tr></table></figure>
<p>执行以上代码可以看到，未量化的模型大小为2732KB，量化模型大小为2720KB</p>
<h2 id="测试转换后的模型"><a href="#测试转换后的模型" class="headerlink" title="测试转换后的模型"></a>测试转换后的模型</h2><p>为了证明这些模型在转换和量化之后仍然是准确的，我们将使用这两个模型进行预测，并将其与我们的测试结果进行比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sine_model = tf.lite.Interpreter(<span class="string">&#x27;sine_model.tflite&#x27;</span>)</span><br><span class="line">sine_model_quantized = tf.lite.Interpreter(<span class="string">&#x27;sine_model_quantized.tflite&#x27;</span>)</span><br><span class="line">sine_model.allocate_tensors()</span><br><span class="line">sine_model_quantized.allocate_tensors()</span><br><span class="line">sine_model_input = sine_model.tensor(sine_model.get_input_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_output = sine_model.tensor(sine_model.get_output_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_quantized_input = sine_model_quantized.tensor(sine_model_quantized.get_input_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_quantized_output = sine_model_quantized.tensor(sine_model_quantized.get_output_details()[<span class="number">0</span>][<span class="string">&quot;index&quot;</span>])</span><br><span class="line">sine_model_predictions = np.empty(x_test.size)</span><br><span class="line">sine_model_quantized_predictions = np.empty(x_test.size)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x_test.size):</span><br><span class="line">    sine_model_input().fill(x_test[i])</span><br><span class="line">    sine_model.invoke()</span><br><span class="line">    sine_model_predictions[i] = sine_model_output()[<span class="number">0</span>]</span><br><span class="line">    sine_model_quantized_input().fill(x_test[i])</span><br><span class="line">    sine_model_quantized.invoke()</span><br><span class="line">    sine_model_quantized_predictions[i] = sine_model_quantized_output()[<span class="number">0</span>]</span><br><span class="line">plt.clf()</span><br><span class="line">plt.title(<span class="string">&#x27;Comparison of various models against actual values&#x27;</span>)</span><br><span class="line">plt.plot(x_test, y_test, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;Actual&#x27;</span>)</span><br><span class="line">plt.plot(x_test, predictions, <span class="string">&#x27;ro&#x27;</span>, label=<span class="string">&#x27;Original predictions&#x27;</span>)</span><br><span class="line">plt.plot(x_test, sine_model_predictions, <span class="string">&#x27;bx&#x27;</span>, label=<span class="string">&#x27;Lite predictions&#x27;</span>)</span><br><span class="line">plt.plot(x_test, sine_model_quantized_predictions, <span class="string">&#x27;gx&#x27;</span>, label=<span class="string">&#x27;Lite quantized predictions&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="TFLite-Micro-Hello-World/images/12.png" alt></p>
<p>从图中我们可以看出，对原始模型、转换模型和量化模型的预测都非常接近，无法区分。这意味着我们的量化模型已经可以使用了！</p>
<h2 id="使用C-程序执行推断"><a href="#使用C-程序执行推断" class="headerlink" title="使用C++程序执行推断"></a>使用C++程序执行推断</h2><p>这里使用C++程序需要依赖TFLite Micro动态链接库，参见<a href></a></p>
<p>通过xxd命令将模型文件转换为C++源文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxd -i sine_model_quantized.tflite &gt; sine_model_quantized.cc</span><br></pre></td></tr></table></figure>
<p>可以看到生成的C++文件中，模型是以字节序列存放的，并通过sine_model_quantized.h文件向外暴露模型地址和长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sine_model_quantized_tflite[] = &#123;</span><br><span class="line">  <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, <span class="number">0x4c</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0e</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x0c</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x00</span>,</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sine_model_quantized_tflite_len = <span class="number">2640</span>;</span><br></pre></td></tr></table></figure>
<p>我们创建一个main.cc源文件，用来加载模型并循环执行推断，将模型输出导出到csv文件中，最后用python绘图呈现模型的预测效果</p>
<h3 id="引用一些头文件"><a href="#引用一些头文件" class="headerlink" title="引用一些头文件"></a>引用一些头文件</h3><p>TFLite Micro程序需要引用一些必要的头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/kernels/all_ops_resolver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/micro_error_reporter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/micro_interpreter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorflow/lite/micro/debug_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tensorlfow/lite/version.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sine_model_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<p>all_ops_resolver.h文件中定义了一些优化器相关的运算组建，例如全连接(Full Connected, FC)、柔性最大化函数Softmax、卷积conv</p>
<p>micro_error_reporter.h文件中定义了调试方法</p>
<p>micro_interpreter.h文件中是解释器的定义</p>
<p>sin_model_data.h引用模型文件</p>
<h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><p>首先创建一个调试器reporter</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tflite::MicroErrorReporter micro_error_reporter;</span><br><span class="line">tflite::ErrorReporter* error_reporter = &amp; micro_error_reporter;</span><br></pre></td></tr></table></figure>
<p>调用GetModel()方法加载模型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tflite::Model* model = ::tflite::<span class="built_in">GetModel</span>(g_sine_model_data);</span><br><span class="line"><span class="keyword">if</span> (model-&gt;<span class="built_in">version</span>() != TFLITE_SCHEMA_VERSION) &#123;</span><br><span class="line">    error_reporter-&gt;<span class="built_in">Report</span>(</span><br><span class="line">        <span class="string">&quot;Model provided is schema version %d not equal &quot;</span></span><br><span class="line">        <span class="string">&quot;to supported version %d.\n&quot;</span>,</span><br><span class="line">        model-&gt;<span class="built_in">version</span>(), TFLITE_SCHEMA_VERSION);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个运算器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tflite::ops::micro::AllOpsResolver resolver;</span><br></pre></td></tr></table></figure>
<p>创建解释器，并为模型推断分配内存空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tensor_arena_size = <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> tensor_arena[tensor_arena_size];</span><br><span class="line"><span class="function">tflite::MicroInterpreter <span class="title">interpreter</span><span class="params">(model, resolver,tensor_arena,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     tensor_arena_size, error_reporter)</span></span>;</span><br><span class="line"></span><br><span class="line">    TfLiteStatus alloc_status = interpreter.<span class="built_in">AllocateTensors</span>();</span><br><span class="line"><span class="keyword">if</span> (alloc_status != kTfLiteOk) &#123;</span><br><span class="line">    error_reporter-&gt;<span class="built_in">Report</span>(<span class="string">&quot;Alloc tensors Error:%d&quot;</span>, alloc_status);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建指针指向模型输入和输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tflite::MicroInterpreter *inter = &amp;interpreter;</span><br><span class="line">TfLiteTensor* input = interpreter.<span class="built_in">input</span>(<span class="number">0</span>);</span><br><span class="line">TfLiteTensor* output = interpreter.<span class="built_in">output</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>创建csv文件”data.csv”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, ios::out);</span><br></pre></td></tr></table></figure>
<p>以下循环，产生1000个输入，执行模型推断，并将输入和输出保存到csv文件，并打印到屏幕</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> kInferencesPerCycle = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> kXrange = <span class="number">2.f</span> * <span class="number">3.14159265359f</span>;</span><br><span class="line"><span class="keyword">int</span> inference_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> position = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(inference_count) /</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(kInferencesPerCycle);</span><br><span class="line">    <span class="keyword">float</span> x_val = position * kXrange;</span><br><span class="line">    <span class="comment">//error_reporter-&gt;Report(&quot;x_val:%f&quot;, x_val);</span></span><br><span class="line">    input-&gt;data.f[<span class="number">0</span>] = x_val;</span><br><span class="line">    TfLiteStatus invoke_status = inter-&gt;<span class="built_in">Invoke</span>();</span><br><span class="line">    <span class="keyword">if</span> (invoke_status != kTfLiteOk) &#123;</span><br><span class="line">        error_reporter-&gt;<span class="built_in">Report</span>(<span class="string">&quot;Invoke Error:%d&quot;</span>, invoke_status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> y_val = output-&gt;data.f[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%f, y:%f\r\n&quot;</span>,x_val, y_val);</span><br><span class="line">    outFile&lt;&lt;x_val&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;y_val&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    inference_count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (inference_count &gt;= kInferencesPerCycle) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>编译程序并运行，数据保存到了”data.csv”文件中，查看其内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat data.csv | head -n 20</span><br><span class="line">0,0.0486171</span><br><span class="line">0.00628319,0.0537117</span><br><span class="line">0.0125664,0.0588063</span><br><span class="line">0.0188496,0.0639008</span><br><span class="line">0.0251327,0.0689952</span><br><span class="line">0.0314159,0.0740901</span><br><span class="line">0.0376991,0.0791845</span><br><span class="line">0.0439823,0.0842792</span><br><span class="line">0.0502655,0.0893737</span><br><span class="line">0.0565487,0.0944682</span><br><span class="line">0.0628319,0.0995628</span><br><span class="line">0.069115,0.104657</span><br><span class="line">0.0753982,0.109752</span><br><span class="line">0.0816814,0.114847</span><br><span class="line">0.0879646,0.119941</span><br><span class="line">0.0942478,0.125036</span><br><span class="line">0.100531,0.13013</span><br><span class="line">0.106814,0.135225</span><br><span class="line">0.113097,0.14032</span><br><span class="line">0.119381,0.145414</span><br></pre></td></tr></table></figure>
<p>编写python脚本draw.py读取data.csv文件并将数值绘制出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">X = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> myFile:</span><br><span class="line">    lines=csv.reader(myFile)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        x = <span class="built_in">float</span>(line[<span class="number">0</span>])</span><br><span class="line">        y = <span class="built_in">float</span>(line[<span class="number">1</span>])</span><br><span class="line">        X.append(x)</span><br><span class="line">        Y.append(y)</span><br><span class="line"></span><br><span class="line">plt.plot(X, Y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python draw.py</span><br></pre></td></tr></table></figure>
<p>结果如图</p>
<p><img src="TFLite-Micro-Hello-World/images/13.png" alt></p>
<p>可见模型输出的结果准确</p>
]]></content>
      <categories>
        <category>ML</category>
        <category>框架</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>pm-debugging</title>
    <url>/2019/12/05/pm-debugging/</url>
    <content><![CDATA[<p>电源管理的调试对于开发需要Suspend to Disk(STD)或者Suspend to Ram(STR)的系统来说，非常必要和重要</p>
<p>由于系统在suspend/resume过程会进行非常复杂的一系列操作，如禁用console、冻结进程等，会导致常规的调试方法难以排查定位问题和跟踪流程</p>
<p>Linux的电源管理框架提供了专门的调试方法，用于方便开发者调试不同类型、不同深度的suspend/resume，本文介绍一些常用的工具和使用方法，并在实际环境中验证</p>
<p><strong>参考文档</strong></p>
<ul>
<li>kernel document : /Document/power/basic-pm-debugging.txt</li>
<li>kernel document : /Document/power/drivers-testing.txt</li>
<li>kernel document : /Document/power/s2ram.txt</li>
<li><a href="https://wiki.ubuntu.com/DebuggingKernelSuspend">ubuntu wiki - DebuggingKernelSuspend</a></li>
<li><a href="https://unix.stackexchange.com/questions/28097/how-to-debug-a-suspend-problem">stackexchange - How to debug a suspend problem?</a></li>
<li><a href="https://01.org/zh/blogs/rzhang/2015/best-practice-debug-linux-suspend/hibernate-issues?langredirect=1">inter open source blog - BEST PRACTICE TO DEBUG LINUX* SUSPEND/HIBERNATE ISSUES</a></li>
</ul>
<p><strong>测试环境</strong><br>本测试在ubuntu上使用qemu创建arm虚拟机环境，linux源码版本4.0，编写内核模块qksleep_test用于调试，关于qemu调试arm kernel参见文章<a href="sadadasd">Qemu+gdb调试内核</a></p>
<ul>
<li>宿主机 : 18.04.1-Ubuntu x86_64</li>
<li>虚拟机 : qemu-system-arm vexpress-a9<ul>
<li>kernel : linux_4.0</li>
</ul>
</li>
</ul>
<h2 id="qksleep-test"><a href="#qksleep-test" class="headerlink" title="qksleep_test"></a>qksleep_test</h2><p>源码下载</p>
<ul>
<li><a href="/download/pm-debugging/pm-debugging.rar">pm-debugging.rar</a><br>qksleep_test以platform_driver方式向系统注册驱动，在其<code>pm</code>操作域上挂接私有的suspend/resume函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qksleep_suspend</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">qksleep_dev_t</span> *qkdev = get_qkdev();</span><br><span class="line">	qksleep_dev_priv *priv = &amp;qkdev-&gt;priv_data;</span><br><span class="line">	</span><br><span class="line">	qksleep_debug(<span class="string">&quot;qksleep suspend in&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;suspend_wakeup_timeout &gt; <span class="number">0</span>)</span><br><span class="line">		schedule_delayed_work(&amp;priv-&gt;suspend_wakeup, msecs_to_jiffies(priv-&gt;suspend_wakeup_timeout));</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;suspend_errlock)</span><br><span class="line">		qksleep_lockerr(priv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;suspend_timeout)</span><br><span class="line">		qksleep_vsleep(priv, priv-&gt;suspend_timeout);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> priv-&gt;suspend_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qksleep_resume</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">qksleep_dev_t</span> *qkdev = get_qkdev();</span><br><span class="line">	qksleep_dev_priv *priv = &amp;qkdev-&gt;priv_data;</span><br><span class="line">	</span><br><span class="line">	qksleep_debug(<span class="string">&quot;qksleep resume in&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;resume_errlock)</span><br><span class="line">		qksleep_lockerr(priv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;resume_timeout)</span><br><span class="line">		qksleep_vsleep(priv, priv-&gt;resume_timeout);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> priv-&gt;resume_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> <span class="title">qk_sleep_pm</span> =</span> &#123;</span><br><span class="line">	.suspend = qksleep_suspend,</span><br><span class="line">	.resume = qksleep_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">qksleep_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = QK_SLEEP_DRV_NAME,</span><br><span class="line">		.pm = &amp;qk_sleep_pm,</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = qksleep_probe,</span><br><span class="line">	.remove = qksleep_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在platform_driver的probe函数中，向系统注册了7个sysfs节点<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">qksleep_attr</span>[] =</span> &#123;</span><br><span class="line">	&amp;dev_attr_suspend_wakeup_timeout.attr,</span><br><span class="line">	&amp;dev_attr_suspend_ret.attr,	</span><br><span class="line">	&amp;dev_attr_suspend_timeout.attr,</span><br><span class="line">	&amp;dev_attr_suspend_errlock.attr,</span><br><span class="line">	&amp;dev_attr_resume_ret.attr,	</span><br><span class="line">	&amp;dev_attr_resume_timeout.attr,	</span><br><span class="line">	&amp;dev_attr_resume_errlock.attr,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>suspend_wakeup_timeout：suspend后多久唤醒系统</li>
<li>suspend_ret：suspend函数返回值</li>
<li>suspend_timeout：suspend函数中模拟一个超时时间</li>
<li>suspend_errlock：suspend函数中模拟一个错误的锁操作</li>
<li>resume_xxx：同上</li>
</ul>
<p>编译kernel，并用quem启动后，在/sys/devices/platform/qksleep路径下生成了该设备的所有sysfs节点<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # cd /sys/devices/platform/qksleep/</span><br><span class="line">/sys/devices/platform/qksleep # ls</span><br><span class="line">driver                  resume_ret              suspend_timeout</span><br><span class="line">driver_override         resume_timeout          suspend_wakeup_timeout</span><br><span class="line">modalias                subsystem               uevent</span><br><span class="line">power                   suspend_errlock</span><br><span class="line">resume_errlock          suspend_ret</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p>
<p>查看suspend/resume操作默认值<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # cat  suspend_*</span><br><span class="line">suspend errlock:0</span><br><span class="line">suspend ret:0</span><br><span class="line">suspend timeout:0(ms)</span><br><span class="line">suspend wakeup timeout:10000(ms)</span><br><span class="line">/sys/devices/platform/qksleep # </span><br><span class="line">/sys/devices/platform/qksleep # cat resume_*</span><br><span class="line">resume errlock:0</span><br><span class="line">resume ret:0</span><br><span class="line">resume timeout:0(ms)</span><br><span class="line">/sys/devices/platform/qksleep #</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令可控制qksleep设备suspend 2秒后唤醒<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 20000 &gt; suspend_wakeup_timeout</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令可控制qksleep设备suspend函数返回错误值-1<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -1 &gt; suspend_ret</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令可控制qksleep设备在suspend函数中模拟一个死锁<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; suspend_errlock</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令可控制qksleep设备在suspend函数中模拟一个2秒的超时<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 2000 &gt; suspend_timeout</span><br></pre></td></tr></table></figure></p>
<p>resume同suspend</p>
<p>操作/sys/power/state节点，手动进入休眠状态，qksleep默认会在10秒后唤醒系统<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[  615.345438] PM: Syncing filesystems ... done.</span><br><span class="line">[  615.346378] PM: Preparing system for mem sleep</span><br><span class="line">[  615.374765] Freezing user space processes ... (elapsed 0.011 seconds) done.</span><br><span class="line">[  615.387040] Freezing remaining freezable tasks ... (elapsed 0.008 seconds) done.</span><br><span class="line">[  615.396303] PM: Entering mem sleep</span><br><span class="line">[  615.396496] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[  615.401243] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[  615.401248] PM: suspend of devices complete after 3.752 msecs</span><br><span class="line">[  615.401269] PM: suspend devices took 0.000 seconds</span><br><span class="line">[  615.402693] PM: late suspend of devices complete after 1.392 msecs</span><br><span class="line">[  615.404024] PM: noirq suspend of devices complete after 1.300 msecs</span><br><span class="line">[  615.404050] PM: suspend-to-idle</span><br><span class="line">[  625.426911] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[  625.426961] PM: resume from suspend-to-idle</span><br><span class="line">[  625.430512] PM: noirq resume of devices complete after 3.254 msecs</span><br><span class="line">[  625.432153] PM: early resume of devices complete after 1.157 msecs</span><br><span class="line">[  625.435256] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[  625.435260] PM: resume of devices complete after 3.047 msecs</span><br><span class="line">[  625.436082] PM: resume devices took 0.010 seconds</span><br><span class="line">[  625.439150] PM: Finishing wakeup.</span><br><span class="line">[  625.439304] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p>
<p>后续的调试验证将在qksleep设备节点的基础上来做</p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>kernel的电源管理框架在“/sys/power”目录下创建了一系列供用户空间操作的sysfs节点，kernel文档“/Document/power/basic-pm-debugging.txt”中详细说明了如何将<code>pm_test</code>节点用于调试suspend/resume过程。“/Document/power/s2ram.txt”文档介绍了使用“s2ram”工具来调试和排查suspend/resume问题。stackexchange问题“How to debug a suspend problem?”的回答中介绍了“pm_utils”工具。英特尔开源社区的文章“BEST PRACTICE TO DEBUG LINUX* SUSPEND/HIBERNATE ISSUES”中系统的介绍了系统级的调试方法和遇到问题的排查步骤</p>
<p>总的来说，Linux电源管理的调试工具主要分为3大类：系统级调试工具(system debug tools)、PM专用调试方法(pm debug tools)和应用层开发的工具(application tools)</p>
<ul>
<li>system debug tools<br>主要是一些kernel启动参数的控制，用于增加更多打印信息<ul>
<li>initcall_debug</li>
<li>no_console_suspend</li>
<li>ignore_loglevel</li>
</ul>
</li>
<li>pm debug tools<br>PM创建的sysfs节点<ul>
<li>pm_test</li>
<li>pm_trace</li>
<li>pm_async</li>
</ul>
</li>
<li>applaction tools<br>结合PM sysfs编写的PM调试app<ul>
<li>pm_utils</li>
<li>s2ram</li>
<li>analyze_suspend.py</li>
</ul>
</li>
</ul>
<h3 id="initcall-debug"><a href="#initcall-debug" class="headerlink" title="initcall_debug"></a>initcall_debug</h3><p>通过将<code>initcall_debug</code>作为启动参数传入kernel，可以跟踪kernel的initcalls和驱动在boot、suspend和resume时的调用情况。通过这种方式可以追踪由于特定组件或驱动引起的suspend/resume问题</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在qksleep的resume过程设置2秒的超时<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 2000 &gt; resume_timeout </span><br></pre></td></tr></table></figure></p>
<p>手动进入休眠，系统唤醒后可看到suspend过程耗时0.010秒，resume操作耗时2.020秒<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[   46.630363] PM: Syncing filesystems ... done.</span><br><span class="line">[   46.632115] PM: Preparing system for mem sleep</span><br><span class="line">[   46.695899] Freezing user space processes ... (elapsed 0.035 seconds) done.</span><br><span class="line">[   46.732478] Freezing remaining freezable tasks ... (elapsed 0.017 seconds) done.</span><br><span class="line">[   46.751186] PM: Entering mem sleep</span><br><span class="line">[   46.751560] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[   46.764225] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[   46.764237] PM: suspend of devices complete after 10.832 msecs</span><br><span class="line">[   46.764522] PM: suspend devices took 0.010 seconds</span><br><span class="line">[   46.766748] PM: late suspend of devices complete after 1.970 msecs</span><br><span class="line">[   46.769322] PM: noirq suspend of devices complete after 2.371 msecs</span><br><span class="line">[   46.769689] PM: suspend-to-idle</span><br><span class="line">[   56.771522] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[   56.771526] PM: resume from suspend-to-idle</span><br><span class="line">[   56.773263] PM: noirq resume of devices complete after 1.499 msecs</span><br><span class="line">[   56.775273] PM: early resume of devices complete after 1.512 msecs</span><br><span class="line">[   58.788915] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[   58.788927] PM: resume of devices complete after 2013.258 msecs</span><br><span class="line">[   58.792183] PM: resume devices took 2.020 seconds</span><br><span class="line">[   58.798512] PM: Finishing wakeup.</span><br><span class="line">[   58.799016] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p>
<p>虽然能看出来系统resume过程耗时明显过长，但是无法知道是在哪里耗时过长，尝试用<code>initcall_debug</code>来查看。系统启动时传入参数<code>initcall_debug</code>，开启该参数后，启动虚拟机，会打印所有initcall信息<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Console: colour dummy device 80x30</span><br><span class="line">[    0.017370] kmemleak: Kernel memory leak detector disabled</span><br><span class="line">[    0.024047] Calibrating delay loop... 915.86 BogoMIPS (lpj=4579328)</span><br><span class="line">[    0.097768] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.101635] Mount-cache hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class="line">[    0.101702] Mountpoint-cache hash table entries: 2048 (order: 1, 8192 bytes)</span><br><span class="line">[    0.133941] CPU: Testing write buffer coherency: ok</span><br><span class="line">[    0.152375] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000</span><br><span class="line">[    0.153210] calling  trace_init_flags_sys_enter+0x0/0x28 @ 1</span><br><span class="line">[    0.153285] initcall trace_init_flags_sys_enter+0x0/0x28 returned 0 after 0 usecs</span><br><span class="line">[    0.153483] calling  trace_init_flags_sys_exit+0x0/0x28 @ 1</span><br><span class="line">[    0.153525] initcall trace_init_flags_sys_exit+0x0/0x28 returned 0 after 0 usecs</span><br><span class="line">[    0.153643] calling  cpu_suspend_alloc_sp+0x0/0x1ec @ 1</span><br><span class="line">[    0.153865] initcall cpu_suspend_alloc_sp+0x0/0x1ec returned 0 after 0 usecs</span><br><span class="line">[    0.153980] calling  init_static_idmap+0x0/0x74 @ 1</span><br><span class="line">[    0.154138] Setting up static identity map for 0x60b26600 - 0x60b26658</span><br><span class="line">[    0.154337] initcall init_static_idmap+0x0/0x74 returned 0 after 0 usecs</span><br><span class="line">[    0.154453] calling  dcscb_init+0x0/0x1a8 @ 1</span><br><span class="line">[    0.154738] initcall dcscb_init+0x0/0x1a8 returned -19 after 0 usecs</span><br><span class="line">[    0.154848] calling  tc2_pm_init+0x0/0x250 @ 1</span><br><span class="line">[    0.155097] initcall tc2_pm_init+0x0/0x250 returned -19 after 0 usecs</span><br><span class="line">[    0.155207] calling  spawn_ksoftirqd+0x0/0x60 @ 1</span><br><span class="line">[    0.159450] initcall spawn_ksoftirqd+0x0/0x60 returned 0 after 9765 usecs</span><br><span class="line">[    0.159624] calling  init_workqueues+0x0/0x800 @ 1</span><br><span class="line">[    0.170386] initcall init_workqueues+0x0/0x800 returned 0 after 9765 usecs</span><br><span class="line">[    0.170520] calling  migration_init+0x0/0xa4 @ 1</span><br><span class="line">[    0.170714] initcall migration_init+0x0/0xa4 returned 0 after 0 usecs</span><br><span class="line">[    0.170830] calling  check_cpu_stall_init+0x0/0x24 @ 1</span><br><span class="line">[    0.170876] initcall check_cpu_stall_init+0x0/0x24 returned 0 after 0 usecs</span><br><span class="line">[    0.170985] calling  rcu_spawn_gp_kthread+0x0/0x1f0 @ 1</span><br><span class="line">[    0.172303] initcall rcu_spawn_gp_kthread+0x0/0x1f0 returned 0 after 0 usecs</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>设置resume超时2秒，手动进入休眠<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 2000 &gt; resume_timeout </span><br><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[   30.075565] PM: Syncing filesystems ... done.</span><br><span class="line">[   30.077755] PM: Preparing system for mem sleep</span><br><span class="line">[   30.128189] Freezing user space processes ... (elapsed 0.019 seconds) done.</span><br><span class="line">[   30.149985] Freezing remaining freezable tasks ... (elapsed 0.007 seconds) done.</span><br><span class="line">[   30.158478] PM: Entering mem sleep</span><br><span class="line">[   30.158851] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[   30.161310] calling  input2+ @ 768, parent: serio1</span><br><span class="line">[   30.163481] call input2+ returned 0 after 2011 usecs</span><br><span class="line">[   30.163599] calling  oprofile-perf.0+ @ 768, parent: platform</span><br><span class="line">[   30.163768] call oprofile-perf.0+ returned 0 after 144 usecs</span><br><span class="line">...</span><br><span class="line">[   30.168789] calling  qksleep+ @ 768, parent: platform</span><br><span class="line">[   30.169022] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[   30.169027] call qksleep+ returned 0 after 202 usecs</span><br><span class="line">[   30.169428] ...</span><br><span class="line">[   30.175275] PM: suspend of devices complete after 14.735 msecs</span><br><span class="line">[   30.175416] PM: suspend devices took 0.010 seconds</span><br><span class="line">[   30.178217] PM: late suspend of devices complete after 2.592 msecs</span><br><span class="line">[   30.180898] PM: noirq suspend of devices complete after 2.424 msecs</span><br><span class="line">[   30.181213] PM: suspend-to-idle</span><br><span class="line">[   40.260326] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[   40.260340] PM: resume from suspend-to-idle</span><br><span class="line">[   40.263683] PM: noirq resume of devices complete after 2.594 msecs</span><br><span class="line">[   40.265601] PM: early resume of devices complete after 1.461 msecs</span><br><span class="line">[   40.266288] calling  reg-dummy+ @ 768, parent: platform</span><br><span class="line">[   40.266395] call reg-dummy+ returned 0 after 84 usecs</span><br><span class="line">[   40.266438] calling  10000000.sysreg+ @ 768, parent: platform</span><br><span class="line">[   40.266455] call 10000000.sysreg+ returned 0 after 1 usecs</span><br><span class="line">[   40.266487] calling  syscon.0.auto+ @ 768, parent: 10000000.sysreg</span><br><span class="line">...</span><br><span class="line">[   40.271348] calling  qksleep+ @ 768, parent: platform</span><br><span class="line">[   42.269188] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[   42.269209] call qksleep+ returned 0 after 1950845 usecs</span><br><span class="line">...</span><br><span class="line">[   42.282800] PM: resume of devices complete after 2016.935 msecs</span><br><span class="line">[   42.286160] PM: resume devices took 2.020 seconds</span><br><span class="line">[   42.389269] PM: Finishing wakeup.</span><br><span class="line">[   42.390769] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>明显可以看出来在qksleep设备的resume过程耗时1950845微秒<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[   42.269209] call qksleep+ returned 0 after 1950845 usecs</span><br></pre></td></tr></table></figure></p>
<h3 id="no-console-suspend"><a href="#no-console-suspend" class="headerlink" title="no_console_suspend"></a>no_console_suspend</h3><p>默认的kernel休眠过程中会禁用console，因此suspend的任何打印只有在系统唤醒以后才能看到，对于suspend这部分的执行过程，kernel是不会输出的。而开启<code>no_console_suspend</code>选项，可以让kernel进入suspend的过程，仍然输出打印</p>
<p>no_console_suspend的控制位于/kernel/power/suspend.c和/kernel/printk.c文件中，函数<code>console_suspend_disable</code>用于处理kernel参数no_console_suspend，当设置了该参数后，全局变量<code>console_suspend_enabled</code>的值为false<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">console_suspend_disable</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	console_suspend_enabled = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">&quot;no_console_suspend&quot;</span>, console_suspend_disable);</span><br></pre></td></tr></table></figure></p>
<p>kernel休眠时会调用<code>suspend_devices_and_enter</code>来执行设备的休眠流程，在其中会调用<code>suspend_console</code>来执行console的suspend<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * suspend_console - suspend the console subsystem</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This disables printk() while we go into suspend states</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suspend_console</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!console_suspend_enabled)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	printk(<span class="string">&quot;Suspending console(s) (use no_console_suspend to debug)\n&quot;</span>);</span><br><span class="line">	console_lock();</span><br><span class="line">	console_suspended = <span class="number">1</span>;</span><br><span class="line">	up_console_sem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>console_suspend_enabled</code>为真，则会执行下面的锁定console操作，此后所有<code>printk</code>的打印信息不会立刻打印到终端；如果为否，直接退出，此后<code>printk</code>函数的打印信息不受影响</p>
<p><code>no_console_suspend</code>参数比较适用于要跟踪调试kernel代码的情况，且适用于suspend后唤醒不正常的情况</p>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>qksleep的resume设置模拟死锁，并分别在带<code>no_console_suspend</code>参数和不带参数情况下调试</p>
<p>qksleep的resume设置死锁<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 1 &gt; resume_errlock</span><br></pre></td></tr></table></figure></p>
<p>不带<code>no_console_suspend</code>情况下，手动进入休眠，打印在“Suspending console(s) (use no_console_suspend to debug)”处停止<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[  160.900817] PM: Syncing filesystems ... done.</span><br><span class="line">[  160.902427] PM: Preparing system for mem sleep</span><br><span class="line">[  160.962134] Freezing user space processes ... (elapsed 0.036 seconds) done.</span><br><span class="line">[  161.000256] Freezing remaining freezable tasks ... (elapsed 0.018 seconds) done.</span><br><span class="line">[  161.020661] PM: Entering mem sleep</span><br><span class="line">[  161.021063] Suspending console(s) (use no_console_suspend to debug)</span><br></pre></td></tr></table></figure></p>
<p>带<code>no_console_suspend</code>的情况下，手动进入休眠，死锁前的打印都能看到<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[   41.220243] PM: Syncing filesystems ... done.</span><br><span class="line">[   41.222718] PM: Preparing system for mem sleep</span><br><span class="line">[   41.274511] Freezing user space processes ... (elapsed 0.026 seconds) done.</span><br><span class="line">[   41.301588] Freezing remaining freezable tasks ... (elapsed 0.011 seconds) done.</span><br><span class="line">[   41.313599] PM: Entering mem sleep</span><br><span class="line">[   41.322571] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[   41.326340] PM: suspend of devices complete after 11.215 msecs</span><br><span class="line">[   41.326920] PM: suspend devices took 0.010 seconds</span><br><span class="line">[   41.330000] PM: late suspend of devices complete after 2.664 msecs</span><br><span class="line">[   41.332451] PM: noirq suspend of devices complete after 2.001 msecs</span><br><span class="line">[   41.333041] PM: suspend-to-idle</span><br><span class="line">[   51.341481] [debug] [qksleep_work_suspend_wakeup:51] qksleep is suspended, wakeup...</span><br><span class="line">[   51.344717] PM: resume from suspend-to-idle</span><br><span class="line">[   51.347243] PM: noirq resume of devices complete after 1.331 msecs</span><br><span class="line">[   51.349427] PM: early resume of devices complete after 1.406 msecs</span><br><span class="line">[   51.352296] [debug] [qksleep_resume:108] qksleep resume in</span><br></pre></td></tr></table></figure></p>
<h3 id="ignore-loglevel"><a href="#ignore-loglevel" class="headerlink" title="ignore_loglevel"></a>ignore_loglevel</h3><p>开启<code>ignore_loglevel</code>参数后，kernel的打印会无视log级别限制，所有打印都能看到，适用于代码中有很多log级别区分的调试</p>
<h3 id="pm-test"><a href="#pm-test" class="headerlink" title="pm_test"></a>pm_test</h3><p>该功能依赖kernel配置宏<code>CONFIG_PM_DEBUG</code>，在make menuconfig中配置路径为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="meta">  --&gt;</span><span class="bash"> Power management options</span></span><br><span class="line">    [*] Power Management Debug Support</span><br></pre></td></tr></table></figure></p>
<p>开启此配置后，可通过写入/sys/power/pm_test节点让PM core以测试模式运行，测试模式有5个级别，对应于不同深度的休眠</p>
<ul>
<li>freezer：测试进程冻结</li>
<li>devices：测试进程冻结和设备suspend</li>
<li>platform：测试进程冻结、设备suspend、平台架构相关suspend</li>
<li>processors：测试进程冻结、设备suspend、平台架构相关suspend、禁用非引导CPU</li>
<li>core：测试进程冻结、设备suspend、平台架构相关suspend、禁用非引导CPU、系统suspend</li>
</ul>
<p>这5个级别由浅入深，正好对应kernel的休眠流程，kernel在不同地方都设置了测试点<code>suspend_test</code>，当设置了测试模式后，对应级别的测试点会delay 5秒钟然后唤醒系统<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">suspend_test</span><span class="params">(<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PM_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (pm_test_level == level) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;suspend debug: Waiting for 5 seconds.\n&quot;</span>);</span><br><span class="line">		mdelay(<span class="number">5000</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !CONFIG_PM_DEBUG */</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这种方法能够在不添加额外唤醒源的情况下测试suspend/resume的完整流程，且能够分阶段进行调试</p>
<h4 id="验证-2"><a href="#验证-2" class="headerlink" title="验证"></a>验证</h4><p>禁用qksleep原本的suspend唤醒<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo 0 &gt; suspend_wakeup_timeout</span><br></pre></td></tr></table></figure></p>
<p>设置PM core调试模式为devices<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo devices &gt; /sys/power/pm_test</span><br></pre></td></tr></table></figure></p>
<p>设置qksleep设备resume返回错误值-1<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo -1 &gt; resume_ret</span><br></pre></td></tr></table></figure></p>
<p>手动进入休眠，可看到kernel在5秒后自动唤醒了<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/devices/platform/qksleep # echo mem &gt; /sys/power/state</span><br><span class="line">[  229.676306] PM: Syncing filesystems ... done.</span><br><span class="line">[  229.676943] PM: Preparing system for mem sleep</span><br><span class="line">[  229.701077] Freezing user space processes ... (elapsed 0.013 seconds) done.</span><br><span class="line">[  229.716141] Freezing remaining freezable tasks ... (elapsed 0.008 seconds) done.</span><br><span class="line">[  229.725218] PM: Entering mem sleep</span><br><span class="line">[  229.725415] Suspending console(s) (use no_console_suspend to debug)</span><br><span class="line">[  229.730420] [debug] [qksleep_suspend:89] qksleep suspend in</span><br><span class="line">[  229.730427] PM: suspend of devices complete after 4.232 msecs</span><br><span class="line">[  229.730448] PM: suspend devices took 0.000 seconds</span><br><span class="line">[  229.730459] suspend debug: Waiting for 5 seconds.</span><br><span class="line">[  234.941168] [debug] [qksleep_resume:108] qksleep resume in</span><br><span class="line">[  234.941173] dpm_run_callback(): platform_pm_resume+0x0/0x90 returns -1</span><br><span class="line">[  234.941196] PM: Device qksleep failed to resume: error -1</span><br><span class="line">[  234.942311] PM: resume of devices complete after 2.948 msecs</span><br><span class="line">[  234.943057] PM: resume devices took 0.000 seconds</span><br><span class="line">[  234.945443] PM: Finishing wakeup.</span><br><span class="line">[  234.945607] Restarting tasks ... done.</span><br><span class="line">/sys/devices/platform/qksleep # </span><br></pre></td></tr></table></figure></p>
<h3 id="sys-kernel-debug-wakeup-source"><a href="#sys-kernel-debug-wakeup-source" class="headerlink" title="/sys/kernel/debug/wakeup_source"></a>/sys/kernel/debug/wakeup_source</h3><p>该节点列举了当前系统中所有唤醒源以及他们的状况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/kernel/debug # cat wakeup_sources </span><br><span class="line">name		active_count	event_count	wakeup_count	expire_count	active_since	total_time	max_time	last_change	prevent_suspend_time</span><br><span class="line">10017000.rtc	0		        0		    0		        0		        0		        0		    0		    6937		    0</span><br><span class="line">qksleep     	1		        1		    0		        1		        0		        196		    196		    1231539		    0</span><br><span class="line">alarmtimer  	0		        0		    0		        0		        0		        0		    0		    4021		    0</span><br><span class="line">autosleep   	0		        0		    0		        0		        0		        0		    0		    280		        0</span><br><span class="line">/sys/kernel/debug # </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>name：唤醒源的驱动名称</li>
<li>active_count：wake lock 活跃次数</li>
<li>event_count：唤醒源唤醒事件次数</li>
<li>wakeup_count：唤醒源强制设备唤醒的次数</li>
<li>expire_count：唤醒源已到期次数</li>
<li>active_since：唤醒源处于活跃状态的时间(以jiffies时间为单位)</li>
<li>total_time：唤醒源活跃的总时间(以jiffies时间为单位)</li>
<li>max_time：唤醒源持续活跃的最长时间</li>
<li>last_change：上次更改唤醒源为活跃的时间戳</li>
<li>prevent_suspend_time：如果没有这个唤醒源，系统进入suspend可以节省多少时间。这对于计算对电池寿命的影响特别有用</li>
</ul>
<h4 id="验证-3"><a href="#验证-3" class="headerlink" title="验证"></a>验证</h4><p>首次启动系统，查看该节点，所有唤醒源均未唤醒过系统</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">/ # cat /sys/kernel/debug/wakeup_sources </span><br><span class="line">name		active_count	event_count	wakeup_count	expire_count	active_since	total_time	max_time	last_change	prevent_suspend_time</span><br><span class="line"><span class="number">10017000</span>.rtc	 <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">7296</span>		    <span class="number">0</span></span><br><span class="line">qksleep     	 <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">6725</span>		    <span class="number">0</span></span><br><span class="line">alarmtimer  	 <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">4358</span>		    <span class="number">0</span></span><br><span class="line">autosleep   	 <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">300</span>		        <span class="number">0</span></span><br><span class="line">/ # </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>手动进入休眠，待系统唤醒后，查看唤醒源</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">/ # <span class="built_in">echo</span> mem &gt; /sys/power/state</span><br><span class="line">[  <span class="number">292</span>.<span class="number">573467</span>] PM: Syncing filesystems ... done.</span><br><span class="line">[  <span class="number">292</span>.<span class="number">578116</span>] PM: Preparing system <span class="keyword">for</span> mem sleep</span><br><span class="line">[  <span class="number">292</span>.<span class="number">644122</span>] Freezing user space processes ... (elapsed <span class="number">0</span>.<span class="number">036</span> seconds) done.</span><br><span class="line">[  <span class="number">292</span>.<span class="number">681593</span>] Freezing remaining freezable tasks ... (elapsed <span class="number">0</span>.<span class="number">020</span> seconds) done.</span><br><span class="line">[  <span class="number">292</span>.<span class="number">704121</span>] PM: Entering mem sleep</span><br><span class="line">[  <span class="number">292</span>.<span class="number">722582</span>] [debug] [qksleep_suspend:<span class="number">89</span>] qksleep suspend <span class="keyword">in</span></span><br><span class="line">[  <span class="number">292</span>.<span class="number">726072</span>] PM: suspend of devices complete after <span class="number">13</span>.<span class="number">506</span> msecs</span><br><span class="line">[  <span class="number">292</span>.<span class="number">726509</span>] PM: suspend devices took <span class="number">0</span>.<span class="number">020</span> seconds</span><br><span class="line">[  <span class="number">292</span>.<span class="number">728801</span>] PM: late suspend of devices complete after <span class="number">1</span>.<span class="number">917</span> msecs</span><br><span class="line">[  <span class="number">292</span>.<span class="number">732123</span>] PM: noirq suspend of devices complete after <span class="number">2</span>.<span class="number">847</span> msecs</span><br><span class="line">[  <span class="number">292</span>.<span class="number">733016</span>] PM: suspend-to-idle</span><br><span class="line">[  <span class="number">302</span>.<span class="number">741766</span>] [debug] [qksleep_work_suspend_wakeup:<span class="number">51</span>] qksleep is suspended, wakeup...</span><br><span class="line">[  <span class="number">302</span>.<span class="number">743342</span>] PM: resume from suspend-to-idle</span><br><span class="line">[  <span class="number">302</span>.<span class="number">746235</span>] PM: noirq resume of devices complete after <span class="number">1</span>.<span class="number">903</span> msecs</span><br><span class="line">[  <span class="number">302</span>.<span class="number">748644</span>] PM: early resume of devices complete after <span class="number">1</span>.<span class="number">406</span> msecs</span><br><span class="line">[  <span class="number">302</span>.<span class="number">751825</span>] [debug] [qksleep_resume:<span class="number">108</span>] qksleep resume <span class="keyword">in</span></span><br><span class="line">[  <span class="number">302</span>.<span class="number">754932</span>] PM: resume of devices complete after <span class="number">5</span>.<span class="number">491</span> msecs</span><br><span class="line">[  <span class="number">302</span>.<span class="number">756098</span>] PM: resume devices took <span class="number">0</span>.<span class="number">010</span> seconds</span><br><span class="line">[  <span class="number">302</span>.<span class="number">756843</span>] PM: Finishing wakeup.</span><br><span class="line">[  <span class="number">302</span>.<span class="number">757105</span>] Restarting tasks ... done.</span><br><span class="line">/ # </span><br><span class="line">/ # cat /sys/kernel/debug/wakeup_sources </span><br><span class="line">name		active_count	event_count	wakeup_count	expire_count	active_since	total_time	max_time	last_change	prevent_suspend_time</span><br><span class="line"><span class="number">10017000</span>.rtc	<span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">7296</span>		    <span class="number">0</span></span><br><span class="line">qksleep     	<span class="number">1</span>		        <span class="number">1</span>		    <span class="number">0</span>		        <span class="number">1</span>		        <span class="number">0</span>		        <span class="number">198</span>		    <span class="number">198</span>		    <span class="number">302929</span>		    <span class="number">0</span></span><br><span class="line">alarmtimer  	<span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">4358</span>		    <span class="number">0</span></span><br><span class="line">autosleep   	<span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		        <span class="number">0</span>		    <span class="number">0</span>		    <span class="number">300</span>		        <span class="number">0</span></span><br><span class="line">/ # </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可看到是qksleep驱动唤醒了系统</p>
]]></content>
      <categories>
        <category>Linux Kernel</category>
        <category>电源管理</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
        <tag>PM</tag>
      </tags>
  </entry>
  <entry>
    <title>杭州市地铁乘客流量预测</title>
    <url>/2019/05/28/%E6%9D%AD%E5%B7%9E%E5%B8%82%E5%9C%B0%E9%93%81%E4%B9%98%E5%AE%A2%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>(待续)</p>
<p>天池竞赛城市计算AI挑战赛以“杭州市地铁乘客流量预测”为题，提供了杭州市2019年1月1日到25日的地铁刷卡流量数据，要求预测出未来时间的客流变化情况</p>
<h1 id="赛题简介"><a href="#赛题简介" class="headerlink" title="赛题简介"></a>赛题简介</h1><p>赛题提供了以下文件</p>
<ul>
<li>Metro_train.zip，包含25天的刷卡数据，每天为一个单独的.csv文件</li>
<li>testA_record_2019-01-28.csv，测试集，用来测试模型性能</li>
<li>Metro_roadMap.csv，各地铁站点连接关系</li>
</ul>
<p>刷卡数据格式为</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">列名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">time</td>
<td style="text-align:left">String</td>
<td style="text-align:left">刷卡发生时间</td>
<td style="text-align:left">2019-01-02 00:30:53</td>
</tr>
<tr>
<td style="text-align:left">lineID</td>
<td style="text-align:left">String</td>
<td style="text-align:left">地铁线路ID</td>
<td style="text-align:left">C</td>
</tr>
<tr>
<td style="text-align:left">stationID</td>
<td style="text-align:left">int</td>
<td style="text-align:left">地铁站ID</td>
<td style="text-align:left">15</td>
</tr>
<tr>
<td style="text-align:left">deviceID</td>
<td style="text-align:left">int</td>
<td style="text-align:left">刷卡设备ID</td>
<td style="text-align:left">2992</td>
</tr>
<tr>
<td style="text-align:left">status</td>
<td style="text-align:left">int</td>
<td style="text-align:left">进出站状态，0表示出站，1表示进站</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">userID</td>
<td style="text-align:left">String</td>
<td style="text-align:left">用户ID</td>
<td style="text-align:left">C21b87e232a083b3e7d6d45e2ff933e31</td>
</tr>
<tr>
<td style="text-align:left">payType</td>
<td style="text-align:left">int</td>
<td style="text-align:left">刷卡类型</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
</div>
<p>Metro_roadMap.csv文件中是一个2维矩阵，首行和首列是地铁站ID，roadMap[i][j]为1表示stationID为i的地铁站和为j的地铁站相连，为0表示不相连</p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>使用pandas对数据做一个初步分析</p>
<h3 id="整体情况"><a href="#整体情况" class="headerlink" title="整体情况"></a>整体情况</h3><p>首先读取一个数据文件，查看结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = pd.read_csv(path+<span class="string">&#x27;/record_2019-01-01.csv&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.head()</span><br><span class="line">                    time lineID  stationID  deviceID  status                             userID  payType</span><br><span class="line"><span class="number">0</span>  <span class="number">2019</span>-01-01 02:<span class="number">00</span>:05      B         <span class="number">27</span>      <span class="number">1354</span>       <span class="number">0</span>  D13f76f42c9a677c4add94d9e480fb5c5        <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2019</span>-01-01 02:01:<span class="number">40</span>      B          <span class="number">5</span>       <span class="number">200</span>       <span class="number">1</span>  D9a337d37d9512184b8e3fd477934b293        <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2019</span>-01-01 02:01:<span class="number">53</span>      B          <span class="number">5</span>       <span class="number">247</span>       <span class="number">0</span>  Dc9e179298617f40b782490c1f3e2346c        <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2019</span>-01-01 02:02:<span class="number">38</span>      B          <span class="number">5</span>       <span class="number">235</span>       <span class="number">0</span>  D9a337d37d9512184b8e3fd477934b293        <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2019</span>-01-01 02:03:<span class="number">42</span>      B         <span class="number">23</span>      <span class="number">1198</span>       <span class="number">0</span>  Dd1cde61886c23fdb7ef1fdb76c9b1234        <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，文件结构与描述一致，从左到右，列依次为time、lineID、stationID、deviceID、status、userID和payType</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.info()</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">2539592</span> entries, <span class="number">0</span> to <span class="number">2539591</span></span><br><span class="line">Data columns (total <span class="number">7</span> columns):</span><br><span class="line">time         <span class="built_in">object</span></span><br><span class="line">lineID       <span class="built_in">object</span></span><br><span class="line">stationID    int64</span><br><span class="line">deviceID     int64</span><br><span class="line">status       int64</span><br><span class="line">userID       <span class="built_in">object</span></span><br><span class="line">payType      int64</span><br><span class="line">dtypes: int64(<span class="number">4</span>), <span class="built_in">object</span>(<span class="number">3</span>)</span><br><span class="line">memory usage: <span class="number">106.6</span>+ MB</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>除了首行，数据共2539592条，占用106MB内存</p>
<p>查看描述信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.describe()</span><br><span class="line">          stationID      deviceID        status       payType</span><br><span class="line">count  <span class="number">2.539592e+06</span>  <span class="number">2.539592e+06</span>  <span class="number">2.539592e+06</span>  <span class="number">2.539592e+06</span></span><br><span class="line">mean   <span class="number">2.885803e+01</span>  <span class="number">1.395870e+03</span>  <span class="number">5.002957e-01</span>  <span class="number">1.432034e+00</span></span><br><span class="line">std    <span class="number">2.190865e+01</span>  <span class="number">1.002121e+03</span>  <span class="number">5.000000e-01</span>  <span class="number">8.313080e-01</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">0.000000e+00</span>  <span class="number">0.000000e+00</span>  <span class="number">0.000000e+00</span>  <span class="number">0.000000e+00</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">1.100000e+01</span>  <span class="number">5.890000e+02</span>  <span class="number">0.000000e+00</span>  <span class="number">1.000000e+00</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">2.000000e+01</span>  <span class="number">1.056000e+03</span>  <span class="number">1.000000e+00</span>  <span class="number">1.000000e+00</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">4.600000e+01</span>  <span class="number">2.196000e+03</span>  <span class="number">1.000000e+00</span>  <span class="number">2.000000e+00</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">8.000000e+01</span>  <span class="number">3.638000e+03</span>  <span class="number">1.000000e+00</span>  <span class="number">3.000000e+00</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>由描述信息可看出</p>
<ul>
<li>共有253万次刷卡数据</li>
<li>地铁站ID从0到80，共81条地铁线</li>
<li>刷卡设备ID从0到3638，共3639个刷卡设备</li>
<li>payType从0到3，共4种刷卡方式</li>
</ul>
<h3 id="基本统计"><a href="#基本统计" class="headerlink" title="基本统计"></a>基本统计</h3><p>查看地铁线路统计信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.lineID.nunique()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.lineID.value_counts()</span><br><span class="line">B    <span class="number">1677014</span></span><br><span class="line">C     <span class="number">646253</span></span><br><span class="line">A     <span class="number">216325</span></span><br><span class="line">Name: lineID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>共3条地铁线，分别为A、B、C，其中地铁线路B流量最大为167万，C次之为64万，A最小为21万</p>
<p>查看地铁站统计信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.stationID.value_counts()</span><br><span class="line"><span class="number">15</span>    <span class="number">357091</span></span><br><span class="line"><span class="number">9</span>     <span class="number">167448</span></span><br><span class="line"><span class="number">7</span>      <span class="number">85737</span></span><br><span class="line"><span class="number">11</span>     <span class="number">75760</span></span><br><span class="line"><span class="number">10</span>     <span class="number">72913</span></span><br><span class="line"><span class="number">20</span>     <span class="number">70824</span></span><br><span class="line"><span class="number">8</span>      <span class="number">64963</span></span><br><span class="line"><span class="number">24</span>     <span class="number">61774</span></span><br><span class="line"><span class="number">22</span>     <span class="number">53702</span></span><br><span class="line"><span class="number">25</span>     <span class="number">51652</span></span><br><span class="line"><span class="number">33</span>     <span class="number">51514</span></span><br><span class="line"><span class="number">12</span>     <span class="number">48386</span></span><br><span class="line"><span class="number">4</span>      <span class="number">45819</span></span><br><span class="line"><span class="number">13</span>     <span class="number">38674</span></span><br><span class="line"><span class="number">14</span>     <span class="number">36249</span></span><br><span class="line"><span class="number">16</span>     <span class="number">33507</span></span><br><span class="line"><span class="number">29</span>     <span class="number">33227</span></span><br><span class="line"><span class="number">2</span>      <span class="number">32289</span></span><br><span class="line"><span class="number">51</span>     <span class="number">31819</span></span><br><span class="line"><span class="number">46</span>     <span class="number">29982</span></span><br><span class="line"><span class="number">38</span>     <span class="number">29870</span></span><br><span class="line"><span class="number">78</span>     <span class="number">29496</span></span><br><span class="line"><span class="number">57</span>     <span class="number">29271</span></span><br><span class="line"><span class="number">56</span>     <span class="number">26974</span></span><br><span class="line"><span class="number">6</span>      <span class="number">26747</span></span><br><span class="line"><span class="number">58</span>     <span class="number">26328</span></span><br><span class="line"><span class="number">76</span>     <span class="number">24916</span></span><br><span class="line"><span class="number">39</span>     <span class="number">24714</span></span><br><span class="line"><span class="number">63</span>     <span class="number">24493</span></span><br><span class="line"><span class="number">55</span>     <span class="number">24465</span></span><br><span class="line">       ...</span><br><span class="line"><span class="number">61</span>     <span class="number">19535</span></span><br><span class="line"><span class="number">27</span>     <span class="number">19339</span></span><br><span class="line"><span class="number">62</span>     <span class="number">19279</span></span><br><span class="line"><span class="number">43</span>     <span class="number">18252</span></span><br><span class="line"><span class="number">50</span>     <span class="number">18144</span></span><br><span class="line"><span class="number">70</span>     <span class="number">17751</span></span><br><span class="line"><span class="number">41</span>     <span class="number">17596</span></span><br><span class="line"><span class="number">48</span>     <span class="number">17528</span></span><br><span class="line"><span class="number">34</span>     <span class="number">17422</span></span><br><span class="line"><span class="number">32</span>     <span class="number">16166</span></span><br><span class="line"><span class="number">67</span>     <span class="number">15656</span></span><br><span class="line"><span class="number">45</span>     <span class="number">13837</span></span><br><span class="line"><span class="number">66</span>     <span class="number">13644</span></span><br><span class="line"><span class="number">71</span>     <span class="number">13590</span></span><br><span class="line"><span class="number">73</span>     <span class="number">13041</span></span><br><span class="line"><span class="number">36</span>     <span class="number">12786</span></span><br><span class="line"><span class="number">1</span>      <span class="number">12477</span></span><br><span class="line"><span class="number">44</span>     <span class="number">12349</span></span><br><span class="line"><span class="number">40</span>     <span class="number">10519</span></span><br><span class="line"><span class="number">21</span>     <span class="number">10488</span></span><br><span class="line"><span class="number">79</span>     <span class="number">10328</span></span><br><span class="line"><span class="number">31</span>     <span class="number">10033</span></span><br><span class="line"><span class="number">17</span>      <span class="number">9481</span></span><br><span class="line"><span class="number">64</span>      <span class="number">9176</span></span><br><span class="line"><span class="number">75</span>      <span class="number">7964</span></span><br><span class="line"><span class="number">28</span>      <span class="number">7939</span></span><br><span class="line"><span class="number">35</span>      <span class="number">7466</span></span><br><span class="line"><span class="number">72</span>      <span class="number">7223</span></span><br><span class="line"><span class="number">80</span>      <span class="number">6752</span></span><br><span class="line"><span class="number">74</span>      <span class="number">4642</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>站点15的流量最大，站点9次之</p>
<p>用户统计分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts = data.userID.value_counts()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts.shape</span><br><span class="line">(<span class="number">916414</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts&gt;<span class="number">10</span>].shape</span><br><span class="line">(<span class="number">1092</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts&gt;<span class="number">5</span>].shape</span><br><span class="line">(<span class="number">46683</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts==<span class="number">4</span>].shape</span><br><span class="line">(<span class="number">241819</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts==<span class="number">2</span>].shape</span><br><span class="line">(<span class="number">613793</span>,)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>由用户统计分析可看出</p>
<ul>
<li>总的地铁出行用户数为91万人</li>
<li>只有4.6万人刷卡次数超过5次，1万人刷卡次数超过10次，60万人刷卡次数为2，24万人刷卡次数为4次</li>
</ul>
<h3 id="挖掘规律"><a href="#挖掘规律" class="headerlink" title="挖掘规律"></a>挖掘规律</h3><p>由以上基本分析可得出几个关键结论</p>
<ul>
<li>从地铁线路来看，流量大小依次为B&gt;C&gt;A</li>
<li>从地铁站来看，15站点流量极高，9站点次之</li>
<li>从用户信息来看，大量用户刷卡次数在5次以下，其中66%的用户是单程</li>
</ul>
<p>由以上结论，提出以下问题</p>
<ul>
<li>为什么B线流量大？</li>
<li>为什么15站和9站流量大？</li>
<li>为什么单程用户流量大？单程的起始和终点集中在哪些线路和站点？往返用户占多少？</li>
</ul>
<h4 id="为什么B线流量大？"><a href="#为什么B线流量大？" class="headerlink" title="为什么B线流量大？"></a>为什么B线流量大？</h4><p>猜测B线流量大，可能是因为B线站点数量多，B线存在交通枢纽站点，或者B线上某些站点周边覆盖人口密度大</p>
<p>查看各线路站点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.lineID==<span class="string">&#x27;A&#x27;</span>].stationID.nunique()</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.lineID==<span class="string">&#x27;B&#x27;</span>].stationID.nunique()</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.lineID==<span class="string">&#x27;C&#x27;</span>].stationID.nunique()</span><br><span class="line"><span class="number">32</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可看到B线站点数量为34最多，C线32站，A线最少，只有14站</p>
<p>查看各地铁线站点流量情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.lineID==<span class="string">&#x27;A&#x27;</span>].stationID.value_counts().describe()</span><br><span class="line">count       <span class="number">14.000000</span></span><br><span class="line">mean     <span class="number">15451.785714</span></span><br><span class="line">std       <span class="number">7684.061288</span></span><br><span class="line"><span class="built_in">min</span>       <span class="number">4642.000000</span></span><br><span class="line"><span class="number">25</span>%       <span class="number">8555.000000</span></span><br><span class="line"><span class="number">50</span>%      <span class="number">14623.000000</span></span><br><span class="line"><span class="number">75</span>%      <span class="number">21201.000000</span></span><br><span class="line"><span class="built_in">max</span>      <span class="number">29496.000000</span></span><br><span class="line">Name: stationID, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.lineID==<span class="string">&#x27;B&#x27;</span>].stationID.value_counts().describe()</span><br><span class="line">count        <span class="number">34.000000</span></span><br><span class="line">mean      <span class="number">49323.941176</span></span><br><span class="line">std       <span class="number">62542.487342</span></span><br><span class="line"><span class="built_in">min</span>        <span class="number">7939.000000</span></span><br><span class="line"><span class="number">25</span>%       <span class="number">21330.250000</span></span><br><span class="line"><span class="number">50</span>%       <span class="number">32758.000000</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">53189.500000</span></span><br><span class="line"><span class="built_in">max</span>      <span class="number">357091.000000</span></span><br><span class="line">Name: stationID, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.lineID==<span class="string">&#x27;C&#x27;</span>].stationID.value_counts().describe()</span><br><span class="line">count       <span class="number">32.000000</span></span><br><span class="line">mean     <span class="number">20195.406250</span></span><br><span class="line">std       <span class="number">6149.949336</span></span><br><span class="line"><span class="built_in">min</span>       <span class="number">7466.000000</span></span><br><span class="line"><span class="number">25</span>%      <span class="number">17501.500000</span></span><br><span class="line"><span class="number">50</span>%      <span class="number">20390.500000</span></span><br><span class="line"><span class="number">75</span>%      <span class="number">24472.000000</span></span><br><span class="line"><span class="built_in">max</span>      <span class="number">31819.000000</span></span><br><span class="line">Name: stationID, dtype: float64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可看到地铁线A最大站点流量才2.9万，平均在1.5万；B线最大站点流量为35万，平均为4.9万；C线最大流量站点为3万，平均为2万；因此，B线大部分站点流量都较高，例如15站、9站等高流量站点，都属于B线，所以导致B线整体流量较大</p>
<h4 id="为什么15站和9站流量大？"><a href="#为什么15站和9站流量大？" class="headerlink" title="为什么15站和9站流量大？"></a>为什么15站和9站流量大？</h4><p>仅仅从训练数据种，无法得出15站和9站的其他信息，站点流量大小很大程度上取决于其周边设施以及本站是否为换乘站</p>
<p>根据赛题给出的站点连接关系，总结出以下交汇点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>站点1</th>
<th>站点2</th>
</tr>
</thead>
<tbody>
<tr>
<td>28</td>
<td>20</td>
</tr>
<tr>
<td>51</td>
<td>9</td>
</tr>
<tr>
<td>50</td>
<td>10</td>
</tr>
<tr>
<td>51</td>
<td>10</td>
</tr>
<tr>
<td>52</td>
<td>10</td>
</tr>
<tr>
<td>74</td>
<td>5</td>
</tr>
<tr>
<td>75</td>
<td>5</td>
</tr>
<tr>
<td>80</td>
<td>15</td>
</tr>
<tr>
<td>77</td>
<td>46</td>
</tr>
<tr>
<td>78</td>
<td>46</td>
</tr>
</tbody>
</table>
</div>
<p>根据站点交汇关系，以及各地铁线路的总站点数，再结合<a href="http://map.amap.com/subway/index.html?&amp;3301">杭州市地铁图</a>，可确定</p>
<ul>
<li>B线为1号线、C线为2号线，A线为4号线</li>
<li>B线站点范围为0~33，其中0为湘湖，5为近江，10为凤起路，15为火车站，20为客运中心，27为下沙滨江，33为临平</li>
<li>C线站点范围为34~66(54不存在)，其中34为朝阳，46为钱江路，51为凤起路</li>
<li>A线站点范围为67~80，74为甬江路，75为城星路，77为江锦路，78为景芳</li>
</ul>
<p>15站为火车站，由于刷卡数据为2019年1月份，临近春节，因此猜测15站流量大是因为春运流量<br>9站为龙翔桥，经百度地图查看，该站点临近西湖，且周边为商业繁华地带，而读取的数据文件是1月1日元旦，因此流量大</p>
<h4 id="为什么单程用户流量大？"><a href="#为什么单程用户流量大？" class="headerlink" title="为什么单程用户流量大？"></a>为什么单程用户流量大？</h4><p>查看单车用户集中在哪些站点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts = data.userID.value_counts()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oneway_users = user_counts[user_counts==<span class="number">2</span>].index</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oneway_users</span><br><span class="line">Index([<span class="string">u&#x27;Da777d480eb319974721ba1395276b9b9&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;Dbb272e5468e0f8f3119affa3548cb2d8&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;Ba5b3c0b2fdcc02009044e1745f786a40&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B5be311471b553fa8a1dae68ae2e98e25&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B5c8c3ea1fe6fdb0f70cc264a16a43349&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;Dde0d323a4dd433975277717c57525cef&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B55870174fd27626952cb0960a679ba6c&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;Ddf91d65e630c39ac4705d1a9789b1dbd&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B3487dabebed8c675e2d72fcaea059ce7&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B775172740ccc61a1856568a09baaa9dc&#x27;</span>,</span><br><span class="line">       ...</span><br><span class="line">       <span class="string">u&#x27;Be838ec43cc032ee398531caa5fd82bdb&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B54815c3bbb7135547c0407d252d1562f&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B703db1dc0f0a9600d7929754ca79e600&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B8fa611fb11119fe7ee4a11d79cd3f6b3&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;Dc989f13b188864668cc0e7d9347d946c&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B8f8d236356b772eb4f143796334d2981&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;Be37e7163697a8caacdb938546306eec0&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;A55804f3d7bf1b47eee1f26e77f7f9acb&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;D117ad973c40f4e4a154604f382923fb7&#x27;</span>,</span><br><span class="line">       <span class="string">u&#x27;B3ddd6a228d019312e7ce53fdb4476301&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;object&#x27;</span>, length=<span class="number">613793</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.userID.isin(oneway_users)].stationID.value_counts()</span><br><span class="line"><span class="number">15</span>    <span class="number">262484</span></span><br><span class="line"><span class="number">9</span>      <span class="number">60701</span></span><br><span class="line"><span class="number">7</span>      <span class="number">50871</span></span><br><span class="line"><span class="number">20</span>     <span class="number">39773</span></span><br><span class="line"><span class="number">11</span>     <span class="number">37383</span></span><br><span class="line"><span class="number">24</span>     <span class="number">35208</span></span><br><span class="line"><span class="number">25</span>     <span class="number">30863</span></span><br><span class="line"><span class="number">33</span>     <span class="number">27761</span></span><br><span class="line"><span class="number">10</span>     <span class="number">26101</span></span><br><span class="line"><span class="number">8</span>      <span class="number">25608</span></span><br><span class="line"><span class="number">12</span>     <span class="number">20355</span></span><br><span class="line"><span class="number">22</span>     <span class="number">20302</span></span><br><span class="line"><span class="number">13</span>     <span class="number">20282</span></span><br><span class="line"><span class="number">4</span>      <span class="number">20269</span></span><br><span class="line">       ...</span><br><span class="line">Name: stationID, Length: <span class="number">80</span>, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>单程用户613793人，那么总流量为613793*2=1227586次。单程流量集中在15、9、7、20、11、24、25，15为火车站，9为龙翔桥，7为客运站，20为客运中心，11为商圈和住宅中心，24、25是大学城，因此可判断单程流量主要是由于临近春运的各大车站出入人口，以及元旦假期的出入人口</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>编写代码，以天为单位，绘制总流量图<br><img src="/2019/05/28/%E6%9D%AD%E5%B7%9E%E5%B8%82%E5%9C%B0%E9%93%81%E4%B9%98%E5%AE%A2%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/image/subway-flow-predict-01.png" alt="回调上下文"><br>由上图可看出，总流量以周为单位，呈周期性变化，规律是周内工作日流量较高，周5到达峰值，周末降到峰谷(除了1月1日的元旦假期)<br>总的趋势是无论周内周日，随着时间临近春节，整体流量有上升趋势</p>
<p>以时刻为单位，绘制3条地铁线的某天实时流量图，发现所有周内情况与下图类似<br><img src="/2019/05/28/%E6%9D%AD%E5%B7%9E%E5%B8%82%E5%9C%B0%E9%93%81%E4%B9%98%E5%AE%A2%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/image/subway-flow-predict-03.png" alt="回调上下文"><br>整天的流量呈现双峰现象，分别集中在早8点和晚6点，是上下班流量</p>
<p>周末的流量与下图类似<br><img src="/2019/05/28/%E6%9D%AD%E5%B7%9E%E5%B8%82%E5%9C%B0%E9%93%81%E4%B9%98%E5%AE%A2%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/image/subway-flow-predict-04.png" alt="回调上下文"></p>
<p>1月1日元旦的流量图如下<br><img src="/2019/05/28/%E6%9D%AD%E5%B7%9E%E5%B8%82%E5%9C%B0%E9%93%81%E4%B9%98%E5%AE%A2%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/image/subway-flow-predict-02.png" alt="回调上下文"></p>
<h3 id="周内分析"><a href="#周内分析" class="headerlink" title="周内分析"></a>周内分析</h3><p>查看数据摘要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = pd.read_csv(path+<span class="string">&#x27;record_2019-01-02.csv&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.describe()</span><br><span class="line">          stationID      deviceID        status       payType</span><br><span class="line">count  <span class="number">2.376462e+06</span>  <span class="number">2.376462e+06</span>  <span class="number">2.376462e+06</span>  <span class="number">2.376462e+06</span></span><br><span class="line">mean   <span class="number">3.282597e+01</span>  <span class="number">1.574050e+03</span>  <span class="number">4.998182e-01</span>  <span class="number">1.371589e+00</span></span><br><span class="line">std    <span class="number">2.340102e+01</span>  <span class="number">1.069709e+03</span>  <span class="number">5.000001e-01</span>  <span class="number">8.458438e-01</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">0.000000e+00</span>  <span class="number">0.000000e+00</span>  <span class="number">0.000000e+00</span>  <span class="number">0.000000e+00</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">1.300000e+01</span>  <span class="number">6.770000e+02</span>  <span class="number">0.000000e+00</span>  <span class="number">1.000000e+00</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">2.600000e+01</span>  <span class="number">1.315000e+03</span>  <span class="number">0.000000e+00</span>  <span class="number">1.000000e+00</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">5.300000e+01</span>  <span class="number">2.565000e+03</span>  <span class="number">1.000000e+00</span>  <span class="number">2.000000e+00</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">8.000000e+01</span>  <span class="number">3.638000e+03</span>  <span class="number">1.000000e+00</span>  <span class="number">3.000000e+00</span></span><br></pre></td></tr></table></figure>
<p>可看到1月2日总流量为2376462</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts = data.userID.value_counts()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts.shape</span><br><span class="line">(<span class="number">764188</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts&gt;<span class="number">4</span>].shape</span><br><span class="line">(<span class="number">45376</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts==<span class="number">2</span>].shape</span><br><span class="line">(<span class="number">394674</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts[user_counts==<span class="number">4</span>].shape</span><br><span class="line">(<span class="number">315658</span>,)</span><br></pre></td></tr></table></figure>
<p>总刷卡人数为74万，刷卡数主要集中在单程和往返</p>
<h4 id="查看单程车站分布"><a href="#查看单程车站分布" class="headerlink" title="查看单程车站分布"></a>查看单程车站分布</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts = data.userID.value_counts()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oneway_users = user_counts[user_counts==<span class="number">2</span>].index</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.userID.isin(oneway_users)].stationID.value_counts()</span><br><span class="line"><span class="number">15</span>    <span class="number">132302</span></span><br><span class="line"><span class="number">7</span>      <span class="number">32533</span></span><br><span class="line"><span class="number">9</span>      <span class="number">27278</span></span><br><span class="line"><span class="number">4</span>      <span class="number">20530</span></span><br><span class="line"><span class="number">20</span>     <span class="number">20429</span></span><br><span class="line"><span class="number">11</span>     <span class="number">19184</span></span><br><span class="line"><span class="number">33</span>     <span class="number">17023</span></span><br><span class="line"><span class="number">13</span>     <span class="number">14934</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到，单程流量较高的车站有</p>
<ul>
<li>15：杭州东站</li>
<li>7：城站</li>
<li>9：龙翔桥</li>
<li>4：江陵路</li>
<li>20：客运中心</li>
<li>11：武林广场</li>
<li>33：临平<br>15、7和20客流量大是因为虽然是周内，依然是春运高峰期，或者元旦假期结尾的返程客流；9龙翔桥站靠近西湖景区，且周边有很多商业热点，猜测可能是经常性大流量；其余站点流量大还需要分析原因</li>
</ul>
<h5 id="查看杭州东站的人流方向"><a href="#查看杭州东站的人流方向" class="headerlink" title="查看杭州东站的人流方向"></a>查看杭州东站的人流方向</h5><p>首先查看从杭州东站进的人主要去往哪些站点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s15_in_users = data[data.stationID==<span class="number">15</span>][data.status==<span class="number">1</span>].userID.values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s15_out_users = data[data.stationID==<span class="number">15</span>][data.status==<span class="number">0</span>].userID.values</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&gt;&gt;&gt; data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s15_in_users)) &amp; (data.stationID!=<span class="number">15</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">11</span>    <span class="number">3705</span></span><br><span class="line"><span class="number">24</span>    <span class="number">3594</span></span><br><span class="line"><span class="number">25</span>    <span class="number">3453</span></span><br><span class="line"><span class="number">7</span>     <span class="number">3322</span></span><br><span class="line"><span class="number">9</span>     <span class="number">3303</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可看到，从15站进入的人，主要去往了11、24、25、7、9这几个站点，24、25是大学城区域，猜测是元旦假期返程人流；7是靠近杭州火车站，猜测是从东站换乘的春运人流；9站更加可以说明是从火车站来西湖游玩的日常流量；7站比9站里西湖稍远，但是也属于靠近西湖的站点，且周边住宅、商业热点众多，因此猜测也是和到西湖游玩有关</p>
<p>查看去往杭州东站的人主要来自哪些站点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s15_out_users)) &amp; (data.stationID!=<span class="number">15</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">9</span>     <span class="number">3476</span></span><br><span class="line"><span class="number">7</span>     <span class="number">2442</span></span><br><span class="line"><span class="number">11</span>    <span class="number">2296</span></span><br><span class="line"><span class="number">20</span>    <span class="number">1910</span></span><br><span class="line"><span class="number">33</span>    <span class="number">1864</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可看到，从15站出站乘坐高铁的人，主要来自9、7、11、20、33几个站点</p>
<ul>
<li>9：西湖游玩返程的人</li>
<li>7：春运换乘上高铁</li>
<li>11：西湖游玩返程的人</li>
<li>20：春运换乘上高铁</li>
<li>33：此站点远离市区，猜测可能房价偏低，人口密度大，也是属于春运客流</li>
</ul>
<h5 id="查看城站的人流方向"><a href="#查看城站的人流方向" class="headerlink" title="查看城站的人流方向"></a>查看城站的人流方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s7_in_users)) &amp; (data.stationID!=<span class="number">7</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">2442</span></span><br><span class="line"><span class="number">4</span>     <span class="number">1037</span></span><br><span class="line"><span class="number">2</span>      <span class="number">721</span></span><br><span class="line"><span class="number">33</span>     <span class="number">601</span></span><br><span class="line"><span class="number">0</span>      <span class="number">572</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可看到从城站进地铁的人流主要去往了15和4站点，15站是因为春运换乘，4站点是因为居住区</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s7_out_users)) &amp; (data.stationID!=<span class="number">7</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">3322</span></span><br><span class="line"><span class="number">0</span>      <span class="number">740</span></span><br><span class="line"><span class="number">4</span>      <span class="number">708</span></span><br><span class="line"><span class="number">9</span>      <span class="number">647</span></span><br><span class="line"><span class="number">33</span>     <span class="number">625</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可看到去往城站的人流，主要来自15站，因为春运换乘</p>
<h5 id="查看龙翔桥的人流方向"><a href="#查看龙翔桥的人流方向" class="headerlink" title="查看龙翔桥的人流方向"></a>查看龙翔桥的人流方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s9_in_users)) &amp; (data.stationID!=<span class="number">9</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">3476</span></span><br><span class="line"><span class="number">7</span>      <span class="number">647</span></span><br><span class="line"><span class="number">14</span>     <span class="number">466</span></span><br><span class="line"><span class="number">13</span>     <span class="number">453</span></span><br><span class="line"><span class="number">33</span>     <span class="number">442</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>从龙翔桥出发的人流主要去往了15站，是从西湖游玩返程的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s9_out_users)) &amp; (data.stationID!=<span class="number">9</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">3303</span></span><br><span class="line"><span class="number">7</span>      <span class="number">564</span></span><br><span class="line"><span class="number">14</span>     <span class="number">532</span></span><br><span class="line"><span class="number">33</span>     <span class="number">518</span></span><br><span class="line"><span class="number">13</span>     <span class="number">502</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>去往龙翔桥的人流主要来自15站，是去西湖游玩的</p>
<h5 id="查看江陵路人流方向"><a href="#查看江陵路人流方向" class="headerlink" title="查看江陵路人流方向"></a>查看江陵路人流方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s4_in_users)) &amp; (data.stationID!=<span class="number">4</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">1472</span></span><br><span class="line"><span class="number">7</span>      <span class="number">708</span></span><br><span class="line"><span class="number">2</span>      <span class="number">494</span></span><br><span class="line"><span class="number">9</span>      <span class="number">426</span></span><br><span class="line"><span class="number">3</span>      <span class="number">341</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>江陵路人流主要去往15和7站点，是春运出发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s4_out_users)) &amp; (data.stationID!=<span class="number">4</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">2287</span></span><br><span class="line"><span class="number">7</span>     <span class="number">1037</span></span><br><span class="line"><span class="number">2</span>      <span class="number">436</span></span><br><span class="line"><span class="number">9</span>      <span class="number">395</span></span><br><span class="line"><span class="number">0</span>      <span class="number">393</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>江陵路人流主要来自15和7站点，是春运返程</p>
<h5 id="查看客运中心人流方向"><a href="#查看客运中心人流方向" class="headerlink" title="查看客运中心人流方向"></a>查看客运中心人流方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s20_in_users)) &amp; (data.stationID!=<span class="number">20</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">1910</span></span><br><span class="line"><span class="number">25</span>     <span class="number">517</span></span><br><span class="line"><span class="number">7</span>      <span class="number">481</span></span><br><span class="line"><span class="number">33</span>     <span class="number">470</span></span><br><span class="line"><span class="number">24</span>     <span class="number">464</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>客运中心人流主要去往15站点，春运</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s20_out_users)) &amp; (data.stationID!=<span class="number">20</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">1948</span></span><br><span class="line"><span class="number">33</span>     <span class="number">484</span></span><br><span class="line"><span class="number">9</span>      <span class="number">390</span></span><br><span class="line"><span class="number">7</span>      <span class="number">361</span></span><br><span class="line"><span class="number">29</span>     <span class="number">302</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>客运中心人流主要来自15站点，春运</p>
<h5 id="查看武林广场人流方向"><a href="#查看武林广场人流方向" class="headerlink" title="查看武林广场人流方向"></a>查看武林广场人流方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s11_in_users)) &amp; (data.stationID!=<span class="number">11</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">2296</span></span><br><span class="line"><span class="number">7</span>      <span class="number">457</span></span><br><span class="line"><span class="number">4</span>      <span class="number">387</span></span><br><span class="line"><span class="number">9</span>      <span class="number">382</span></span><br><span class="line"><span class="number">14</span>     <span class="number">323</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>武林广场人流主要来自15站点，春运和去西湖游玩</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s11_out_users)) &amp; (data.stationID!=<span class="number">11</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">3705</span></span><br><span class="line"><span class="number">7</span>      <span class="number">511</span></span><br><span class="line"><span class="number">20</span>     <span class="number">456</span></span><br><span class="line"><span class="number">9</span>      <span class="number">391</span></span><br><span class="line"><span class="number">33</span>     <span class="number">354</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>武林广场人流主要去往15、7站点，春运和西湖游玩返程</p>
<h5 id="查看临平人流方向"><a href="#查看临平人流方向" class="headerlink" title="查看临平人流方向"></a>查看临平人流方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s33_in_users)) &amp; (data.stationID!=<span class="number">33</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">1864</span></span><br><span class="line"><span class="number">7</span>      <span class="number">625</span></span><br><span class="line"><span class="number">9</span>      <span class="number">518</span></span><br><span class="line"><span class="number">20</span>     <span class="number">484</span></span><br><span class="line"><span class="number">31</span>     <span class="number">392</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>临平人流主要来自15站点，春运</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[(data.userID.isin(oneway_users)) &amp; (data.userID.isin(s33_out_users)) &amp; (data.stationID!=<span class="number">33</span>)].stationID.value_counts()[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>    <span class="number">1895</span></span><br><span class="line"><span class="number">7</span>      <span class="number">601</span></span><br><span class="line"><span class="number">20</span>     <span class="number">470</span></span><br><span class="line"><span class="number">9</span>      <span class="number">442</span></span><br><span class="line"><span class="number">31</span>     <span class="number">309</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>临平人流主要去往15站点，春运</p>
<h4 id="查看返程车站分布"><a href="#查看返程车站分布" class="headerlink" title="查看返程车站分布"></a>查看返程车站分布</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.userID.isin(twiceway_users)].stationID.value_counts()[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"><span class="number">4</span>     <span class="number">45691</span></span><br><span class="line"><span class="number">15</span>    <span class="number">44826</span></span><br><span class="line"><span class="number">9</span>     <span class="number">42756</span></span><br><span class="line"><span class="number">12</span>    <span class="number">29187</span></span><br><span class="line"><span class="number">7</span>     <span class="number">28001</span></span><br><span class="line"><span class="number">16</span>    <span class="number">27825</span></span><br><span class="line"><span class="number">10</span>    <span class="number">26033</span></span><br><span class="line"><span class="number">11</span>    <span class="number">25882</span></span><br><span class="line"><span class="number">22</span>    <span class="number">25470</span></span><br><span class="line"><span class="number">5</span>     <span class="number">25369</span></span><br><span class="line">Name: stationID, dtype: int64</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>返程站点流量前10位为4、15、9、12、7、16、10、11、22、5，查看这些站点附近热点</p>
<ul>
<li>4，市公安局、滨江区政府、武警医院、江锦汽车有限公司、中财、中化、海康威视、吉利集团、百得利</li>
<li>9，市第一人民医院、浙大附属产科医院、银泰、天长小学、思鑫坊、胜利剧院、国贸中心、浙江省中医院、惠星中学</li>
<li>12，环球中心、科技馆、清园小区、通盛嘉苑、武林府、中山北园、西子花园、河东社区</li>
<li>7，建国中路小区、长明寺巷社区、第二中学、葵巷社区、新东方、浙大附属第一医院、银联、国贸、国税局、中闽大厦、国家电网、第六中学、三益里小区、第三人民医院</li>
<li>16，宇威德信、三花国际、港龙城、新和嘉苑、德信东望、明月嘉苑、明月嘉苑、夏衍小学</li>
<li>10，换乘站、皇亲苑社区、皇后公园、第十四中学、长寿社区、锦绣天地、杭州嘉里中心、建德路小区、凤麟社区、镜瑞弄、国都公寓、麒麟公寓、儿童医院、竹竿巷社区</li>
<li>11，国大城市广场、杭州百货大楼、浙信大厦、国信大厦、元通大厦、广发大厦、下城区人民医院、南都天水苑、仓桥社区、天水阳光家园、长江实验小学、天巢花苑、杭州大厦购物城、文化会堂浙江展览馆、浙江展览馆南广场、武林广场、电信大楼、中国电信、天水小学</li>
<li>22，经济技术开发区、龙湖滟澜山、龙湖时代金沙天街、德信中外公寓、名城湖左岸、新元社区、金沙城、金沙湖、和达御观邸、上沙锦湖家园、金沙湖公园</li>
<li>5，换乘站、杭州市公安局、望江公园、杭州市建兰中学分校、近江东园社区、近江家园、天福花园、滨江新苑、崇文实验学校、胜利小学、开元中学、妇产科医院、万泰城、文华苑、林风花园</li>
</ul>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_counts = data.userID.value_counts()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>twiceway_users = user_counts[user_counts==<span class="number">4</span>].index</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data.userID.isin(twiceway_users)].stationID.value_counts()</span><br><span class="line"><span class="number">15</span>    <span class="number">132302</span></span><br><span class="line"><span class="number">7</span>      <span class="number">32533</span></span><br><span class="line"><span class="number">9</span>      <span class="number">27278</span></span><br><span class="line"><span class="number">4</span>      <span class="number">20530</span></span><br><span class="line"><span class="number">20</span>     <span class="number">20429</span></span><br><span class="line"><span class="number">11</span>     <span class="number">19184</span></span><br><span class="line"><span class="number">33</span>     <span class="number">17023</span></span><br><span class="line"><span class="number">13</span>     <span class="number">14934</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>s13_in_users = data[data.stationID==13][data.status==1].userID.values<br>s13_out_users = data[data.stationID==13][data.status==0].userID.values</p>
<h1 id="模型选择和评估"><a href="#模型选择和评估" class="headerlink" title="模型选择和评估"></a>模型选择和评估</h1><h1 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h1>]]></content>
      <categories>
        <category>ML</category>
        <category>project</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>Python</tag>
        <tag>天池竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>构建gcc交叉编译链</title>
    <url>/2019/07/05/%E6%9E%84%E5%BB%BAgcc%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%93%BE/</url>
    <content><![CDATA[<h1 id="构建gcc交叉编译链"><a href="#构建gcc交叉编译链" class="headerlink" title="构建gcc交叉编译链"></a>构建gcc交叉编译链</h1><p>本文翻译“Cross-compilation Tool Making”</p>
<h2 id="download"><a href="#download" class="headerlink" title="download"></a>download</h2><ul>
<li>Binutils: <a href="http://ftp.gnu.org/gnu/binutils/">Index of /gnu/binutils</a></li>
<li>gcc: <a href="http://mirrors.kernel.org/gnu/gcc">Index of /gnu/gcc/</a></li>
<li>Glibc &amp; Glibc-ports: <a href="http://ftp.gnu.org/gnu/glibc/">Index of /gnu/glibc</a></li>
<li>mpfr-2.4.2: wget ftp://gcc.gnu.org/pub/gcc/infrastructure/mpfr-2.4.2.tar.bz2</li>
<li>gmp-4.3.2: wget ftp://gcc.gnu.org/pub/gcc/infrastructure/gmp-4.3.2.tar.bz2</li>
<li>mpc-0.8.1: wget ftp://gcc.gnu.org/pub/gcc/infrastructure/mpc-0.8.1.tar.gz</li>
</ul>
<h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><ul>
<li>setup-dir: download files</li>
<li>src-dir: unzip files</li>
</ul>
<h2 id="Binutils-install"><a href="#Binutils-install" class="headerlink" title="Binutils install"></a>Binutils install</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --target=$TARGET --prefix=$PREFIX</span><br></pre></td></tr></table></figure>
<h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p><a href="https://blog.csdn.net/w36680130/article/details/81740046">Linux ARM交叉编译工具链制作过程 - w36680130的博客 - CSDN博客</a></p>
<h1 id="Build-a-GCC-based-cross-compiler-for-Linux"><a href="#Build-a-GCC-based-cross-compiler-for-Linux" class="headerlink" title="Build a GCC-based cross compiler for Linux"></a>Build a GCC-based cross compiler for Linux</h1><h2 id="Section-1-开始之前"><a href="#Section-1-开始之前" class="headerlink" title="Section 1. 开始之前"></a>Section 1. 开始之前</h2><h3 id="关于这篇教程"><a href="#关于这篇教程" class="headerlink" title="关于这篇教程"></a>关于这篇教程</h3><p>有时候，你正在开发的平台和使用的计算机不匹配。例如，你可能想要在你的x86/Linux笔记本电脑上构建一个PowerPC/Linux应用程序。使用GNU工具包中的gcc、gas和lds工具，您可以指定并构建一个交叉编译器，它将使您能够在您的机器上为其他目标构建程序。只需多做一点工作，您甚至可以设置一个能为各种不同的目标构建应用程序的环境。在本教程中，我将介绍在你的系统上构建交叉编译器所需的整个过程。还将讨论为一系列目标构建一个完整的环境，向您展示如何与distcc和ccache工具集成，并介绍更新你的新开发平台以及更新最新版本的方法。</p>
<p>要构建一个交叉编译器，您需要了解典型UNIX开源项目的构建过程的基本知识、一些基本的shell技能和足够的耐心。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>要构建一个交叉编译器，您需要一个可工作的C编译器(gcc通常是一个好主意)。大多数基于Linux/unix的操作系统都提供了C编译器。您还需要用于构建交叉编译器的各种工具的源代码。您可以从GNU(<a href="http://www.gnu.org)下载GNU工具。">http://www.gnu.org)下载GNU工具。</a></p>
<p>除了这些工具之外，还需要目标平台的头文件副本。对于Linux目标，使用Kernel.org(<a href="http://www.kernel.org)提供的通用Linux内核头文件。">http://www.kernel.org)提供的通用Linux内核头文件。</a></p>
<h2 id="Section-2-交叉编译"><a href="#Section-2-交叉编译" class="headerlink" title="Section 2. 交叉编译"></a>Section 2. 交叉编译</h2><h3 id="为什么需要交叉编译"><a href="#为什么需要交叉编译" class="headerlink" title="为什么需要交叉编译"></a>为什么需要交叉编译</h3><p>并不总是在同一个平台上编写和构建应用程序。例如，对于许多嵌入式环境，用于RAM和存储的空间较小，通常小于256MB，甚至可能小于64MB。一个合理的C编译器、相关的工具和所需的C库都不适合这么小的空间，更不用说运行了。</p>
<p>实际上，在这样的环境下开发显然更加困难。如果您使用键盘显示器访问和使用系统，使用成熟的编辑器(例如emacs)或成熟的开发环境(IDEA)是不可能的。许多嵌入式解决方案甚至没有网络访问的能力。</p>
<p>跨编译器使您能够在一个具有开发能力的平台(主机)上进行开发，而实际构建另一个目标系统的程序。目标计算机并不需要可用，您所需要的只是一个编译器，它知道如何为您的目标平台编写机器码。交叉编译器在其他情况下也很有用。我曾经不得不在一台没有安装C编译器的计算机上工作，而且我没有获得预编译二进制文件的简单方法。但是，我确实拥有GNU编译器集合(GCC)、C库(newlib)和计算机上的二进制实用程序的必要源代码，而计算机上确实有C编译器。使用这些工具，我可以先为目标计算机构建一个交叉编译器，然后再为目标计算机构建一个本机编译器，我可以跨目标计算机复制并直接使用它。</p>
<p>当您的计算机速度较慢且速度快得多，并且希望在几分钟内而不是几小时或几天内构建时，交叉编译器也很方便。我曾使用这种方法在一台计算机上执行升级到新软件版本的任务，在此过程中，需要花费2-3天的时间来重建所有组件——而此时计算机正在执行其已经非常重要的服务器任务。</p>
<p>在我向您展示构建交叉编译器的细节之前，让我们仔细看看编译是如何工作的，以便您更好地理解为什么——更重要的是——交叉编译是如何工作的。</p>
<h3 id="交叉编译如何工作"><a href="#交叉编译如何工作" class="headerlink" title="交叉编译如何工作"></a>交叉编译如何工作</h3><p>编译器的工作方式很简单。几个不同的组件一起工作， 最终目标是生成目标CPU使用的字节码。当您可以生成组装好的字节码时，您已经成功地交叉编译了。</p>
<p>任何编译器的主要组件包括:</p>
<ul>
<li><strong>解析器</strong>：解析器将原始语言源代码转换为汇编语言，因为要从一种格式转换为另一种格式(C语言转换为汇编)，所以解析器需要知道目标汇编语言</li>
<li><strong>汇编器</strong>：汇编程序将汇编语言代码转换成CPU执行的字节码</li>
<li><strong>链接器</strong>：链接器将汇编程序生成的单个目标文件组合到可执行应用程序中。不同的操作系统和CPU组合通常使用不同的封装机制和标准。链接器需要知道该目标格式才能工作</li>
<li><strong>标准C库</strong>：核心C函数(例如printf)在C库中提供。假设应用程序中使用了来自C库的函数，那么这个库将与链接器和源代码结合使用，生成最终的可执行文件</li>
</ul>
<p>在标准的、基于主机的C编译器中，每个组件都被设计成生成相应的汇编代码、字节码和主机本身的目标执行格式。在交叉编译器中，虽然构建应用程序是为了在主机上执行，但汇编语言、链接器和C库都是为目标平台和处理器设计的。例如，基于intel的<br>在Linux机器上，您可以交叉编译一个应用程序，以便汇编语言和最终的应用程序都适用于基于solarisis的SPARC主机。</p>
<p>因此，构建交叉编译器依赖于构建C编译器套件的替代版本，该版本为目标主机生成并链接应用程序。幸运的是，因为可以编译GCC和相关的工具，所以可以构建自己的交叉编译器。</p>
<h3 id="交叉编译器构建过程"><a href="#交叉编译器构建过程" class="headerlink" title="交叉编译器构建过程"></a>交叉编译器构建过程</h3><p>GNU工具集(即GCC)，包括C编译器、二进制实用程序和C库，都有一些好处，其中最重要的是它们是免费的、开放源码的，并且易于编译。从跨编译器的角度来看，一个更大的好处是，由于GCC已经移植到许多平台上，代码支持几种不同的CPU和平台类型。然而，也有一些限制。GCC并不支持所有处理器类型(尽管它生成的处理器类型最多)，也并不支持所有平台。配置工具会在执行时警告您这一点。</p>
<p>要构建一个交叉编译器，您需要从GNU套件构建三个组件：</p>
<ul>
<li><strong>binutils</strong>：binutils包包括基本的二进制实用程序，如汇编程序、链接器和相关工具，如Size和Strip。二进制实用程序包含用于构建应用程序的核心组件和用于构建和操作目标执行格式的工具。例如，Strip程序从目标文件或应用程序中删除符号表、调试和其他“无用”信息，但要做到这一点，实用程序需要知道目标格式，以便不删除错误的信息</li>
<li><strong>gcc</strong>：gcc是编译过程的主要组件。Gcc包含C预处理器(cpp)和转换器，后者将C代码转换为目标CPU汇编语言。Gcc还充当整个流程的接口，相应地调用cpp、翻译程序、汇编程序和链接器</li>
<li><strong>newlib/glibc</strong>：这个库是标准的C库。Newlib是通过Redhat开发的，在为嵌入式目标设计的交叉编译器中，它对用户稍微友好一些。您也可以使用GNU库(glibc)，但我在本教程中主要使用newlib</li>
</ul>
<p>您还需要目标操作系统的头文件，这是必需的，以便您能够访问构建应用程序所需的所有操作系统级函数和系统调用。使用Linux，您可以相当容易地获得头文件。对于其他操作系统，您可以复制一组现有的头文件。稍后我将更详细地说明头文件。</p>
<p>您可以选择为目标主机构建GNU调试器(gdb)。您不能构建一个调试器来在主机上运行时为目标执行代码，因为这样做需要仿真。不过，您可以为目标主机构建一个gdb可执行文件。</p>
<h2 id="Section-3-准备"><a href="#Section-3-准备" class="headerlink" title="Section 3. 准备"></a>Section 3. 准备</h2><h3 id="目的地和共存"><a href="#目的地和共存" class="headerlink" title="目的地和共存"></a>目的地和共存</h3><p>在开始配置过程之前，需要确定将在何处安装编译器和相关工具。您有两个选择:要么将它们安装到一个完全独立的目录中，要么将它们作为现有安装的一部分安装。</p>
<p>GNU工具集的许多好处之一是内置在安装结构中的设计，它使不同目标平台的工具和组件能够共存。安装软件后，您提供的安装前缀将根据正常布局进行组织，并为特定于目标的工具添加一个目标目录。例如，下面的结构取自我为泛型安装了交叉编译器的系统<br>PowerPC / Linux平台:</p>
<p>drwxrwxrwx 2 root root 4096 Nov 16 16:48 bin/<br>drwxrwxrwx 2 root root 4096 Nov 17 12:53 info/<br>drwxrwxrwx 2 root root 4096 Nov 17 12:53 lib/<br>drwxrwxrwx 3 root root 4096 Nov 16 16:44 man/<br>drwxrwxrwx 4 root root 4096 Nov 16 16:48 ppc-linux/<br>drwxrwxrwx 3 root root 4096 Nov 16 16:43 share/</p>
<p>如果你查看bin目录，你会看到每个主要的二进制实用程序都有你的build-target前缀:</p>
<p>-rwxr-xr-x 1 root root 2108536 Nov 16 16:46 ppc-linux-addr2line<em><br>-rwxr-xr-x 2 root root 2157815 Nov 16 16:45 ppc-linux-ar</em><br>-rwxr-xr-x 2 root root 3398961 Nov 16 16:48 ppc-linux-as<em><br>-rwxr-xr-x 1 root root 2062804 Nov 16 16:47 ppc-linux-c++filt</em><br>-rwxr-xr-x 2 root root 2907348 Nov 16 16:48 ppc-linux-ld<em><br>-rwxr-xr-x 2 root root 2140893 Nov 16 16:46 ppc-linux-nm</em><br>-rwxr-xr-x 1 root root 2552661 Nov 16 16:46 ppc-linux-objcopy<em><br>-rwxr-xr-x 1 root root 2708801 Nov 16 16:45 ppc-linux-objdump</em><br>-rwxr-xr-x 2 root root 2157810 Nov 16 16:46 ppc-linux-ranlib<em><br>-rwxr-xr-x 1 root root 371010 Nov 16 16:46 ppc-linux-readelf</em><br>-rwxr-xr-x 1 root root 2008330 Nov 16 16:45 ppc-linux-size<em><br>-rwxr-xr-x 1 root root 1982880 Nov 16 16:46 ppc-linux-strings</em><br>-rwxr-xr-x 2 root root 2552660 Nov 16 16:46 ppc-linux-strip*</p>
<p>主要工具(如gcc)只是执行编译的后台工具的包装器，因此gcc可以在为不同平台构建时确定使用哪个工具。只要您继续将gcc用于您的构建需求，以及您构建的其他库和组件使用GNU configure结构，您应该能够在标准工具集旁边安装交叉编译工具。在大多数Linux平台上，这个位置都是/usr/local。我喜欢把我的交叉编译器和宿主编译器分开，这样我就可以保持不同版本的宿主和跨编译器工具集。</p>
<h3 id="确定您的目标平台"><a href="#确定您的目标平台" class="headerlink" title="确定您的目标平台"></a>确定您的目标平台</h3><p>准备交叉编译的下一步是确定目标平台。GNU系统中的目标有一个特定的格式，这个信息在整个构建过程中被用来识别各种工具的正确版本。因此，当您使用特定的目标运行GCC时，GCC会在目录路径中查找包含该目标规范的应用程序路径。</p>
<p>GNU目标规范的格式是CPU-PLATFORM-OS。x86的Solaris 8是i386-pc-solaris2.8，而Macintosh OS X是powerpc-apple-darwin7.6.0。PC上的Linux具有目标i686-pc-linux-gnu。本例中的-gnu标记表示Linux操作系统使用的是gnu风格的环境。</p>
<p>有许多方法可以识别目标，包括简单地了解或猜测目标规范。例如，大多数Linux目标可以根据它们的CPU来指定；因此，PowerPC/Linux是ppc-linux。然而，最好的方法是使用config.guess脚本，它随任何脚本一起提供GNU套件，包括我在本教程中使用的那些。要使用这个脚本，只需从一个shell运行它:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> config.guess</span></span><br><span class="line">i686-pc-linux-gnu</span><br></pre></td></tr></table></figure>
<p>对于那些无法运行此脚本的系统，有必要检查该文件以确定一些可能的目标。只要在目标CPU上使用grep，就可以了解所需的目标规范。出于本教程的目的，我将为i386-linux平台创建一个交叉编译器，这是一个公共目标，也是受支持程度最高的平台之一。</p>
<h3 id="设置构建环境"><a href="#设置构建环境" class="headerlink" title="设置构建环境"></a>设置构建环境</h3><p>开始构建之前的最后一个阶段是创建一个合适的环境。您只需要创建一个简单的目录集，您可以使用它来构建不同的组件。</p>
<p>首先，创建一个构建目录:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir crossbuild</span></span><br></pre></td></tr></table></figure><br>接下来，获取gcc、binutils、gdb和newlib的最新版本，并将它们提取到目录中:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bunzip2 -c gcc-3.3.2.tar.bz2|tar xf -</span><br><span class="line">$ bunzip2 -c binutils-2.14.tar.bz2 |tar xf -</span><br><span class="line">$ bunzip2 -c linux-2.6.9.tar.bz2 |tar xf -</span><br><span class="line">$ bunzip2 -c gdb-6.3.tar.bz2|tar xf -</span><br><span class="line">$ bunzip2 -c glibc-2.3.tar.bz2|tar xf -</span><br></pre></td></tr></table></figure></p>
<p>如果正在为Linux目标构建，还需要解包Linux -threads包(如果目标平台支持它)。</p>
<p>现在，创建实际构建软件的目录。基本布局是为每个组件创建一个目录:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir build-binutils build-gcc build-glibc build-gdb</span></span><br></pre></td></tr></table></figure><br>如果要创建几个不同的交叉编译器，可以考虑为每个目标创建单独的目录，然后在每个目标目录中创建上面的目录。</p>
<p>准备工作完成后，就可以配置和构建每个工具了。</p>
<h2 id="Section-4-配置和构建"><a href="#Section-4-配置和构建" class="headerlink" title="Section 4. 配置和构建"></a>Section 4. 配置和构建</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>重新输入所有东西是令人沮丧的，你可能会输入错误的东西。为了简化工作，我创建了几个环境变量来节省输入。我假设下面有一个类似伯恩的壳；如果使用csh、tcsh或类似的shell，可能需要使用特定于shell的技术。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TARGET=i386pc</span><br><span class="line">export PREFIX=/usr/local/crossgcc</span><br><span class="line">export TARGET_PREFIX=$PREFIX/$TARGET</span><br><span class="line">export PATH=$PATH:$PREFIX/bin</span><br></pre></td></tr></table></figure>
<h3 id="获取操作系统头文件"><a href="#获取操作系统头文件" class="headerlink" title="获取操作系统头文件"></a>获取操作系统头文件</h3><p>操作系统头对于获取编译器需要的信息是必要的，这些信息用于目标平台支持的系统函数调用。对于Linux目标，获得头文件的最佳方法是下载适当内核的最新副本。您需要对内核进行基本配置，以便生成正确的头文件供您复制，但是，您不需要构建或编译内核。对于我的示例目标i386-linux，必要的步骤如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> linux-2.6.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=i386 CROSS_COMPILE=i386-linux- menuconfig</span></span><br></pre></td></tr></table></figure><br>注意，上面后面的连字符不是拼写错误。通过运行上面的命令，将提示您为内核配置组件。因为您不需要过多地担心内核本身的内容，所以您只需要使用默认选项，保存配置，然后退出工具。</p>
<p>现在，您需要将标题复制到目标目录:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$TARGET_PREFIX</span>/include</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -r include/linux <span class="variable">$TARGET_PREFIX</span>/include</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -r include/asm-i386 <span class="variable">$TARGET_PREFIX</span>/include/asm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -r include/asm-generic <span class="variable">$TARGET_PREFIX</span>/include/</span></span><br></pre></td></tr></table></figure></p>
<p>显然，我在上面的代码中基于示例目标做了一些假设。如果您正在为PowerPC目标构建，您应该已经从asm-ppc复制了文件。</p>
<p>现在可以开始构建实用程序了。</p>
<h3 id="构建binutils"><a href="#构建binutils" class="headerlink" title="构建binutils"></a>构建binutils</h3><p>binutils实用程序是整个系统的核心。它提供了系统其余部分所需的基本汇编器和链接器功能。每种情况的第一个阶段都是为另一种目标平台配置每个包。构建的第一步：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build-binutils</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../binutils-2.14/configure --target=<span class="variable">$TARGET</span> --prefix=<span class="variable">$PREFIX</span> --disable-nls -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br></pre></td></tr></table></figure><br>目标和前缀应该是显而易见的。命令禁用国家语言支持(NLS)。无论如何，许多嵌入式平台都不能支持必要的表。对于大多数交叉编译器，NLS的有用性是有争议的，因为目标(通常是嵌入式设备)不能在内存中保存必要的NLS表。</p>
<p>构建的这个阶段将需要一些时间。因为您仍然在使用主机编译器和工具进行构建，所以可以使用ccache和distcc工具来帮助加速这个过程。有关这些工具的更多信息，请参见参考资料(# Resources)部分。</p>
<p>现在，您已经准备好构建GCC，它稍微复杂一些。</p>
<h3 id="构建第一阶段GCC"><a href="#构建第一阶段GCC" class="headerlink" title="构建第一阶段GCC"></a>构建第一阶段GCC</h3><p>GCC比binutils更复杂，这仅仅是因为构建GCC的标准方法构建两个编译器。GCC使用GNU工具来构建一个主程序(即，第一阶段，或引导)编译器，可以构建和解析基本代码。然后GCC使用目标的可用库和头文件来构建完整的编译器。构建GCC第一阶段编译器需要对配置脚本的选项进行一些较小的更改，这样您就可以在没有适当头文件的情况下构建第一阶段编译器。严格地说，只有在构建了库之后才会有头文件。<code>with-newlib</code>命令并不一定意味着您正在使用newlib:它只是告诉配置脚本不要担心头文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build-gcc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../gcc-3.3.2/configure --target=<span class="variable">$TARGET</span> --prefix=<span class="variable">$PREFIX</span> \</span></span><br><span class="line"><span class="bash">--without-headers --with-newlib -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all-gcc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install-gcc</span></span><br></pre></td></tr></table></figure>
<p>与构建binutils一样，这个阶段需要一段时间才能完成。时间长短取决于您的主机，但是可以期望从一个小时(即使是在高速机器上)到慢速或繁忙的主机上最多5或6个小时。</p>
<h3 id="构建newlib"><a href="#构建newlib" class="headerlink" title="构建newlib"></a>构建newlib</h3><p>您可以使用glibc的newlib。c.总的来说，newlib在嵌入式平台上表现得更好，因为newlib的设计初衷就是支持嵌入式平台。Glibc更适合linux风格的主机。</p>
<p>在构建newlib时，需要使用目标编译器和工具构建库。当然，该库应采用目标CPU和平台的格式和语言，以便用于构建依赖于库组件的应用程序:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build-newlib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CC=<span class="variable">$&#123;TARGET&#125;</span>-gcc ../newlib-1.12.0/configure --host=<span class="variable">$TARGET</span> --prefix=<span class="variable">$PREFIX</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p>
<p>构建了newlib之后，您可以基于此代码创建最终的GCC来创建最终的编译器。或者，您可以使用glibc，我将在下一个面板中介绍它。</p>
<h3 id="构建glibc"><a href="#构建glibc" class="headerlink" title="构建glibc"></a>构建glibc</h3><p>glibc包构建起来很简单；与以前版本的主要区别在于，与newlib一样，现在开始使用刚才构建的引导跨编译器。您还需要告诉configure脚本操作系统的头文件保存在哪里。最后——这是一个很大的区别——定义构建的主机而不是目标。这是因为您已经构建的GCC和二进制实用程序意味着这台机器是您的开发主机；您指定的GCC将为您生成必要的目标代码。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> CC=<span class="variable">$&#123;TARGET&#125;</span>-gcc ../glibc-2.3/configure --target=<span class="variable">$TARGET</span> \</span></span><br><span class="line"><span class="bash">--prefix=<span class="variable">$PREFIX</span> --with-headers=<span class="variable">$&#123;TARGET_PREFIX&#125;</span>/include</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br></pre></td></tr></table></figure></p>
<p>如果您想包含Linux threads选项，需要在configure脚本中添加<code>--enable-add-ons</code>选项。同样，这个过程需要一些时间来完成。从来没有人说构建交叉编译器是快速的。</p>
<p>要安装glibc，您仍然使用make，但是您显式地设置了安装根并清空了前缀(否则，这两者将被连接起来，这不是您想要的)：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make install_root=<span class="variable">$&#123;TARGET_PREFIX&#125;</span> prefix=<span class="string">&quot;&quot;</span> install</span></span><br></pre></td></tr></table></figure></p>
<p>最后，您可以构建gcc的最终版本，它现在使用上面的库和头信息。</p>
<h3 id="构建最终的GCC"><a href="#构建最终的GCC" class="headerlink" title="构建最终的GCC"></a>构建最终的GCC</h3><p>最后的GCC使用您刚刚编译的头文件和库(使用您选择的目标)构建完整的gcc系统。不幸的是，这意味着在构建完整的gcc版本时，等待的时间更长。我只使用gcc构建了一个C编译器，而不是构建完整的套件。</p>
<p>您不需要担心旧的gcc构建，因此您可以删除该内容，然后在build-gcc目录中重新启动。配置与前面的示例一样。注意，因为您正在构建一个将在这个平台上执行的工具，所以您将回到使用宿主GCC编译器，而不是之前构建的引导GCC编译器:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build-gcc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf *</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../gcc-3.3.2/configure --enable-languages=c --target=<span class="variable">$TARGET</span> --prefix=<span class="variable">$PREFIX</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p>
<p>因为您正在为目标平台构建完整的newlib和gcc组件，如果不在distcc主机列表中的其他机器上安装这些组件，就不可能使用distcc。即使使用distcc，也需要一些时间，即使是在高速机器上。如果可能的话，我倾向于让这些构建在夜间运行——部分原因是时间，但部分原因是它增加了构建机器(或多个机器)的负载，如果您的机器同时用于其他目的，这可能会很烦人。</p>
<p>不过，当构建完成后，就可以开始使用交叉编译器来构建目标平台所需的其他应用程序和库了。</p>
<h2 id="Section-5-安装并使用交叉编译器"><a href="#Section-5-安装并使用交叉编译器" class="headerlink" title="Section 5. 安装并使用交叉编译器"></a>Section 5. 安装并使用交叉编译器</h2><h3 id="使用你的交叉编译器"><a href="#使用你的交叉编译器" class="headerlink" title="使用你的交叉编译器"></a>使用你的交叉编译器</h3><p>实际上使用交叉编译器很容易。要编译一个简单的C文件，只需直接调用交叉编译器：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> i386-linux-gcc myapp.c -o myapp</span></span><br></pre></td></tr></table></figure></p>
<p>GCC交叉编译器的工作原理与本地版本一样:它只是为另一个平台创建了不同类型的可执行文件。这意味着您可以使用相同的命令行选项,如头和库位置、优化和调试。(请记住,您不能将不同目标平台的库连接起来,并期望它们能够工作。)在下一个面板中,我将向您展示如何使用新的跨编译器构建库和扩展。</p>
<p>对于具有Makefile的应用程序和项目，请在要生成的命令行上指定交叉编译器。例如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make CC=i386-linux-gcc</span></span><br></pre></td></tr></table></figure></p>
<p>或者，更改Makefile中的CC定义。</p>
<h3 id="编译其他工具和库"><a href="#编译其他工具和库" class="headerlink" title="编译其他工具和库"></a>编译其他工具和库</h3><p>您可能希望在目标平台上使用的任何库都需要使用交叉编译器进行编译，以便它们能够工作。对于大多数库，应用与构建自己的项目相同的基本规则。如果一个系统使用一个简单的Makefile,使用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make CC=i386-linux-gcc</span></span><br></pre></td></tr></table></figure>
<p>或者，如果使用configure脚本，在configure命令前面加上重新定义CC环境变量的前缀：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC=i386-linux-gcc ./configure</span><br></pre></td></tr></table></figure></p>
<p>使用gnu风格的配置脚本，您可能还需要指定主机：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure --host=i386-linux</span></span><br></pre></td></tr></table></figure></p>
<p>记住，对于库，您需要指定目标前缀，就像您在构建glibc或newlib时所做的那样。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>译</tag>
      </tags>
  </entry>
</search>
